function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~layouts-auth-auth-module~pages-dashboard-dashboard-module~pages-relatorios-relatorios-module"], {
  /***/
  "./node_modules/@fullcalendar/angular/__ivy_ngcc__/fesm2015/fullcalendar-angular.js":
  /*!******************************************************************************************!*\
    !*** ./node_modules/@fullcalendar/angular/__ivy_ngcc__/fesm2015/fullcalendar-angular.js ***!
    \******************************************************************************************/

  /*! exports provided: FullCalendarComponent, FullCalendarModule */

  /***/
  function node_modulesFullcalendarAngular__ivy_ngcc__Fesm2015FullcalendarAngularJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FullCalendarComponent", function () {
      return FullCalendarComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FullCalendarModule", function () {
      return FullCalendarModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var fast_deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! fast-deep-equal */
    "./node_modules/fast-deep-equal/index.js");
    /* harmony import */


    var fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @fullcalendar/core */
    "./node_modules/@fullcalendar/core/main.esm.js");

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /*
    Really simple clone utility. Only copies plain arrays, objects, and Dates. Transfers everything else as-is.
    Wanted to use a third-party lib, but none did exactly this.
    */

    function deepCopy(input) {
      if (Array.isArray(input)) {
        return input.map(deepCopy);
      } else if (input instanceof Date) {
        return new Date(input.valueOf());
      } else if (typeof input === 'object' && input) {
        // non-null object
        return mapHash(input, deepCopy);
      } else {
        // everything else (null, function, etc)
        return input;
      }
    }

    function mapHash(input, func) {
      var output = {};

      for (var key in input) {
        if (hasOwnProperty.call(input, key)) {
          output[key] = func(input[key], key);
        }
      }

      return output;
    }
    /*
    the docs point to this file as an index of options.
    when this files is moved, update the docs.
    */


    var INPUT_NAMES = ['header', 'footer', 'customButtons', 'buttonIcons', 'themeSystem', 'bootstrapFontAwesome', 'firstDay', 'dir', 'weekends', 'hiddenDays', 'fixedWeekCount', 'weekNumbers', 'weekNumbersWithinDays', 'weekNumberCalculation', 'businessHours', 'showNonCurrentDates', 'height', 'contentHeight', 'aspectRatio', 'handleWindowResize', 'windowResizeDelay', 'eventLimit', 'eventLimitClick', 'timeZone', 'now', 'defaultView', 'allDaySlot', 'allDayText', 'slotDuration', 'slotLabelFormat', 'slotLabelInterval', 'snapDuration', 'scrollTime', 'minTime', 'maxTime', 'slotEventOverlap', 'listDayFormat', 'listDayAltFormat', 'noEventsMessage', 'defaultDate', 'nowIndicator', 'visibleRange', 'validRange', 'dateIncrement', 'dateAlignment', 'duration', 'dayCount', 'locales', 'locale', 'eventTimeFormat', 'columnHeader', 'columnHeaderFormat', 'columnHeaderText', 'columnHeaderHtml', 'titleFormat', 'weekLabel', 'displayEventTime', 'displayEventEnd', 'eventLimitText', 'dayPopoverFormat', 'navLinks', 'selectable', 'selectMirror', 'selectMinDistance', 'unselectAuto', 'unselectCancel', 'defaultAllDayEventDuration', 'defaultTimedEventDuration', 'cmdFormatter', 'defaultRangeSeparator', 'selectConstraint', 'selectOverlap', 'selectAllow', 'editable', 'eventStartEditable', 'eventDurationEditable', 'eventConstraint', 'eventOverlap', 'eventAllow', 'eventClassName', 'eventClassNames', 'eventBackgroundColor', 'eventBorderColor', 'eventTextColor', 'eventColor', 'events', 'eventSources', 'allDayDefault', 'startParam', 'endParam', 'lazyFetching', 'nextDayThreshold', 'eventOrder', 'rerenderDelay', 'dragRevertDuration', 'dragScroll', 'longPressDelay', 'eventLongPressDelay', 'droppable', 'dropAccept', 'eventDataTransform', 'allDayMaintainDuration', 'eventResizableFromStart', 'timeGridEventMinHeight', 'allDayHtml', 'eventDragMinDistance', 'eventSourceFailure', 'eventSourceSuccess', 'forceEventDuration', 'progressiveEventRendering', 'selectLongPressDelay', 'selectMinDistance', 'timeZoneParam', 'titleRangeSeparator', // compound OptionsInput...
    'buttonText', 'views', 'plugins', // scheduler...
    'schedulerLicenseKey', 'resources', 'resourceLabelText', 'resourceOrder', 'filterResourcesWithEvents', 'resourceText', 'resourceGroupField', 'resourceGroupText', 'resourceAreaWidth', 'resourceColumns', 'resourcesInitiallyExpanded', 'slotWidth', 'datesAboveResources', 'googleCalendarApiKey', 'refetchResourcesOnNavigate', 'eventResourceEditable'];
    var INPUT_IS_DEEP = {
      header: true,
      footer: true,
      events: true,
      eventSources: true,
      resources: true
    };
    var OUTPUT_NAMES = ['windowResize', 'dateClick', 'eventClick', 'navLinkDayClick', 'navLinkWeekClick', 'eventMouseEnter', 'eventMouseLeave', 'select', 'unselect', 'loading', 'eventPositioned', 'eventDragStart', 'eventDragStop', 'eventDrop', 'eventResizeStart', 'eventResizeStop', 'eventResize', 'drop', 'eventReceive', 'eventLeave', '_destroyed', // TODO: make these inputs...
    'viewSkeletonRender', 'viewSkeletonDestroy', 'datesRender', 'datesDestroy', 'dayRender', 'eventRender', 'eventDestroy', 'resourceRender'];

    var FullCalendarComponent = /*#__PURE__*/function () {
      function FullCalendarComponent(element) {
        _classCallCheck(this, FullCalendarComponent);

        this.element = element;
        this.dirtyProps = {};
        this.deepCopies = {}; // holds frozen states

        this.windowResize = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.dateClick = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventClick = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventMouseEnter = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventMouseLeave = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.select = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.unselect = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.loading = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventPositioned = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventDragStart = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventDragStop = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventDrop = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventResizeStart = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventResizeStop = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventResize = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.drop = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventReceive = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventLeave = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this._destroyed = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.navLinkDayClick = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.navLinkWeekClick = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"](); // TODO: make these inputs...

        this.viewSkeletonRender = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.viewSkeletonDestroy = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.datesRender = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.datesDestroy = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.dayRender = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventRender = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.eventDestroy = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
        this.resourceRender = new _angular_core__WEBPACK_IMPORTED_MODULE_2__["EventEmitter"]();
      }

      _createClass(FullCalendarComponent, [{
        key: "ngAfterViewInit",
        value: function ngAfterViewInit() {
          this.calendar = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_3__["Calendar"](this.element.nativeElement, this.buildOptions());
          this.calendar.render();
        }
      }, {
        key: "buildOptions",
        value: function buildOptions() {
          var _this2 = this;

          var options = {};
          OUTPUT_NAMES.forEach(function (outputName) {
            options[outputName] = function () {
              var _this2$outputName;

              (_this2$outputName = _this2[outputName]).emit.apply(_this2$outputName, arguments);
            };
          }); // do after outputs, so that inputs with same name override

          INPUT_NAMES.forEach(function (inputName) {
            var inputVal = _this2[inputName];

            if (inputVal !== undefined) {
              // unfortunately FC chokes when some props are set to undefined
              if (_this2.deepChangeDetection && INPUT_IS_DEEP[inputName]) {
                inputVal = deepCopy(inputVal);
                _this2.deepCopies[inputName] = inputVal; // side effect!
              }

              options[inputName] = inputVal;
            }
          });
          return options;
        }
        /*
        called before ngOnChanges, allows us to manually detect input changes.
        called much more often than ngOnChanges.
        */

      }, {
        key: "ngDoCheck",
        value: function ngDoCheck() {
          if (this.calendar && this.deepChangeDetection) {
            // not the initial render AND we do deep-mutation checks
            var deepCopies = this.deepCopies;

            for (var inputName in INPUT_IS_DEEP) {
              if (INPUT_IS_DEEP.hasOwnProperty(inputName)) {
                var inputVal = this[inputName];

                if (inputVal !== undefined) {
                  // unfortunately FC chokes when some props are set to undefined
                  if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(inputVal, deepCopies[inputName])) {
                    var copy = deepCopy(inputVal);
                    deepCopies[inputName] = copy;
                    this.dirtyProps[inputName] = copy;
                  }
                }
              }
            }
          }
        }
        /*
        called with confirmed changes to input references
        */

      }, {
        key: "ngOnChanges",
        value: function ngOnChanges(changes) {
          if (this.calendar) {
            // not the initial render
            for (var inputName in changes) {
              if (changes.hasOwnProperty(inputName)) {
                if (this.deepCopies[inputName] === undefined) {
                  // not already handled in ngDoCheck
                  this.dirtyProps[inputName] = changes[inputName].currentValue;
                }
              }
            }
          }
        }
      }, {
        key: "ngAfterContentChecked",
        value: function ngAfterContentChecked() {
          var dirtyProps = this.dirtyProps; // hold on to reference before clearing

          if (Object.keys(dirtyProps).length > 0) {
            this.dirtyProps = {}; // clear first, in case the rerender causes new dirtiness

            this.calendar.mutateOptions(dirtyProps, [], false, fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default.a);
          }
        }
      }, {
        key: "ngOnDestroy",
        value: function ngOnDestroy() {
          if (this.calendar) {
            this.calendar.destroy();
          }

          this.calendar = null;
        }
      }, {
        key: "getApi",
        value: function getApi() {
          return this.calendar;
        }
      }]);

      return FullCalendarComponent;
    }();

    FullCalendarComponent.ɵfac = function FullCalendarComponent_Factory(t) {
      return new (t || FullCalendarComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]));
    };

    FullCalendarComponent.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]({
      type: FullCalendarComponent,
      selectors: [["full-calendar"]],
      inputs: {
        deepChangeDetection: "deepChangeDetection",
        header: "header",
        footer: "footer",
        customButtons: "customButtons",
        buttonIcons: "buttonIcons",
        themeSystem: "themeSystem",
        bootstrapFontAwesome: "bootstrapFontAwesome",
        firstDay: "firstDay",
        dir: "dir",
        weekends: "weekends",
        hiddenDays: "hiddenDays",
        fixedWeekCount: "fixedWeekCount",
        weekNumbers: "weekNumbers",
        weekNumbersWithinDays: "weekNumbersWithinDays",
        weekNumberCalculation: "weekNumberCalculation",
        businessHours: "businessHours",
        showNonCurrentDates: "showNonCurrentDates",
        height: "height",
        contentHeight: "contentHeight",
        aspectRatio: "aspectRatio",
        handleWindowResize: "handleWindowResize",
        windowResizeDelay: "windowResizeDelay",
        eventLimit: "eventLimit",
        eventLimitClick: "eventLimitClick",
        timeZone: "timeZone",
        now: "now",
        defaultView: "defaultView",
        allDaySlot: "allDaySlot",
        allDayText: "allDayText",
        slotDuration: "slotDuration",
        slotLabelFormat: "slotLabelFormat",
        slotLabelInterval: "slotLabelInterval",
        snapDuration: "snapDuration",
        scrollTime: "scrollTime",
        minTime: "minTime",
        maxTime: "maxTime",
        slotEventOverlap: "slotEventOverlap",
        listDayFormat: "listDayFormat",
        listDayAltFormat: "listDayAltFormat",
        noEventsMessage: "noEventsMessage",
        defaultDate: "defaultDate",
        nowIndicator: "nowIndicator",
        visibleRange: "visibleRange",
        validRange: "validRange",
        dateIncrement: "dateIncrement",
        dateAlignment: "dateAlignment",
        duration: "duration",
        dayCount: "dayCount",
        locales: "locales",
        locale: "locale",
        eventTimeFormat: "eventTimeFormat",
        columnHeader: "columnHeader",
        columnHeaderFormat: "columnHeaderFormat",
        columnHeaderText: "columnHeaderText",
        columnHeaderHtml: "columnHeaderHtml",
        titleFormat: "titleFormat",
        weekLabel: "weekLabel",
        displayEventTime: "displayEventTime",
        displayEventEnd: "displayEventEnd",
        eventLimitText: "eventLimitText",
        dayPopoverFormat: "dayPopoverFormat",
        navLinks: "navLinks",
        selectable: "selectable",
        selectMirror: "selectMirror",
        unselectAuto: "unselectAuto",
        unselectCancel: "unselectCancel",
        defaultAllDayEventDuration: "defaultAllDayEventDuration",
        defaultTimedEventDuration: "defaultTimedEventDuration",
        cmdFormatter: "cmdFormatter",
        defaultRangeSeparator: "defaultRangeSeparator",
        selectConstraint: "selectConstraint",
        selectOverlap: "selectOverlap",
        selectAllow: "selectAllow",
        selectMinDistance: "selectMinDistance",
        editable: "editable",
        eventStartEditable: "eventStartEditable",
        eventDurationEditable: "eventDurationEditable",
        eventConstraint: "eventConstraint",
        eventOverlap: "eventOverlap",
        eventAllow: "eventAllow",
        eventClassName: "eventClassName",
        eventClassNames: "eventClassNames",
        eventBackgroundColor: "eventBackgroundColor",
        eventBorderColor: "eventBorderColor",
        eventTextColor: "eventTextColor",
        eventColor: "eventColor",
        events: "events",
        eventSources: "eventSources",
        allDayDefault: "allDayDefault",
        startParam: "startParam",
        endParam: "endParam",
        lazyFetching: "lazyFetching",
        nextDayThreshold: "nextDayThreshold",
        eventOrder: "eventOrder",
        rerenderDelay: "rerenderDelay",
        dragRevertDuration: "dragRevertDuration",
        dragScroll: "dragScroll",
        longPressDelay: "longPressDelay",
        eventLongPressDelay: "eventLongPressDelay",
        droppable: "droppable",
        dropAccept: "dropAccept",
        eventDataTransform: "eventDataTransform",
        allDayMaintainDuration: "allDayMaintainDuration",
        eventResizableFromStart: "eventResizableFromStart",
        timeGridEventMinHeight: "timeGridEventMinHeight",
        allDayHtml: "allDayHtml",
        eventDragMinDistance: "eventDragMinDistance",
        eventSourceFailure: "eventSourceFailure",
        eventSourceSuccess: "eventSourceSuccess",
        forceEventDuration: "forceEventDuration",
        progressiveEventRendering: "progressiveEventRendering",
        selectLongPressDelay: "selectLongPressDelay",
        timeZoneParam: "timeZoneParam",
        titleRangeSeparator: "titleRangeSeparator",
        buttonText: "buttonText",
        views: "views",
        plugins: "plugins",
        schedulerLicenseKey: "schedulerLicenseKey",
        resources: "resources",
        resourceLabelText: "resourceLabelText",
        resourceOrder: "resourceOrder",
        filterResourcesWithEvents: "filterResourcesWithEvents",
        resourceText: "resourceText",
        resourceGroupField: "resourceGroupField",
        resourceGroupText: "resourceGroupText",
        resourceAreaWidth: "resourceAreaWidth",
        resourceColumns: "resourceColumns",
        resourcesInitiallyExpanded: "resourcesInitiallyExpanded",
        slotWidth: "slotWidth",
        datesAboveResources: "datesAboveResources",
        googleCalendarApiKey: "googleCalendarApiKey",
        refetchResourcesOnNavigate: "refetchResourcesOnNavigate",
        eventResourceEditable: "eventResourceEditable"
      },
      outputs: {
        windowResize: "windowResize",
        dateClick: "dateClick",
        eventClick: "eventClick",
        eventMouseEnter: "eventMouseEnter",
        eventMouseLeave: "eventMouseLeave",
        select: "select",
        unselect: "unselect",
        loading: "loading",
        eventPositioned: "eventPositioned",
        eventDragStart: "eventDragStart",
        eventDragStop: "eventDragStop",
        eventDrop: "eventDrop",
        eventResizeStart: "eventResizeStart",
        eventResizeStop: "eventResizeStop",
        eventResize: "eventResize",
        drop: "drop",
        eventReceive: "eventReceive",
        eventLeave: "eventLeave",
        _destroyed: "_destroyed",
        navLinkDayClick: "navLinkDayClick",
        navLinkWeekClick: "navLinkWeekClick",
        viewSkeletonRender: "viewSkeletonRender",
        viewSkeletonDestroy: "viewSkeletonDestroy",
        datesRender: "datesRender",
        datesDestroy: "datesDestroy",
        dayRender: "dayRender",
        eventRender: "eventRender",
        eventDestroy: "eventDestroy",
        resourceRender: "resourceRender"
      },
      features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]],
      decls: 0,
      vars: 0,
      template: function FullCalendarComponent_Template(rf, ctx) {},
      encapsulation: 2
    });

    FullCalendarComponent.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "deepChangeDetection", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "header", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "footer", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "customButtons", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "buttonIcons", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "themeSystem", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "bootstrapFontAwesome", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "firstDay", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "dir", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "weekends", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)], FullCalendarComponent.prototype, "hiddenDays", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "fixedWeekCount", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "weekNumbers", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "weekNumbersWithinDays", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "weekNumberCalculation", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "businessHours", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "showNonCurrentDates", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "height", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "contentHeight", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "aspectRatio", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "handleWindowResize", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "windowResizeDelay", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventLimit", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventLimitClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "timeZone", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "now", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "defaultView", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "allDaySlot", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "allDayText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "slotDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "slotLabelFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "slotLabelInterval", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "snapDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "scrollTime", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "minTime", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "maxTime", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "slotEventOverlap", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "listDayFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "listDayAltFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "noEventsMessage", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "defaultDate", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "nowIndicator", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "visibleRange", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "validRange", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "dateIncrement", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "dateAlignment", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "duration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "dayCount", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)], FullCalendarComponent.prototype, "locales", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "locale", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventTimeFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "columnHeader", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "columnHeaderFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "columnHeaderText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "columnHeaderHtml", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "titleFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "weekLabel", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "displayEventTime", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "displayEventEnd", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventLimitText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "dayPopoverFormat", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "navLinks", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "selectable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "selectMirror", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "unselectAuto", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "unselectCancel", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "defaultAllDayEventDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "defaultTimedEventDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "cmdFormatter", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "defaultRangeSeparator", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "selectConstraint", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "selectOverlap", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "selectAllow", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "selectMinDistance", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "editable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "eventStartEditable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "eventDurationEditable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventConstraint", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventOverlap", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventAllow", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventClassName", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventClassNames", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "eventBackgroundColor", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "eventBorderColor", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "eventTextColor", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "eventColor", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "events", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)], FullCalendarComponent.prototype, "eventSources", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "allDayDefault", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "startParam", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "endParam", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "lazyFetching", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "nextDayThreshold", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventOrder", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "rerenderDelay", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "dragRevertDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "dragScroll", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "longPressDelay", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "eventLongPressDelay", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "droppable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "dropAccept", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventDataTransform", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "allDayMaintainDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "eventResizableFromStart", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "timeGridEventMinHeight", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "allDayHtml", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "eventDragMinDistance", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventSourceFailure", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventSourceSuccess", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "forceEventDuration", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "progressiveEventRendering", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Number)], FullCalendarComponent.prototype, "selectLongPressDelay", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "timeZoneParam", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "titleRangeSeparator", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "buttonText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "views", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Array)], FullCalendarComponent.prototype, "plugins", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "schedulerLicenseKey", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resources", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "resourceLabelText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceOrder", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "filterResourcesWithEvents", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceGroupField", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceGroupText", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceAreaWidth", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceColumns", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourcesInitiallyExpanded", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "slotWidth", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "datesAboveResources", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", String)], FullCalendarComponent.prototype, "googleCalendarApiKey", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "refetchResourcesOnNavigate", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Boolean)], FullCalendarComponent.prototype, "eventResourceEditable", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "windowResize", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "dateClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventMouseEnter", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventMouseLeave", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "select", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "unselect", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "loading", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventPositioned", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventDragStart", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventDragStop", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventDrop", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventResizeStart", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventResizeStop", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventResize", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "drop", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventReceive", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventLeave", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "_destroyed", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "navLinkDayClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "navLinkWeekClick", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "viewSkeletonRender", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "viewSkeletonDestroy", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "datesRender", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "datesDestroy", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "dayRender", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventRender", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "eventDestroy", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"])(), Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:type", Object)], FullCalendarComponent.prototype, "resourceRender", void 0);
    FullCalendarComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__metadata"])("design:paramtypes", [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]])], FullCalendarComponent);

    var FullCalendarModule = /*#__PURE__*/_createClass(function FullCalendarModule() {
      _classCallCheck(this, FullCalendarModule);
    });

    FullCalendarModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineNgModule"]({
      type: FullCalendarModule
    });
    FullCalendarModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineInjector"]({
      factory: function FullCalendarModule_Factory(t) {
        return new (t || FullCalendarModule)();
      },
      imports: [[]]
    });
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](FullCalendarComponent, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Component"],
        args: [{
          selector: 'full-calendar',
          template: ''
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["ElementRef"]
        }];
      }, {
        windowResize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        dateClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventMouseEnter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventMouseLeave: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        select: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        unselect: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        loading: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventPositioned: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventDragStart: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventDragStop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventDrop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventResizeStart: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventResizeStop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventResize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        drop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventReceive: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventLeave: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        _destroyed: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        navLinkDayClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        navLinkWeekClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        viewSkeletonRender: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        viewSkeletonDestroy: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        datesRender: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        datesDestroy: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        dayRender: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventRender: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        eventDestroy: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        resourceRender: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Output"]
        }],
        deepChangeDetection: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        header: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        footer: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        customButtons: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        buttonIcons: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        themeSystem: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        bootstrapFontAwesome: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        firstDay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dir: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        weekends: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        hiddenDays: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        fixedWeekCount: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        weekNumbers: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        weekNumbersWithinDays: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        weekNumberCalculation: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        businessHours: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        showNonCurrentDates: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        height: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        contentHeight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        aspectRatio: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        handleWindowResize: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        windowResizeDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventLimit: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventLimitClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        timeZone: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        now: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        defaultView: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        allDaySlot: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        allDayText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        slotDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        slotLabelFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        slotLabelInterval: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        snapDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        scrollTime: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        minTime: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        maxTime: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        slotEventOverlap: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        listDayFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        listDayAltFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        noEventsMessage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        defaultDate: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        nowIndicator: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        visibleRange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        validRange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dateIncrement: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dateAlignment: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        duration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dayCount: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        locales: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        locale: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventTimeFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        columnHeader: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        columnHeaderFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        columnHeaderText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        columnHeaderHtml: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        titleFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        weekLabel: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        displayEventTime: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        displayEventEnd: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventLimitText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dayPopoverFormat: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        navLinks: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectMirror: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        unselectAuto: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        unselectCancel: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        defaultAllDayEventDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        defaultTimedEventDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        cmdFormatter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        defaultRangeSeparator: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectConstraint: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectOverlap: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectAllow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectMinDistance: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        editable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventStartEditable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventDurationEditable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventConstraint: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventOverlap: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventAllow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventClassName: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventClassNames: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventBackgroundColor: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventBorderColor: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventTextColor: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventColor: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        events: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventSources: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        allDayDefault: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        startParam: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        endParam: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        lazyFetching: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        nextDayThreshold: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventOrder: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        rerenderDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dragRevertDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dragScroll: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        longPressDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventLongPressDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        droppable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        dropAccept: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventDataTransform: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        allDayMaintainDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventResizableFromStart: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        timeGridEventMinHeight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        allDayHtml: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventDragMinDistance: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventSourceFailure: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventSourceSuccess: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        forceEventDuration: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        progressiveEventRendering: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        selectLongPressDelay: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        timeZoneParam: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        titleRangeSeparator: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        buttonText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        views: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        plugins: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        schedulerLicenseKey: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resources: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceLabelText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceOrder: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        filterResourcesWithEvents: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceGroupField: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceGroupText: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceAreaWidth: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourceColumns: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        resourcesInitiallyExpanded: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        slotWidth: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        datesAboveResources: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        googleCalendarApiKey: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        refetchResourcesOnNavigate: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }],
        eventResourceEditable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["Input"]
        }]
      });
    })();

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵsetNgModuleScope"](FullCalendarModule, {
        declarations: [FullCalendarComponent],
        exports: [FullCalendarComponent]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](FullCalendarModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_2__["NgModule"],
        args: [{
          declarations: [FullCalendarComponent],
          imports: [],
          exports: [FullCalendarComponent]
        }]
      }], null, null);
    })();
    /*
     * Public API Surface of fullcalendar
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=fullcalendar-angular.js.map

    /***/

  },

  /***/
  "./node_modules/@fullcalendar/core/main.esm.js":
  /*!*****************************************************!*\
    !*** ./node_modules/@fullcalendar/core/main.esm.js ***!
    \*****************************************************/

  /*! exports provided: Calendar, Component, ComponentContext, DateComponent, DateEnv, DateProfileGenerator, DayHeader, DaySeries, DayTable, ElementDragging, ElementScrollController, EmitterMixin, EventApi, FgEventRenderer, FillRenderer, Interaction, Mixin, NamedTimeZoneImpl, PositionCache, ScrollComponent, ScrollController, Slicer, Splitter, Theme, View, WindowScrollController, addDays, addDurations, addMs, addWeeks, allowContextMenu, allowSelection, appendToElement, applyAll, applyMutationToEventStore, applyStyle, applyStyleProp, asRoughMinutes, asRoughMs, asRoughSeconds, buildGotoAnchorHtml, buildSegCompareObj, capitaliseFirstLetter, combineEventUis, compareByFieldSpec, compareByFieldSpecs, compareNumbers, compensateScroll, computeClippingRect, computeEdges, computeEventDraggable, computeEventEndResizable, computeEventStartResizable, computeFallbackHeaderFormat, computeHeightAndMargins, computeInnerRect, computeRect, computeVisibleDayRange, config, constrainPoint, createDuration, createElement, createEmptyEventStore, createEventInstance, createFormatter, createPlugin, cssToStr, debounce, diffDates, diffDayAndTime, diffDays, diffPoints, diffWeeks, diffWholeDays, diffWholeWeeks, disableCursor, distributeHeight, elementClosest, elementMatches, enableCursor, eventTupleToStore, filterEventStoreDefs, filterHash, findChildren, findElements, flexibleCompare, forceClassName, formatDate, formatIsoTimeString, formatRange, getAllDayHtml, getClippingParents, getDayClasses, getElSeg, getRectCenter, getRelevantEvents, globalDefaults, greatestDurationDenominator, hasBgRendering, htmlEscape, htmlToElement, insertAfterElement, interactionSettingsStore, interactionSettingsToStore, intersectRanges, intersectRects, isArraysEqual, isDateSpansEqual, isInt, isInteractionValid, isMultiDayRange, isPropsEqual, isPropsValid, isSingleDay, isValidDate, listenBySelector, mapHash, matchCellWidths, memoize, memoizeOutput, memoizeRendering, mergeEventStores, multiplyDuration, padStart, parseBusinessHours, parseDragMeta, parseEventDef, parseFieldSpecs, parseMarker, pointInsideRect, prependToElement, preventContextMenu, preventDefault, preventSelection, processScopedUiProps, rangeContainsMarker, rangeContainsRange, rangesEqual, rangesIntersect, refineProps, removeElement, removeExact, renderDateCell, requestJson, sliceEventStore, startOfDay, subtractInnerElHeight, translateRect, uncompensateScroll, undistributeHeight, unpromisify, version, whenTransitionDone, wholeDivideDurations */

  /***/
  function node_modulesFullcalendarCoreMainEsmJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Calendar", function () {
      return Calendar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Component", function () {
      return Component;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ComponentContext", function () {
      return ComponentContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DateComponent", function () {
      return DateComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DateEnv", function () {
      return DateEnv;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DateProfileGenerator", function () {
      return DateProfileGenerator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DayHeader", function () {
      return DayHeader;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DaySeries", function () {
      return DaySeries;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DayTable", function () {
      return DayTable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ElementDragging", function () {
      return ElementDragging;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ElementScrollController", function () {
      return ElementScrollController;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmitterMixin", function () {
      return EmitterMixin;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EventApi", function () {
      return EventApi;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FgEventRenderer", function () {
      return FgEventRenderer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FillRenderer", function () {
      return FillRenderer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Interaction", function () {
      return Interaction;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Mixin", function () {
      return Mixin;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NamedTimeZoneImpl", function () {
      return NamedTimeZoneImpl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PositionCache", function () {
      return PositionCache;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollComponent", function () {
      return ScrollComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollController", function () {
      return ScrollController;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Slicer", function () {
      return Slicer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Splitter", function () {
      return Splitter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Theme", function () {
      return Theme;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "View", function () {
      return View;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WindowScrollController", function () {
      return WindowScrollController;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "addDays", function () {
      return addDays;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "addDurations", function () {
      return addDurations;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "addMs", function () {
      return addMs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "addWeeks", function () {
      return addWeeks;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "allowContextMenu", function () {
      return allowContextMenu;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "allowSelection", function () {
      return allowSelection;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "appendToElement", function () {
      return appendToElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "applyAll", function () {
      return applyAll;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "applyMutationToEventStore", function () {
      return applyMutationToEventStore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "applyStyle", function () {
      return applyStyle;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "applyStyleProp", function () {
      return applyStyleProp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "asRoughMinutes", function () {
      return asRoughMinutes;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "asRoughMs", function () {
      return asRoughMs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "asRoughSeconds", function () {
      return asRoughSeconds;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buildGotoAnchorHtml", function () {
      return buildGotoAnchorHtml;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buildSegCompareObj", function () {
      return buildSegCompareObj;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "capitaliseFirstLetter", function () {
      return capitaliseFirstLetter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineEventUis", function () {
      return combineEventUis;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compareByFieldSpec", function () {
      return compareByFieldSpec;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compareByFieldSpecs", function () {
      return compareByFieldSpecs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compareNumbers", function () {
      return compareNumbers;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "compensateScroll", function () {
      return compensateScroll;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeClippingRect", function () {
      return computeClippingRect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeEdges", function () {
      return computeEdges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeEventDraggable", function () {
      return computeEventDraggable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeEventEndResizable", function () {
      return computeEventEndResizable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeEventStartResizable", function () {
      return computeEventStartResizable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeFallbackHeaderFormat", function () {
      return computeFallbackHeaderFormat;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeHeightAndMargins", function () {
      return computeHeightAndMargins;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeInnerRect", function () {
      return computeInnerRect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeRect", function () {
      return computeRect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "computeVisibleDayRange", function () {
      return computeVisibleDayRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "config", function () {
      return config;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "constrainPoint", function () {
      return constrainPoint;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createDuration", function () {
      return createDuration;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createElement", function () {
      return createElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createEmptyEventStore", function () {
      return createEmptyEventStore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createEventInstance", function () {
      return createEventInstance;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createFormatter", function () {
      return createFormatter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createPlugin", function () {
      return createPlugin;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "cssToStr", function () {
      return cssToStr;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "debounce", function () {
      return debounce;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffDates", function () {
      return diffDates;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffDayAndTime", function () {
      return diffDayAndTime;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffDays", function () {
      return diffDays;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffPoints", function () {
      return diffPoints;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffWeeks", function () {
      return diffWeeks;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffWholeDays", function () {
      return diffWholeDays;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "diffWholeWeeks", function () {
      return diffWholeWeeks;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "disableCursor", function () {
      return disableCursor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distributeHeight", function () {
      return distributeHeight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "elementClosest", function () {
      return elementClosest;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "elementMatches", function () {
      return elementMatches;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "enableCursor", function () {
      return enableCursor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "eventTupleToStore", function () {
      return eventTupleToStore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "filterEventStoreDefs", function () {
      return filterEventStoreDefs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "filterHash", function () {
      return filterHash;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "findChildren", function () {
      return findChildren;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "findElements", function () {
      return findElements;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "flexibleCompare", function () {
      return flexibleCompare;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "forceClassName", function () {
      return forceClassName;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "formatDate", function () {
      return formatDate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "formatIsoTimeString", function () {
      return formatIsoTimeString;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "formatRange", function () {
      return formatRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getAllDayHtml", function () {
      return getAllDayHtml;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getClippingParents", function () {
      return getClippingParents;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getDayClasses", function () {
      return getDayClasses;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getElSeg", function () {
      return getElSeg;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getRectCenter", function () {
      return getRectCenter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getRelevantEvents", function () {
      return getRelevantEvents;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "globalDefaults", function () {
      return globalDefaults;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "greatestDurationDenominator", function () {
      return greatestDurationDenominator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "hasBgRendering", function () {
      return hasBgRendering;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "htmlEscape", function () {
      return htmlEscape;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "htmlToElement", function () {
      return htmlToElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "insertAfterElement", function () {
      return insertAfterElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "interactionSettingsStore", function () {
      return interactionSettingsStore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "interactionSettingsToStore", function () {
      return interactionSettingsToStore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "intersectRanges", function () {
      return intersectRanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "intersectRects", function () {
      return intersectRects;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isArraysEqual", function () {
      return isArraysEqual;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isDateSpansEqual", function () {
      return isDateSpansEqual;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isInt", function () {
      return isInt;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isInteractionValid", function () {
      return isInteractionValid;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isMultiDayRange", function () {
      return isMultiDayRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isPropsEqual", function () {
      return isPropsEqual;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isPropsValid", function () {
      return isPropsValid;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isSingleDay", function () {
      return isSingleDay;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isValidDate", function () {
      return isValidDate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "listenBySelector", function () {
      return listenBySelector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mapHash", function () {
      return mapHash;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "matchCellWidths", function () {
      return matchCellWidths;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "memoize", function () {
      return memoize;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "memoizeOutput", function () {
      return memoizeOutput;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "memoizeRendering", function () {
      return memoizeRendering;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeEventStores", function () {
      return mergeEventStores;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "multiplyDuration", function () {
      return multiplyDuration;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "padStart", function () {
      return padStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseBusinessHours", function () {
      return parseBusinessHours;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseDragMeta", function () {
      return parseDragMeta;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseEventDef", function () {
      return parseEventDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseFieldSpecs", function () {
      return parseFieldSpecs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "parseMarker", function () {
      return parse;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pointInsideRect", function () {
      return pointInsideRect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "prependToElement", function () {
      return prependToElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "preventContextMenu", function () {
      return preventContextMenu;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "preventDefault", function () {
      return preventDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "preventSelection", function () {
      return preventSelection;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "processScopedUiProps", function () {
      return processScopedUiProps;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rangeContainsMarker", function () {
      return rangeContainsMarker;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rangeContainsRange", function () {
      return rangeContainsRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rangesEqual", function () {
      return rangesEqual;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rangesIntersect", function () {
      return rangesIntersect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "refineProps", function () {
      return refineProps;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "removeElement", function () {
      return removeElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "removeExact", function () {
      return removeExact;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "renderDateCell", function () {
      return renderDateCell;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "requestJson", function () {
      return requestJson;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sliceEventStore", function () {
      return sliceEventStore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "startOfDay", function () {
      return startOfDay;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subtractInnerElHeight", function () {
      return subtractInnerElHeight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "translateRect", function () {
      return translateRect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "uncompensateScroll", function () {
      return uncompensateScroll;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "undistributeHeight", function () {
      return undistributeHeight;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "unpromisify", function () {
      return unpromisify;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "version", function () {
      return version;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "whenTransitionDone", function () {
      return whenTransitionDone;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "wholeDivideDurations", function () {
      return wholeDivideDurations;
    });
    /*!
    FullCalendar Core Package v4.4.2
    Docs & License: https://fullcalendar.io/
    (c) 2019 Adam Shaw
    */
    // Creating
    // ----------------------------------------------------------------------------------------------------------------


    var elementPropHash = {
      className: true,
      colSpan: true,
      rowSpan: true
    };
    var containerTagHash = {
      '<tr': 'tbody',
      '<td': 'tr'
    };

    function createElement(tagName, attrs, content) {
      var el = document.createElement(tagName);

      if (attrs) {
        for (var attrName in attrs) {
          if (attrName === 'style') {
            applyStyle(el, attrs[attrName]);
          } else if (elementPropHash[attrName]) {
            el[attrName] = attrs[attrName];
          } else {
            el.setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      if (typeof content === 'string') {
        el.innerHTML = content; // shortcut. no need to process HTML in any way
      } else if (content != null) {
        appendToElement(el, content);
      }

      return el;
    }

    function htmlToElement(html) {
      html = html.trim();
      var container = document.createElement(computeContainerTag(html));
      container.innerHTML = html;
      return container.firstChild;
    }

    function htmlToElements(html) {
      return Array.prototype.slice.call(htmlToNodeList(html));
    }

    function htmlToNodeList(html) {
      html = html.trim();
      var container = document.createElement(computeContainerTag(html));
      container.innerHTML = html;
      return container.childNodes;
    } // assumes html already trimmed and tag names are lowercase


    function computeContainerTag(html) {
      return containerTagHash[html.substr(0, 3) // faster than using regex
      ] || 'div';
    }

    function appendToElement(el, content) {
      var childNodes = normalizeContent(content);

      for (var i = 0; i < childNodes.length; i++) {
        el.appendChild(childNodes[i]);
      }
    }

    function prependToElement(parent, content) {
      var newEls = normalizeContent(content);
      var afterEl = parent.firstChild || null; // if no firstChild, will append to end, but that's okay, b/c there were no children

      for (var i = 0; i < newEls.length; i++) {
        parent.insertBefore(newEls[i], afterEl);
      }
    }

    function insertAfterElement(refEl, content) {
      var newEls = normalizeContent(content);
      var afterEl = refEl.nextSibling || null;

      for (var i = 0; i < newEls.length; i++) {
        refEl.parentNode.insertBefore(newEls[i], afterEl);
      }
    }

    function normalizeContent(content) {
      var els;

      if (typeof content === 'string') {
        els = htmlToElements(content);
      } else if (content instanceof Node) {
        els = [content];
      } else {
        // Node[] or NodeList
        els = Array.prototype.slice.call(content);
      }

      return els;
    }

    function removeElement(el) {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } // Querying
    // ----------------------------------------------------------------------------------------------------------------
    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest


    var matchesMethod = Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.msMatchesSelector;

    var closestMethod = Element.prototype.closest || function (selector) {
      // polyfill
      var el = this;

      if (!document.documentElement.contains(el)) {
        return null;
      }

      do {
        if (elementMatches(el, selector)) {
          return el;
        }

        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType === 1);

      return null;
    };

    function elementClosest(el, selector) {
      return closestMethod.call(el, selector);
    }

    function elementMatches(el, selector) {
      return matchesMethod.call(el, selector);
    } // accepts multiple subject els
    // returns a real array. good for methods like forEach


    function findElements(container, selector) {
      var containers = container instanceof HTMLElement ? [container] : container;
      var allMatches = [];

      for (var i = 0; i < containers.length; i++) {
        var matches = containers[i].querySelectorAll(selector);

        for (var j = 0; j < matches.length; j++) {
          allMatches.push(matches[j]);
        }
      }

      return allMatches;
    } // accepts multiple subject els
    // only queries direct child elements


    function findChildren(parent, selector) {
      var parents = parent instanceof HTMLElement ? [parent] : parent;
      var allMatches = [];

      for (var i = 0; i < parents.length; i++) {
        var childNodes = parents[i].children; // only ever elements

        for (var j = 0; j < childNodes.length; j++) {
          var childNode = childNodes[j];

          if (!selector || elementMatches(childNode, selector)) {
            allMatches.push(childNode);
          }
        }
      }

      return allMatches;
    } // Attributes
    // ----------------------------------------------------------------------------------------------------------------


    function forceClassName(el, className, bool) {
      if (bool) {
        el.classList.add(className);
      } else {
        el.classList.remove(className);
      }
    } // Style
    // ----------------------------------------------------------------------------------------------------------------


    var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;

    function applyStyle(el, props) {
      for (var propName in props) {
        applyStyleProp(el, propName, props[propName]);
      }
    }

    function applyStyleProp(el, name, val) {
      if (val == null) {
        el.style[name] = '';
      } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {
        el.style[name] = val + 'px';
      } else {
        el.style[name] = val;
      }
    }

    function pointInsideRect(point, rect) {
      return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
    } // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false


    function intersectRects(rect1, rect2) {
      var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
      };

      if (res.left < res.right && res.top < res.bottom) {
        return res;
      }

      return false;
    }

    function translateRect(rect, deltaX, deltaY) {
      return {
        left: rect.left + deltaX,
        right: rect.right + deltaX,
        top: rect.top + deltaY,
        bottom: rect.bottom + deltaY
      };
    } // Returns a new point that will have been moved to reside within the given rectangle


    function constrainPoint(point, rect) {
      return {
        left: Math.min(Math.max(point.left, rect.left), rect.right),
        top: Math.min(Math.max(point.top, rect.top), rect.bottom)
      };
    } // Returns a point that is the center of the given rectangle


    function getRectCenter(rect) {
      return {
        left: (rect.left + rect.right) / 2,
        top: (rect.top + rect.bottom) / 2
      };
    } // Subtracts point2's coordinates from point1's coordinates, returning a delta


    function diffPoints(point1, point2) {
      return {
        left: point1.left - point2.left,
        top: point1.top - point2.top
      };
    } // Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side


    var isRtlScrollbarOnLeft = null;

    function getIsRtlScrollbarOnLeft() {
      if (isRtlScrollbarOnLeft === null) {
        isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
      }

      return isRtlScrollbarOnLeft;
    }

    function computeIsRtlScrollbarOnLeft() {
      var outerEl = createElement('div', {
        style: {
          position: 'absolute',
          top: -1000,
          left: 0,
          border: 0,
          padding: 0,
          overflow: 'scroll',
          direction: 'rtl'
        }
      }, '<div></div>');
      document.body.appendChild(outerEl);
      var innerEl = outerEl.firstChild;
      var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
      removeElement(outerEl);
      return res;
    } // The scrollbar width computations in computeEdges are sometimes flawed when it comes to
    // retina displays, rounding, and IE11. Massage them into a usable value.


    function sanitizeScrollbarWidth(width) {
      width = Math.max(0, width); // no negatives

      width = Math.round(width);
      return width;
    }

    function computeEdges(el, getPadding) {
      if (getPadding === void 0) {
        getPadding = false;
      }

      var computedStyle = window.getComputedStyle(el);
      var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
      var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
      var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
      var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0; // must use offset(Width|Height) because compatible with client(Width|Height)

      var scrollbarLeftRight = sanitizeScrollbarWidth(el.offsetWidth - el.clientWidth - borderLeft - borderRight);
      var scrollbarBottom = sanitizeScrollbarWidth(el.offsetHeight - el.clientHeight - borderTop - borderBottom);
      var res = {
        borderLeft: borderLeft,
        borderRight: borderRight,
        borderTop: borderTop,
        borderBottom: borderBottom,
        scrollbarBottom: scrollbarBottom,
        scrollbarLeft: 0,
        scrollbarRight: 0
      };

      if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {
        // is the scrollbar on the left side?
        res.scrollbarLeft = scrollbarLeftRight;
      } else {
        res.scrollbarRight = scrollbarLeftRight;
      }

      if (getPadding) {
        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
      }

      return res;
    }

    function computeInnerRect(el, goWithinPadding) {
      if (goWithinPadding === void 0) {
        goWithinPadding = false;
      }

      var outerRect = computeRect(el);
      var edges = computeEdges(el, goWithinPadding);
      var res = {
        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
        right: outerRect.right - edges.borderRight - edges.scrollbarRight,
        top: outerRect.top + edges.borderTop,
        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
      };

      if (goWithinPadding) {
        res.left += edges.paddingLeft;
        res.right -= edges.paddingRight;
        res.top += edges.paddingTop;
        res.bottom -= edges.paddingBottom;
      }

      return res;
    }

    function computeRect(el) {
      var rect = el.getBoundingClientRect();
      return {
        left: rect.left + window.pageXOffset,
        top: rect.top + window.pageYOffset,
        right: rect.right + window.pageXOffset,
        bottom: rect.bottom + window.pageYOffset
      };
    }

    function computeViewportRect() {
      return {
        left: window.pageXOffset,
        right: window.pageXOffset + document.documentElement.clientWidth,
        top: window.pageYOffset,
        bottom: window.pageYOffset + document.documentElement.clientHeight
      };
    }

    function computeHeightAndMargins(el) {
      return el.getBoundingClientRect().height + computeVMargins(el);
    }

    function computeVMargins(el) {
      var computed = window.getComputedStyle(el);
      return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);
    } // does not return window


    function getClippingParents(el) {
      var parents = [];

      while (el instanceof HTMLElement) {
        // will stop when gets to document or null
        var computedStyle = window.getComputedStyle(el);

        if (computedStyle.position === 'fixed') {
          break;
        }

        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
          parents.push(el);
        }

        el = el.parentNode;
      }

      return parents;
    }

    function computeClippingRect(el) {
      return getClippingParents(el).map(function (el) {
        return computeInnerRect(el);
      }).concat(computeViewportRect()).reduce(function (rect0, rect1) {
        return intersectRects(rect0, rect1) || rect1; // should always intersect
      });
    } // Stops a mouse/touch event from doing it's native browser action


    function preventDefault(ev) {
      ev.preventDefault();
    } // Event Delegation
    // ----------------------------------------------------------------------------------------------------------------


    function listenBySelector(container, eventType, selector, handler) {
      function realHandler(ev) {
        var matchedChild = elementClosest(ev.target, selector);

        if (matchedChild) {
          handler.call(matchedChild, ev, matchedChild);
        }
      }

      container.addEventListener(eventType, realHandler);
      return function () {
        container.removeEventListener(eventType, realHandler);
      };
    }

    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
      var currentMatchedChild;
      return listenBySelector(container, 'mouseover', selector, function (ev, matchedChild) {
        if (matchedChild !== currentMatchedChild) {
          currentMatchedChild = matchedChild;
          onMouseEnter(ev, matchedChild);

          var realOnMouseLeave_1 = function realOnMouseLeave_1(ev) {
            currentMatchedChild = null;
            onMouseLeave(ev, matchedChild);
            matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);
          }; // listen to the next mouseleave, and then unattach


          matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);
        }
      });
    } // Animation
    // ----------------------------------------------------------------------------------------------------------------


    var transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes

    function whenTransitionDone(el, callback) {
      var realCallback = function realCallback(ev) {
        callback(ev);
        transitionEventNames.forEach(function (eventName) {
          el.removeEventListener(eventName, realCallback);
        });
      };

      transitionEventNames.forEach(function (eventName) {
        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes
      });
    }

    var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding

    function addWeeks(m, n) {
      var a = dateToUtcArray(m);
      a[2] += n * 7;
      return arrayToUtcDate(a);
    }

    function addDays(m, n) {
      var a = dateToUtcArray(m);
      a[2] += n;
      return arrayToUtcDate(a);
    }

    function addMs(m, n) {
      var a = dateToUtcArray(m);
      a[6] += n;
      return arrayToUtcDate(a);
    } // Diffing (all return floats)


    function diffWeeks(m0, m1) {
      return diffDays(m0, m1) / 7;
    }

    function diffDays(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);
    }

    function diffHours(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);
    }

    function diffMinutes(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / (1000 * 60);
    }

    function diffSeconds(m0, m1) {
      return (m1.valueOf() - m0.valueOf()) / 1000;
    }

    function diffDayAndTime(m0, m1) {
      var m0day = startOfDay(m0);
      var m1day = startOfDay(m1);
      return {
        years: 0,
        months: 0,
        days: Math.round(diffDays(m0day, m1day)),
        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
      };
    } // Diffing Whole Units


    function diffWholeWeeks(m0, m1) {
      var d = diffWholeDays(m0, m1);

      if (d !== null && d % 7 === 0) {
        return d / 7;
      }

      return null;
    }

    function diffWholeDays(m0, m1) {
      if (timeAsMs(m0) === timeAsMs(m1)) {
        return Math.round(diffDays(m0, m1));
      }

      return null;
    } // Start-Of


    function startOfDay(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);
    }

    function startOfHour(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);
    }

    function startOfMinute(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);
    }

    function startOfSecond(m) {
      return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);
    } // Week Computation


    function weekOfYear(marker, dow, doy) {
      var y = marker.getUTCFullYear();
      var w = weekOfGivenYear(marker, y, dow, doy);

      if (w < 1) {
        return weekOfGivenYear(marker, y - 1, dow, doy);
      }

      var nextW = weekOfGivenYear(marker, y + 1, dow, doy);

      if (nextW >= 1) {
        return Math.min(w, nextW);
      }

      return w;
    }

    function weekOfGivenYear(marker, year, dow, doy) {
      var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
      var dayStart = startOfDay(marker);
      var days = Math.round(diffDays(firstWeekStart, dayStart));
      return Math.floor(days / 7) + 1; // zero-indexed
    } // start-of-first-week - start-of-year


    function firstWeekOffset(year, dow, doy) {
      // first-week day -- which january is always in the first week (4 for iso, 1 for other)
      var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd

      var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    } // Array Conversion


    function dateToLocalArray(date) {
      return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
    }

    function arrayToLocalDate(a) {
      return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month
      a[3] || 0, a[4] || 0, a[5] || 0);
    }

    function dateToUtcArray(date) {
      return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];
    }

    function arrayToUtcDate(a) {
      // according to web standards (and Safari), a month index is required.
      // massage if only given a year.
      if (a.length === 1) {
        a = a.concat([0]);
      }

      return new Date(Date.UTC.apply(Date, a));
    } // Other Utils


    function isValidDate(m) {
      return !isNaN(m.valueOf());
    }

    function timeAsMs(m) {
      return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();
    }

    var INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];
    var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; // Parsing and Creation

    function createDuration(input, unit) {
      var _a;

      if (typeof input === 'string') {
        return parseString(input);
      } else if (typeof input === 'object' && input) {
        // non-null object
        return normalizeObject(input);
      } else if (typeof input === 'number') {
        return normalizeObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));
      } else {
        return null;
      }
    }

    function parseString(s) {
      var m = PARSE_RE.exec(s);

      if (m) {
        var sign = m[1] ? -1 : 1;
        return {
          years: 0,
          months: 0,
          days: sign * (m[2] ? parseInt(m[2], 10) : 0),
          milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours
          (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes
          (m[5] ? parseInt(m[5], 10) : 0) * 1000 + ( // seconds
          m[6] ? parseInt(m[6], 10) : 0) // ms
          )
        };
      }

      return null;
    }

    function normalizeObject(obj) {
      return {
        years: obj.years || obj.year || 0,
        months: obj.months || obj.month || 0,
        days: (obj.days || obj.day || 0) + getWeeksFromInput(obj) * 7,
        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours
        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes
        (obj.seconds || obj.second || 0) * 1000 + ( // seconds
        obj.milliseconds || obj.millisecond || obj.ms || 0) // ms

      };
    }

    function getWeeksFromInput(obj) {
      return obj.weeks || obj.week || 0;
    } // Equality


    function durationsEqual(d0, d1) {
      return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
    }

    function isSingleDay(dur) {
      return dur.years === 0 && dur.months === 0 && dur.days === 1 && dur.milliseconds === 0;
    } // Simple Math


    function addDurations(d0, d1) {
      return {
        years: d0.years + d1.years,
        months: d0.months + d1.months,
        days: d0.days + d1.days,
        milliseconds: d0.milliseconds + d1.milliseconds
      };
    }

    function subtractDurations(d1, d0) {
      return {
        years: d1.years - d0.years,
        months: d1.months - d0.months,
        days: d1.days - d0.days,
        milliseconds: d1.milliseconds - d0.milliseconds
      };
    }

    function multiplyDuration(d, n) {
      return {
        years: d.years * n,
        months: d.months * n,
        days: d.days * n,
        milliseconds: d.milliseconds * n
      };
    } // Conversions
    // "Rough" because they are based on average-case Gregorian months/years


    function asRoughYears(dur) {
      return asRoughDays(dur) / 365;
    }

    function asRoughMonths(dur) {
      return asRoughDays(dur) / 30;
    }

    function asRoughDays(dur) {
      return asRoughMs(dur) / 864e5;
    }

    function asRoughMinutes(dur) {
      return asRoughMs(dur) / (1000 * 60);
    }

    function asRoughSeconds(dur) {
      return asRoughMs(dur) / 1000;
    }

    function asRoughMs(dur) {
      return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
    } // Advanced Math


    function wholeDivideDurations(numerator, denominator) {
      var res = null;

      for (var i = 0; i < INTERNAL_UNITS.length; i++) {
        var unit = INTERNAL_UNITS[i];

        if (denominator[unit]) {
          var localRes = numerator[unit] / denominator[unit];

          if (!isInt(localRes) || res !== null && res !== localRes) {
            return null;
          }

          res = localRes;
        } else if (numerator[unit]) {
          // needs to divide by something but can't!
          return null;
        }
      }

      return res;
    }

    function greatestDurationDenominator(dur, dontReturnWeeks) {
      var ms = dur.milliseconds;

      if (ms) {
        if (ms % 1000 !== 0) {
          return {
            unit: 'millisecond',
            value: ms
          };
        }

        if (ms % (1000 * 60) !== 0) {
          return {
            unit: 'second',
            value: ms / 1000
          };
        }

        if (ms % (1000 * 60 * 60) !== 0) {
          return {
            unit: 'minute',
            value: ms / (1000 * 60)
          };
        }

        if (ms) {
          return {
            unit: 'hour',
            value: ms / (1000 * 60 * 60)
          };
        }
      }

      if (dur.days) {
        if (!dontReturnWeeks && dur.days % 7 === 0) {
          return {
            unit: 'week',
            value: dur.days / 7
          };
        }

        return {
          unit: 'day',
          value: dur.days
        };
      }

      if (dur.months) {
        return {
          unit: 'month',
          value: dur.months
        };
      }

      if (dur.years) {
        return {
          unit: 'year',
          value: dur.years
        };
      }

      return {
        unit: 'millisecond',
        value: 0
      };
    }
    /* FullCalendar-specific DOM Utilities
    ----------------------------------------------------------------------------------------------------------------------*/
    // Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
    // and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.


    function compensateScroll(rowEl, scrollbarWidths) {
      if (scrollbarWidths.left) {
        applyStyle(rowEl, {
          borderLeftWidth: 1,
          marginLeft: scrollbarWidths.left - 1
        });
      }

      if (scrollbarWidths.right) {
        applyStyle(rowEl, {
          borderRightWidth: 1,
          marginRight: scrollbarWidths.right - 1
        });
      }
    } // Undoes compensateScroll and restores all borders/margins


    function uncompensateScroll(rowEl) {
      applyStyle(rowEl, {
        marginLeft: '',
        marginRight: '',
        borderLeftWidth: '',
        borderRightWidth: ''
      });
    } // Make the mouse cursor express that an event is not allowed in the current area


    function disableCursor() {
      document.body.classList.add('fc-not-allowed');
    } // Returns the mouse cursor to its original look


    function enableCursor() {
      document.body.classList.remove('fc-not-allowed');
    } // Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
    // By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
    // any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
    // reduces the available height.


    function distributeHeight(els, availableHeight, shouldRedistribute) {
      // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
      // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
      var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element

      var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*

      var flexEls = []; // elements that are allowed to expand. array of DOM nodes

      var flexOffsets = []; // amount of vertical space it takes up

      var flexHeights = []; // actual css height

      var usedHeight = 0;
      undistributeHeight(els); // give all elements their natural height
      // find elements that are below the recommended height (expandable).
      // important to query for heights in a single first pass (to avoid reflow oscillation).

      els.forEach(function (el, i) {
        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
        var naturalHeight = el.getBoundingClientRect().height;
        var naturalOffset = naturalHeight + computeVMargins(el);

        if (naturalOffset < minOffset) {
          flexEls.push(el);
          flexOffsets.push(naturalOffset);
          flexHeights.push(naturalHeight);
        } else {
          // this element stretches past recommended height (non-expandable). mark the space as occupied.
          usedHeight += naturalOffset;
        }
      }); // readjust the recommended height to only consider the height available to non-maxed-out rows.

      if (shouldRedistribute) {
        availableHeight -= usedHeight;
        minOffset1 = Math.floor(availableHeight / flexEls.length);
        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
      } // assign heights to all expandable elements


      flexEls.forEach(function (el, i) {
        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = flexOffsets[i];
        var naturalHeight = flexHeights[i];
        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

        if (naturalOffset < minOffset) {
          // we check this again because redistribution might have changed things
          el.style.height = newHeight + 'px';
        }
      });
    } // Undoes distrubuteHeight, restoring all els to their natural height


    function undistributeHeight(els) {
      els.forEach(function (el) {
        el.style.height = '';
      });
    } // Given `els`, a set of <td> cells, find the cell with the largest natural width and set the widths of all the
    // cells to be that width.
    // PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline


    function matchCellWidths(els) {
      var maxInnerWidth = 0;
      els.forEach(function (el) {
        var innerEl = el.firstChild; // hopefully an element

        if (innerEl instanceof HTMLElement) {
          var innerWidth_1 = innerEl.getBoundingClientRect().width;

          if (innerWidth_1 > maxInnerWidth) {
            maxInnerWidth = innerWidth_1;
          }
        }
      });
      maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

      els.forEach(function (el) {
        el.style.width = maxInnerWidth + 'px';
      });
      return maxInnerWidth;
    } // Given one element that resides inside another,
    // Subtracts the height of the inner element from the outer element.


    function subtractInnerElHeight(outerEl, innerEl) {
      // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
      var reflowStyleProps = {
        position: 'relative',
        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll

      };
      applyStyle(outerEl, reflowStyleProps);
      applyStyle(innerEl, reflowStyleProps);
      var diff = // grab the dimensions
      outerEl.getBoundingClientRect().height - innerEl.getBoundingClientRect().height; // undo hack

      var resetStyleProps = {
        position: '',
        left: ''
      };
      applyStyle(outerEl, resetStyleProps);
      applyStyle(innerEl, resetStyleProps);
      return diff;
    }
    /* Selection
    ----------------------------------------------------------------------------------------------------------------------*/


    function preventSelection(el) {
      el.classList.add('fc-unselectable');
      el.addEventListener('selectstart', preventDefault);
    }

    function allowSelection(el) {
      el.classList.remove('fc-unselectable');
      el.removeEventListener('selectstart', preventDefault);
    }
    /* Context Menu
    ----------------------------------------------------------------------------------------------------------------------*/


    function preventContextMenu(el) {
      el.addEventListener('contextmenu', preventDefault);
    }

    function allowContextMenu(el) {
      el.removeEventListener('contextmenu', preventDefault);
    }
    /* Object Ordering by Field
    ----------------------------------------------------------------------------------------------------------------------*/


    function parseFieldSpecs(input) {
      var specs = [];
      var tokens = [];
      var i;
      var token;

      if (typeof input === 'string') {
        tokens = input.split(/\s*,\s*/);
      } else if (typeof input === 'function') {
        tokens = [input];
      } else if (Array.isArray(input)) {
        tokens = input;
      }

      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];

        if (typeof token === 'string') {
          specs.push(token.charAt(0) === '-' ? {
            field: token.substring(1),
            order: -1
          } : {
            field: token,
            order: 1
          });
        } else if (typeof token === 'function') {
          specs.push({
            func: token
          });
        }
      }

      return specs;
    }

    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
      var i;
      var cmp;

      for (i = 0; i < fieldSpecs.length; i++) {
        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);

        if (cmp) {
          return cmp;
        }
      }

      return 0;
    }

    function compareByFieldSpec(obj0, obj1, fieldSpec) {
      if (fieldSpec.func) {
        return fieldSpec.func(obj0, obj1);
      }

      return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
    }

    function flexibleCompare(a, b) {
      if (!a && !b) {
        return 0;
      }

      if (b == null) {
        return -1;
      }

      if (a == null) {
        return 1;
      }

      if (typeof a === 'string' || typeof b === 'string') {
        return String(a).localeCompare(String(b));
      }

      return a - b;
    }
    /* String Utilities
    ----------------------------------------------------------------------------------------------------------------------*/


    function capitaliseFirstLetter(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function padStart(val, len) {
      var s = String(val);
      return '000'.substr(0, len - s.length) + s;
    }
    /* Number Utilities
    ----------------------------------------------------------------------------------------------------------------------*/


    function compareNumbers(a, b) {
      return a - b;
    }

    function isInt(n) {
      return n % 1 === 0;
    }
    /* Weird Utilities
    ----------------------------------------------------------------------------------------------------------------------*/


    function applyAll(functions, thisObj, args) {
      if (typeof functions === 'function') {
        // supplied a single function
        functions = [functions];
      }

      if (functions) {
        var i = void 0;
        var ret = void 0;

        for (i = 0; i < functions.length; i++) {
          ret = functions[i].apply(thisObj, args) || ret;
        }

        return ret;
      }
    }

    function firstDefined() {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      for (var i = 0; i < args.length; i++) {
        if (args[i] !== undefined) {
          return args[i];
        }
      }
    } // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    // https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714


    function debounce(func, wait) {
      var timeout;
      var args;
      var context;
      var timestamp;
      var result;

      var later = function later() {
        var last = new Date().valueOf() - timestamp;

        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          result = func.apply(context, args);
          context = args = null;
        }
      };

      return function () {
        context = this;
        args = arguments;
        timestamp = new Date().valueOf();

        if (!timeout) {
          timeout = setTimeout(later, wait);
        }

        return result;
      };
    } // Number and Boolean are only types that defaults or not computed for
    // TODO: write more comments


    function refineProps(rawProps, processors, defaults, leftoverProps) {
      if (defaults === void 0) {
        defaults = {};
      }

      var refined = {};

      for (var key in processors) {
        var processor = processors[key];

        if (rawProps[key] !== undefined) {
          // found
          if (processor === Function) {
            refined[key] = typeof rawProps[key] === 'function' ? rawProps[key] : null;
          } else if (processor) {
            // a refining function?
            refined[key] = processor(rawProps[key]);
          } else {
            refined[key] = rawProps[key];
          }
        } else if (defaults[key] !== undefined) {
          // there's an explicit default
          refined[key] = defaults[key];
        } else {
          // must compute a default
          if (processor === String) {
            refined[key] = ''; // empty string is default for String
          } else if (!processor || processor === Number || processor === Boolean || processor === Function) {
            refined[key] = null; // assign null for other non-custom processor funcs
          } else {
            refined[key] = processor(null); // run the custom processor func
          }
        }
      }

      if (leftoverProps) {
        for (var key in rawProps) {
          if (processors[key] === undefined) {
            leftoverProps[key] = rawProps[key];
          }
        }
      }

      return refined;
    }
    /* Date stuff that doesn't belong in datelib core
    ----------------------------------------------------------------------------------------------------------------------*/
    // given a timed range, computes an all-day range that has the same exact duration,
    // but whose start time is aligned with the start of the day.


    function computeAlignedDayRange(timedRange) {
      var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
      var start = startOfDay(timedRange.start);
      var end = addDays(start, dayCnt);
      return {
        start: start,
        end: end
      };
    } // given a timed range, computes an all-day range based on how for the end date bleeds into the next day
    // TODO: give nextDayThreshold a default arg


    function computeVisibleDayRange(timedRange, nextDayThreshold) {
      if (nextDayThreshold === void 0) {
        nextDayThreshold = createDuration(0);
      }

      var startDay = null;
      var endDay = null;

      if (timedRange.end) {
        endDay = startOfDay(timedRange.end);
        var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.

        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
          endDay = addDays(endDay, 1);
        }
      }

      if (timedRange.start) {
        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.

        if (endDay && endDay <= startDay) {
          endDay = addDays(startDay, 1);
        }
      }

      return {
        start: startDay,
        end: endDay
      };
    } // spans from one day into another?


    function isMultiDayRange(range) {
      var visibleRange = computeVisibleDayRange(range);
      return diffDays(visibleRange.start, visibleRange.end) > 1;
    }

    function diffDates(date0, date1, dateEnv, largeUnit) {
      if (largeUnit === 'year') {
        return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');
      } else if (largeUnit === 'month') {
        return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');
      } else {
        return diffDayAndTime(date0, date1); // returns a duration
      }
    }
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */


    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    function parseRecurring(eventInput, allDayDefault, dateEnv, recurringTypes, leftovers) {
      for (var i = 0; i < recurringTypes.length; i++) {
        var localLeftovers = {};
        var parsed = recurringTypes[i].parse(eventInput, localLeftovers, dateEnv);

        if (parsed) {
          var allDay = localLeftovers.allDay;
          delete localLeftovers.allDay; // remove from leftovers

          if (allDay == null) {
            allDay = allDayDefault;

            if (allDay == null) {
              allDay = parsed.allDayGuess;

              if (allDay == null) {
                allDay = false;
              }
            }
          }

          _assign(leftovers, localLeftovers);

          return {
            allDay: allDay,
            duration: parsed.duration,
            typeData: parsed.typeData,
            typeId: i
          };
        }
      }

      return null;
    }
    /*
    Event MUST have a recurringDef
    */


    function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
      var typeDef = recurringTypes[eventDef.recurringDef.typeId];
      var markers = typeDef.expand(eventDef.recurringDef.typeData, {
        start: dateEnv.subtract(framingRange.start, duration),
        end: framingRange.end
      }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to

      if (eventDef.allDay) {
        markers = markers.map(startOfDay);
      }

      return markers;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.
    // The second argument allows for an array of property names who's object values will be merged together.

    function mergeProps(propObjs, complexProps) {
      var dest = {};
      var i;
      var name;
      var complexObjs;
      var j;
      var val;
      var props;

      if (complexProps) {
        for (i = 0; i < complexProps.length; i++) {
          name = complexProps[i];
          complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered

          for (j = propObjs.length - 1; j >= 0; j--) {
            val = propObjs[j][name];

            if (typeof val === 'object' && val) {
              // non-null object
              complexObjs.unshift(val);
            } else if (val !== undefined) {
              dest[name] = val; // if there were no objects, this value will be used

              break;
            }
          } // if the trailing values were objects, use the merged value


          if (complexObjs.length) {
            dest[name] = mergeProps(complexObjs);
          }
        }
      } // copy values into the destination, going from last to first


      for (i = propObjs.length - 1; i >= 0; i--) {
        props = propObjs[i];

        for (name in props) {
          if (!(name in dest)) {
            // if already assigned by previous props or complex props, don't reassign
            dest[name] = props[name];
          }
        }
      }

      return dest;
    }

    function filterHash(hash, func) {
      var filtered = {};

      for (var key in hash) {
        if (func(hash[key], key)) {
          filtered[key] = hash[key];
        }
      }

      return filtered;
    }

    function mapHash(hash, func) {
      var newHash = {};

      for (var key in hash) {
        newHash[key] = func(hash[key], key);
      }

      return newHash;
    }

    function arrayToHash(a) {
      var hash = {};

      for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {
        var item = a_1[_i];
        hash[item] = true;
      }

      return hash;
    }

    function hashValuesToArray(obj) {
      var a = [];

      for (var key in obj) {
        a.push(obj[key]);
      }

      return a;
    }

    function isPropsEqual(obj0, obj1) {
      for (var key in obj0) {
        if (hasOwnProperty.call(obj0, key)) {
          if (!(key in obj1)) {
            return false;
          }
        }
      }

      for (var key in obj1) {
        if (hasOwnProperty.call(obj1, key)) {
          if (obj0[key] !== obj1[key]) {
            return false;
          }
        }
      }

      return true;
    }

    function parseEvents(rawEvents, sourceId, calendar, allowOpenRange) {
      var eventStore = createEmptyEventStore();

      for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {
        var rawEvent = rawEvents_1[_i];
        var tuple = parseEvent(rawEvent, sourceId, calendar, allowOpenRange);

        if (tuple) {
          eventTupleToStore(tuple, eventStore);
        }
      }

      return eventStore;
    }

    function eventTupleToStore(tuple, eventStore) {
      if (eventStore === void 0) {
        eventStore = createEmptyEventStore();
      }

      eventStore.defs[tuple.def.defId] = tuple.def;

      if (tuple.instance) {
        eventStore.instances[tuple.instance.instanceId] = tuple.instance;
      }

      return eventStore;
    }

    function expandRecurring(eventStore, framingRange, calendar) {
      var dateEnv = calendar.dateEnv;
      var defs = eventStore.defs,
          instances = eventStore.instances; // remove existing recurring instances

      instances = filterHash(instances, function (instance) {
        return !defs[instance.defId].recurringDef;
      });

      for (var defId in defs) {
        var def = defs[defId];

        if (def.recurringDef) {
          var duration = def.recurringDef.duration;

          if (!duration) {
            duration = def.allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration;
          }

          var starts = expandRecurringRanges(def, duration, framingRange, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes);

          for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {
            var start = starts_1[_i];
            var instance = createEventInstance(defId, {
              start: start,
              end: dateEnv.add(start, duration)
            });
            instances[instance.instanceId] = instance;
          }
        }
      }

      return {
        defs: defs,
        instances: instances
      };
    } // retrieves events that have the same groupId as the instance specified by `instanceId`
    // or they are the same as the instance.
    // why might instanceId not be in the store? an event from another calendar?


    function getRelevantEvents(eventStore, instanceId) {
      var instance = eventStore.instances[instanceId];

      if (instance) {
        var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group

        var newStore = filterEventStoreDefs(eventStore, function (lookDef) {
          return isEventDefsGrouped(def_1, lookDef);
        }); // add the original
        // TODO: wish we could use eventTupleToStore or something like it

        newStore.defs[def_1.defId] = def_1;
        newStore.instances[instance.instanceId] = instance;
        return newStore;
      }

      return createEmptyEventStore();
    }

    function isEventDefsGrouped(def0, def1) {
      return Boolean(def0.groupId && def0.groupId === def1.groupId);
    }

    function transformRawEvents(rawEvents, eventSource, calendar) {
      var calEachTransform = calendar.opt('eventDataTransform');
      var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;

      if (sourceEachTransform) {
        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
      }

      if (calEachTransform) {
        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
      }

      return rawEvents;
    }

    function transformEachRawEvent(rawEvents, func) {
      var refinedEvents;

      if (!func) {
        refinedEvents = rawEvents;
      } else {
        refinedEvents = [];

        for (var _i = 0, rawEvents_2 = rawEvents; _i < rawEvents_2.length; _i++) {
          var rawEvent = rawEvents_2[_i];
          var refinedEvent = func(rawEvent);

          if (refinedEvent) {
            refinedEvents.push(refinedEvent);
          } else if (refinedEvent == null) {
            refinedEvents.push(rawEvent);
          } // if a different falsy value, do nothing

        }
      }

      return refinedEvents;
    }

    function createEmptyEventStore() {
      return {
        defs: {},
        instances: {}
      };
    }

    function mergeEventStores(store0, store1) {
      return {
        defs: _assign({}, store0.defs, store1.defs),
        instances: _assign({}, store0.instances, store1.instances)
      };
    }

    function filterEventStoreDefs(eventStore, filterFunc) {
      var defs = filterHash(eventStore.defs, filterFunc);
      var instances = filterHash(eventStore.instances, function (instance) {
        return defs[instance.defId]; // still exists?
      });
      return {
        defs: defs,
        instances: instances
      };
    }

    function parseRange(input, dateEnv) {
      var start = null;
      var end = null;

      if (input.start) {
        start = dateEnv.createMarker(input.start);
      }

      if (input.end) {
        end = dateEnv.createMarker(input.end);
      }

      if (!start && !end) {
        return null;
      }

      if (start && end && end < start) {
        return null;
      }

      return {
        start: start,
        end: end
      };
    } // SIDE-EFFECT: will mutate ranges.
    // Will return a new array result.


    function invertRanges(ranges, constraintRange) {
      var invertedRanges = [];
      var start = constraintRange.start; // the end of the previous range. the start of the new range

      var i;
      var dateRange; // ranges need to be in order. required for our date-walking algorithm

      ranges.sort(compareRanges);

      for (i = 0; i < ranges.length; i++) {
        dateRange = ranges[i]; // add the span of time before the event (if there is any)

        if (dateRange.start > start) {
          // compare millisecond time (skip any ambig logic)
          invertedRanges.push({
            start: start,
            end: dateRange.start
          });
        }

        if (dateRange.end > start) {
          start = dateRange.end;
        }
      } // add the span of time after the last event (if there is any)


      if (start < constraintRange.end) {
        // compare millisecond time (skip any ambig logic)
        invertedRanges.push({
          start: start,
          end: constraintRange.end
        });
      }

      return invertedRanges;
    }

    function compareRanges(range0, range1) {
      return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first
    }

    function intersectRanges(range0, range1) {
      var start = range0.start;
      var end = range0.end;
      var newRange = null;

      if (range1.start !== null) {
        if (start === null) {
          start = range1.start;
        } else {
          start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
        }
      }

      if (range1.end != null) {
        if (end === null) {
          end = range1.end;
        } else {
          end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
        }
      }

      if (start === null || end === null || start < end) {
        newRange = {
          start: start,
          end: end
        };
      }

      return newRange;
    }

    function rangesEqual(range0, range1) {
      return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
    }

    function rangesIntersect(range0, range1) {
      return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
    }

    function rangeContainsRange(outerRange, innerRange) {
      return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
    }

    function rangeContainsMarker(range, date) {
      return (range.start === null || date >= range.start) && (range.end === null || date < range.end);
    } // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).


    function constrainMarkerToRange(date, range) {
      if (range.start != null && date < range.start) {
        return range.start;
      }

      if (range.end != null && date >= range.end) {
        return new Date(range.end.valueOf() - 1);
      }

      return date;
    }

    function removeExact(array, exactVal) {
      var removeCnt = 0;
      var i = 0;

      while (i < array.length) {
        if (array[i] === exactVal) {
          array.splice(i, 1);
          removeCnt++;
        } else {
          i++;
        }
      }

      return removeCnt;
    }

    function isArraysEqual(a0, a1) {
      var len = a0.length;
      var i;

      if (len !== a1.length) {
        // not array? or not same length?
        return false;
      }

      for (i = 0; i < len; i++) {
        if (a0[i] !== a1[i]) {
          return false;
        }
      }

      return true;
    }

    function memoize(workerFunc) {
      var args;
      var res;
      return function () {
        if (!args || !isArraysEqual(args, arguments)) {
          args = arguments;
          res = workerFunc.apply(this, arguments);
        }

        return res;
      };
    }
    /*
    always executes the workerFunc, but if the result is equal to the previous result,
    return the previous result instead.
    */


    function memoizeOutput(workerFunc, equalityFunc) {
      var cachedRes = null;
      return function () {
        var newRes = workerFunc.apply(this, arguments);

        if (cachedRes === null || !(cachedRes === newRes || equalityFunc(cachedRes, newRes))) {
          cachedRes = newRes;
        }

        return cachedRes;
      };
    }

    var EXTENDED_SETTINGS_AND_SEVERITIES = {
      week: 3,
      separator: 0,
      omitZeroMinute: 0,
      meridiem: 0,
      omitCommas: 0
    };
    var STANDARD_DATE_PROP_SEVERITIES = {
      timeZoneName: 7,
      era: 6,
      year: 5,
      month: 4,
      day: 2,
      weekday: 2,
      hour: 1,
      minute: 1,
      second: 1
    };
    var MERIDIEM_RE = /\s*([ap])\.?m\.?/i; // eats up leading spaces too

    var COMMA_RE = /,/g; // we need re for globalness

    var MULTI_SPACE_RE = /\s+/g;
    var LTR_RE = /\u200e/g; // control character

    var UTC_RE = /UTC|GMT/;

    var NativeFormatter =
    /** @class */
    function () {
      function NativeFormatter(formatSettings) {
        var standardDateProps = {};
        var extendedSettings = {};
        var severity = 0;

        for (var name_1 in formatSettings) {
          if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {
            extendedSettings[name_1] = formatSettings[name_1];
            severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);
          } else {
            standardDateProps[name_1] = formatSettings[name_1];

            if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {
              severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);
            }
          }
        }

        this.standardDateProps = standardDateProps;
        this.extendedSettings = extendedSettings;
        this.severity = severity;
        this.buildFormattingFunc = memoize(buildFormattingFunc);
      }

      NativeFormatter.prototype.format = function (date, context) {
        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
      };

      NativeFormatter.prototype.formatRange = function (start, end, context) {
        var _a = this,
            standardDateProps = _a.standardDateProps,
            extendedSettings = _a.extendedSettings;

        var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);

        if (!diffSeverity) {
          return this.format(start, context);
        }

        var biggestUnitForPartial = diffSeverity;

        if (biggestUnitForPartial > 1 && ( // the two dates are different in a way that's larger scale than time
        standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {
          biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time
        }

        var full0 = this.format(start, context);
        var full1 = this.format(end, context);

        if (full0 === full1) {
          return full0;
        }

        var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
        var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
        var partial0 = partialFormattingFunc(start);
        var partial1 = partialFormattingFunc(end);
        var insertion = findCommonInsertion(full0, partial0, full1, partial1);
        var separator = extendedSettings.separator || '';

        if (insertion) {
          return insertion.before + partial0 + separator + partial1 + insertion.after;
        }

        return full0 + separator + full1;
      };

      NativeFormatter.prototype.getLargestUnit = function () {
        switch (this.severity) {
          case 7:
          case 6:
          case 5:
            return 'year';

          case 4:
            return 'month';

          case 3:
            return 'week';

          default:
            return 'day';
        }
      };

      return NativeFormatter;
    }();

    function buildFormattingFunc(standardDateProps, extendedSettings, context) {
      var standardDatePropCnt = Object.keys(standardDateProps).length;

      if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {
        return function (date) {
          return formatTimeZoneOffset(date.timeZoneOffset);
        };
      }

      if (standardDatePropCnt === 0 && extendedSettings.week) {
        return function (date) {
          return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekLabel, context.locale, extendedSettings.week);
        };
      }

      return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
    }

    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
      standardDateProps = _assign({}, standardDateProps); // copy

      extendedSettings = _assign({}, extendedSettings); // copy

      sanitizeSettings(standardDateProps, extendedSettings);
      standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers

      var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
      var zeroFormat; // needed?

      if (extendedSettings.omitZeroMinute) {
        var zeroProps = _assign({}, standardDateProps);

        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings

        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
      }

      return function (date) {
        var marker = date.marker;
        var format;

        if (zeroFormat && !marker.getUTCMinutes()) {
          format = zeroFormat;
        } else {
          format = normalFormat;
        }

        var s = format.format(marker);
        return postProcess(s, date, standardDateProps, extendedSettings, context);
      };
    }

    function sanitizeSettings(standardDateProps, extendedSettings) {
      // deal with a browser inconsistency where formatting the timezone
      // requires that the hour/minute be present.
      if (standardDateProps.timeZoneName) {
        if (!standardDateProps.hour) {
          standardDateProps.hour = '2-digit';
        }

        if (!standardDateProps.minute) {
          standardDateProps.minute = '2-digit';
        }
      } // only support short timezone names


      if (standardDateProps.timeZoneName === 'long') {
        standardDateProps.timeZoneName = 'short';
      } // if requesting to display seconds, MUST display minutes


      if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
        delete extendedSettings.omitZeroMinute;
      }
    }

    function postProcess(s, date, standardDateProps, extendedSettings, context) {
      s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes

      if (standardDateProps.timeZoneName === 'short') {
        s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does "GMT"
        formatTimeZoneOffset(date.timeZoneOffset));
      }

      if (extendedSettings.omitCommas) {
        s = s.replace(COMMA_RE, '').trim();
      }

      if (extendedSettings.omitZeroMinute) {
        s = s.replace(':00', ''); // zeroFormat doesn't always achieve this
      } // ^ do anything that might create adjacent spaces before this point,
      // because MERIDIEM_RE likes to eat up loading spaces


      if (extendedSettings.meridiem === false) {
        s = s.replace(MERIDIEM_RE, '').trim();
      } else if (extendedSettings.meridiem === 'narrow') {
        // a/p
        s = s.replace(MERIDIEM_RE, function (m0, m1) {
          return m1.toLocaleLowerCase();
        });
      } else if (extendedSettings.meridiem === 'short') {
        // am/pm
        s = s.replace(MERIDIEM_RE, function (m0, m1) {
          return m1.toLocaleLowerCase() + 'm';
        });
      } else if (extendedSettings.meridiem === 'lowercase') {
        // other meridiem transformers already converted to lowercase
        s = s.replace(MERIDIEM_RE, function (m0) {
          return m0.toLocaleLowerCase();
        });
      }

      s = s.replace(MULTI_SPACE_RE, ' ');
      s = s.trim();
      return s;
    }

    function injectTzoStr(s, tzoStr) {
      var replaced = false;
      s = s.replace(UTC_RE, function () {
        replaced = true;
        return tzoStr;
      }); // IE11 doesn't include UTC/GMT in the original string, so append to end

      if (!replaced) {
        s += ' ' + tzoStr;
      }

      return s;
    }

    function formatWeekNumber(num, weekLabel, locale, display) {
      var parts = [];

      if (display === 'narrow') {
        parts.push(weekLabel);
      } else if (display === 'short') {
        parts.push(weekLabel, ' ');
      } // otherwise, considered 'numeric'


      parts.push(locale.simpleNumberFormat.format(num));

      if (locale.options.isRtl) {
        // TODO: use control characters instead?
        parts.reverse();
      }

      return parts.join('');
    } // Range Formatting Utils
    // 0 = exactly the same
    // 1 = different by time
    // and bigger


    function computeMarkerDiffSeverity(d0, d1, ca) {
      if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
        return 5;
      }

      if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
        return 4;
      }

      if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
        return 2;
      }

      if (timeAsMs(d0) !== timeAsMs(d1)) {
        return 1;
      }

      return 0;
    }

    function computePartialFormattingOptions(options, biggestUnit) {
      var partialOptions = {};

      for (var name_2 in options) {
        if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
        STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {
          partialOptions[name_2] = options[name_2];
        }
      }

      return partialOptions;
    }

    function findCommonInsertion(full0, partial0, full1, partial1) {
      var i0 = 0;

      while (i0 < full0.length) {
        var found0 = full0.indexOf(partial0, i0);

        if (found0 === -1) {
          break;
        }

        var before0 = full0.substr(0, found0);
        i0 = found0 + partial0.length;
        var after0 = full0.substr(i0);
        var i1 = 0;

        while (i1 < full1.length) {
          var found1 = full1.indexOf(partial1, i1);

          if (found1 === -1) {
            break;
          }

          var before1 = full1.substr(0, found1);
          i1 = found1 + partial1.length;
          var after1 = full1.substr(i1);

          if (before0 === before1 && after0 === after1) {
            return {
              before: before0,
              after: after0
            };
          }
        }
      }

      return null;
    }
    /*
    TODO: fix the terminology of "formatter" vs "formatting func"
    */

    /*
    At the time of instantiation, this object does not know which cmd-formatting system it will use.
    It receives this at the time of formatting, as a setting.
    */


    var CmdFormatter =
    /** @class */
    function () {
      function CmdFormatter(cmdStr, separator) {
        this.cmdStr = cmdStr;
        this.separator = separator;
      }

      CmdFormatter.prototype.format = function (date, context) {
        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, this.separator));
      };

      CmdFormatter.prototype.formatRange = function (start, end, context) {
        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, this.separator));
      };

      return CmdFormatter;
    }();

    var FuncFormatter =
    /** @class */
    function () {
      function FuncFormatter(func) {
        this.func = func;
      }

      FuncFormatter.prototype.format = function (date, context) {
        return this.func(createVerboseFormattingArg(date, null, context));
      };

      FuncFormatter.prototype.formatRange = function (start, end, context) {
        return this.func(createVerboseFormattingArg(start, end, context));
      };

      return FuncFormatter;
    }(); // Formatter Object Creation


    function createFormatter(input, defaultSeparator) {
      if (typeof input === 'object' && input) {
        // non-null object
        if (typeof defaultSeparator === 'string') {
          input = _assign({
            separator: defaultSeparator
          }, input);
        }

        return new NativeFormatter(input);
      } else if (typeof input === 'string') {
        return new CmdFormatter(input, defaultSeparator);
      } else if (typeof input === 'function') {
        return new FuncFormatter(input);
      }
    } // String Utils
    // timeZoneOffset is in minutes


    function buildIsoString(marker, timeZoneOffset, stripZeroTime) {
      if (stripZeroTime === void 0) {
        stripZeroTime = false;
      }

      var s = marker.toISOString();
      s = s.replace('.000', '');

      if (stripZeroTime) {
        s = s.replace('T00:00:00Z', '');
      }

      if (s.length > 10) {
        // time part wasn't stripped, can add timezone info
        if (timeZoneOffset == null) {
          s = s.replace('Z', '');
        } else if (timeZoneOffset !== 0) {
          s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));
        } // otherwise, its UTC-0 and we want to keep the Z

      }

      return s;
    }

    function formatIsoTimeString(marker) {
      return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);
    }

    function formatTimeZoneOffset(minutes, doIso) {
      if (doIso === void 0) {
        doIso = false;
      }

      var sign = minutes < 0 ? '-' : '+';
      var abs = Math.abs(minutes);
      var hours = Math.floor(abs / 60);
      var mins = Math.round(abs % 60);

      if (doIso) {
        return sign + padStart(hours, 2) + ':' + padStart(mins, 2);
      } else {
        return 'GMT' + sign + hours + (mins ? ':' + padStart(mins, 2) : '');
      }
    } // Arg Utils


    function createVerboseFormattingArg(start, end, context, separator) {
      var startInfo = expandZonedMarker(start, context.calendarSystem);
      var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
      return {
        date: startInfo,
        start: startInfo,
        end: endInfo,
        timeZone: context.timeZone,
        localeCodes: context.locale.codes,
        separator: separator
      };
    }

    function expandZonedMarker(dateInfo, calendarSystem) {
      var a = calendarSystem.markerToArray(dateInfo.marker);
      return {
        marker: dateInfo.marker,
        timeZoneOffset: dateInfo.timeZoneOffset,
        array: a,
        year: a[0],
        month: a[1],
        day: a[2],
        hour: a[3],
        minute: a[4],
        second: a[5],
        millisecond: a[6]
      };
    }

    var EventSourceApi =
    /** @class */
    function () {
      function EventSourceApi(calendar, internalEventSource) {
        this.calendar = calendar;
        this.internalEventSource = internalEventSource;
      }

      EventSourceApi.prototype.remove = function () {
        this.calendar.dispatch({
          type: 'REMOVE_EVENT_SOURCE',
          sourceId: this.internalEventSource.sourceId
        });
      };

      EventSourceApi.prototype.refetch = function () {
        this.calendar.dispatch({
          type: 'FETCH_EVENT_SOURCES',
          sourceIds: [this.internalEventSource.sourceId]
        });
      };

      Object.defineProperty(EventSourceApi.prototype, "id", {
        get: function get() {
          return this.internalEventSource.publicId;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventSourceApi.prototype, "url", {
        // only relevant to json-feed event sources
        get: function get() {
          return this.internalEventSource.meta.url;
        },
        enumerable: true,
        configurable: true
      });
      return EventSourceApi;
    }();

    var EventApi =
    /** @class */
    function () {
      function EventApi(calendar, def, instance) {
        this._calendar = calendar;
        this._def = def;
        this._instance = instance || null;
      }
      /*
      TODO: make event struct more responsible for this
      */


      EventApi.prototype.setProp = function (name, val) {
        var _a, _b;

        if (name in DATE_PROPS) ;else if (name in NON_DATE_PROPS) {
          if (typeof NON_DATE_PROPS[name] === 'function') {
            val = NON_DATE_PROPS[name](val);
          }

          this.mutate({
            standardProps: (_a = {}, _a[name] = val, _a)
          });
        } else if (name in UNSCOPED_EVENT_UI_PROPS) {
          var ui = void 0;

          if (typeof UNSCOPED_EVENT_UI_PROPS[name] === 'function') {
            val = UNSCOPED_EVENT_UI_PROPS[name](val);
          }

          if (name === 'color') {
            ui = {
              backgroundColor: val,
              borderColor: val
            };
          } else if (name === 'editable') {
            ui = {
              startEditable: val,
              durationEditable: val
            };
          } else {
            ui = (_b = {}, _b[name] = val, _b);
          }

          this.mutate({
            standardProps: {
              ui: ui
            }
          });
        }
      };

      EventApi.prototype.setExtendedProp = function (name, val) {
        var _a;

        this.mutate({
          extendedProps: (_a = {}, _a[name] = val, _a)
        });
      };

      EventApi.prototype.setStart = function (startInput, options) {
        if (options === void 0) {
          options = {};
        }

        var dateEnv = this._calendar.dateEnv;
        var start = dateEnv.createMarker(startInput);

        if (start && this._instance) {
          // TODO: warning if parsed bad
          var instanceRange = this._instance.range;
          var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?

          if (options.maintainDuration) {
            this.mutate({
              datesDelta: startDelta
            });
          } else {
            this.mutate({
              startDelta: startDelta
            });
          }
        }
      };

      EventApi.prototype.setEnd = function (endInput, options) {
        if (options === void 0) {
          options = {};
        }

        var dateEnv = this._calendar.dateEnv;
        var end;

        if (endInput != null) {
          end = dateEnv.createMarker(endInput);

          if (!end) {
            return; // TODO: warning if parsed bad
          }
        }

        if (this._instance) {
          if (end) {
            var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
            this.mutate({
              endDelta: endDelta
            });
          } else {
            this.mutate({
              standardProps: {
                hasEnd: false
              }
            });
          }
        }
      };

      EventApi.prototype.setDates = function (startInput, endInput, options) {
        if (options === void 0) {
          options = {};
        }

        var dateEnv = this._calendar.dateEnv;
        var standardProps = {
          allDay: options.allDay
        };
        var start = dateEnv.createMarker(startInput);
        var end;

        if (!start) {
          return; // TODO: warning if parsed bad
        }

        if (endInput != null) {
          end = dateEnv.createMarker(endInput);

          if (!end) {
            // TODO: warning if parsed bad
            return;
          }
        }

        if (this._instance) {
          var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,
          // compute diff off of the all-day values the way event-mutation does.

          if (options.allDay === true) {
            instanceRange = computeAlignedDayRange(instanceRange);
          }

          var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);

          if (end) {
            var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);

            if (durationsEqual(startDelta, endDelta)) {
              this.mutate({
                datesDelta: startDelta,
                standardProps: standardProps
              });
            } else {
              this.mutate({
                startDelta: startDelta,
                endDelta: endDelta,
                standardProps: standardProps
              });
            }
          } else {
            // means "clear the end"
            standardProps.hasEnd = false;
            this.mutate({
              datesDelta: startDelta,
              standardProps: standardProps
            });
          }
        }
      };

      EventApi.prototype.moveStart = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // TODO: warning if parsed bad
          this.mutate({
            startDelta: delta
          });
        }
      };

      EventApi.prototype.moveEnd = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // TODO: warning if parsed bad
          this.mutate({
            endDelta: delta
          });
        }
      };

      EventApi.prototype.moveDates = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // TODO: warning if parsed bad
          this.mutate({
            datesDelta: delta
          });
        }
      };

      EventApi.prototype.setAllDay = function (allDay, options) {
        if (options === void 0) {
          options = {};
        }

        var standardProps = {
          allDay: allDay
        };
        var maintainDuration = options.maintainDuration;

        if (maintainDuration == null) {
          maintainDuration = this._calendar.opt('allDayMaintainDuration');
        }

        if (this._def.allDay !== allDay) {
          standardProps.hasEnd = maintainDuration;
        }

        this.mutate({
          standardProps: standardProps
        });
      };

      EventApi.prototype.formatRange = function (formatInput) {
        var dateEnv = this._calendar.dateEnv;
        var instance = this._instance;
        var formatter = createFormatter(formatInput, this._calendar.opt('defaultRangeSeparator'));

        if (this._def.hasEnd) {
          return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
            forcedStartTzo: instance.forcedStartTzo,
            forcedEndTzo: instance.forcedEndTzo
          });
        } else {
          return dateEnv.format(instance.range.start, formatter, {
            forcedTzo: instance.forcedStartTzo
          });
        }
      };

      EventApi.prototype.mutate = function (mutation) {
        var def = this._def;
        var instance = this._instance;

        if (instance) {
          this._calendar.dispatch({
            type: 'MUTATE_EVENTS',
            instanceId: instance.instanceId,
            mutation: mutation,
            fromApi: true
          });

          var eventStore = this._calendar.state.eventStore;
          this._def = eventStore.defs[def.defId];
          this._instance = eventStore.instances[instance.instanceId];
        }
      };

      EventApi.prototype.remove = function () {
        this._calendar.dispatch({
          type: 'REMOVE_EVENT_DEF',
          defId: this._def.defId
        });
      };

      Object.defineProperty(EventApi.prototype, "source", {
        get: function get() {
          var sourceId = this._def.sourceId;

          if (sourceId) {
            return new EventSourceApi(this._calendar, this._calendar.state.eventSources[sourceId]);
          }

          return null;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "start", {
        get: function get() {
          return this._instance ? this._calendar.dateEnv.toDate(this._instance.range.start) : null;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "end", {
        get: function get() {
          return this._instance && this._def.hasEnd ? this._calendar.dateEnv.toDate(this._instance.range.end) : null;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "id", {
        // computable props that all access the def
        // TODO: find a TypeScript-compatible way to do this at scale
        get: function get() {
          return this._def.publicId;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "groupId", {
        get: function get() {
          return this._def.groupId;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "allDay", {
        get: function get() {
          return this._def.allDay;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "title", {
        get: function get() {
          return this._def.title;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "url", {
        get: function get() {
          return this._def.url;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "rendering", {
        get: function get() {
          return this._def.rendering;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "startEditable", {
        get: function get() {
          return this._def.ui.startEditable;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "durationEditable", {
        get: function get() {
          return this._def.ui.durationEditable;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "constraint", {
        get: function get() {
          return this._def.ui.constraints[0] || null;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "overlap", {
        get: function get() {
          return this._def.ui.overlap;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "allow", {
        get: function get() {
          return this._def.ui.allows[0] || null;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "backgroundColor", {
        get: function get() {
          return this._def.ui.backgroundColor;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "borderColor", {
        get: function get() {
          return this._def.ui.borderColor;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "textColor", {
        get: function get() {
          return this._def.ui.textColor;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "classNames", {
        // NOTE: user can't modify these because Object.freeze was called in event-def parsing
        get: function get() {
          return this._def.ui.classNames;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(EventApi.prototype, "extendedProps", {
        get: function get() {
          return this._def.extendedProps;
        },
        enumerable: true,
        configurable: true
      });
      return EventApi;
    }();
    /*
    Specifying nextDayThreshold signals that all-day ranges should be sliced.
    */


    function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
      var inverseBgByGroupId = {};
      var inverseBgByDefId = {};
      var defByGroupId = {};
      var bgRanges = [];
      var fgRanges = [];
      var eventUis = compileEventUis(eventStore.defs, eventUiBases);

      for (var defId in eventStore.defs) {
        var def = eventStore.defs[defId];

        if (def.rendering === 'inverse-background') {
          if (def.groupId) {
            inverseBgByGroupId[def.groupId] = [];

            if (!defByGroupId[def.groupId]) {
              defByGroupId[def.groupId] = def;
            }
          } else {
            inverseBgByDefId[defId] = [];
          }
        }
      }

      for (var instanceId in eventStore.instances) {
        var instance = eventStore.instances[instanceId];
        var def = eventStore.defs[instance.defId];
        var ui = eventUis[def.defId];
        var origRange = instance.range;
        var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
        var slicedRange = intersectRanges(normalRange, framingRange);

        if (slicedRange) {
          if (def.rendering === 'inverse-background') {
            if (def.groupId) {
              inverseBgByGroupId[def.groupId].push(slicedRange);
            } else {
              inverseBgByDefId[instance.defId].push(slicedRange);
            }
          } else {
            (def.rendering === 'background' ? bgRanges : fgRanges).push({
              def: def,
              ui: ui,
              instance: instance,
              range: slicedRange,
              isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
              isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
            });
          }
        }
      }

      for (var groupId in inverseBgByGroupId) {
        // BY GROUP
        var ranges = inverseBgByGroupId[groupId];
        var invertedRanges = invertRanges(ranges, framingRange);

        for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {
          var invertedRange = invertedRanges_1[_i];
          var def = defByGroupId[groupId];
          var ui = eventUis[def.defId];
          bgRanges.push({
            def: def,
            ui: ui,
            instance: null,
            range: invertedRange,
            isStart: false,
            isEnd: false
          });
        }
      }

      for (var defId in inverseBgByDefId) {
        var ranges = inverseBgByDefId[defId];
        var invertedRanges = invertRanges(ranges, framingRange);

        for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {
          var invertedRange = invertedRanges_2[_a];
          bgRanges.push({
            def: eventStore.defs[defId],
            ui: eventUis[defId],
            instance: null,
            range: invertedRange,
            isStart: false,
            isEnd: false
          });
        }
      }

      return {
        bg: bgRanges,
        fg: fgRanges
      };
    }

    function hasBgRendering(def) {
      return def.rendering === 'background' || def.rendering === 'inverse-background';
    }

    function filterSegsViaEls(context, segs, isMirror) {
      var calendar = context.calendar,
          view = context.view;

      if (calendar.hasPublicHandlers('eventRender')) {
        segs = segs.filter(function (seg) {
          var custom = calendar.publiclyTrigger('eventRender', [{
            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
            isMirror: isMirror,
            isStart: seg.isStart,
            isEnd: seg.isEnd,
            // TODO: include seg.range once all components consistently generate it
            el: seg.el,
            view: view
          }]);

          if (custom === false) {
            // means don't render at all
            return false;
          } else if (custom && custom !== true) {
            seg.el = custom;
          }

          return true;
        });
      }

      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
        var seg = segs_1[_i];
        setElSeg(seg.el, seg);
      }

      return segs;
    }

    function setElSeg(el, seg) {
      el.fcSeg = seg;
    }

    function getElSeg(el) {
      return el.fcSeg || null;
    } // event ui computation


    function compileEventUis(eventDefs, eventUiBases) {
      return mapHash(eventDefs, function (eventDef) {
        return compileEventUi(eventDef, eventUiBases);
      });
    }

    function compileEventUi(eventDef, eventUiBases) {
      var uis = [];

      if (eventUiBases['']) {
        uis.push(eventUiBases['']);
      }

      if (eventUiBases[eventDef.defId]) {
        uis.push(eventUiBases[eventDef.defId]);
      }

      uis.push(eventDef.ui);
      return combineEventUis(uis);
    } // triggers


    function triggerRenderedSegs(context, segs, isMirrors) {
      var calendar = context.calendar,
          view = context.view;

      if (calendar.hasPublicHandlers('eventPositioned')) {
        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
          var seg = segs_2[_i];
          calendar.publiclyTriggerAfterSizing('eventPositioned', [{
            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
            isMirror: isMirrors,
            isStart: seg.isStart,
            isEnd: seg.isEnd,
            el: seg.el,
            view: view
          }]);
        }
      }

      if (!calendar.state.eventSourceLoadingLevel) {
        // avoid initial empty state while pending
        calendar.afterSizingTriggers._eventsPositioned = [null]; // fire once
      }
    }

    function triggerWillRemoveSegs(context, segs, isMirrors) {
      var calendar = context.calendar,
          view = context.view;

      for (var _i = 0, segs_3 = segs; _i < segs_3.length; _i++) {
        var seg = segs_3[_i];
        calendar.trigger('eventElRemove', seg.el);
      }

      if (calendar.hasPublicHandlers('eventDestroy')) {
        for (var _a = 0, segs_4 = segs; _a < segs_4.length; _a++) {
          var seg = segs_4[_a];
          calendar.publiclyTrigger('eventDestroy', [{
            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
            isMirror: isMirrors,
            el: seg.el,
            view: view
          }]);
        }
      }
    } // is-interactable


    function computeEventDraggable(context, eventDef, eventUi) {
      var calendar = context.calendar,
          view = context.view;
      var transformers = calendar.pluginSystem.hooks.isDraggableTransformers;
      var val = eventUi.startEditable;

      for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
        var transformer = transformers_1[_i];
        val = transformer(val, eventDef, eventUi, view);
      }

      return val;
    }

    function computeEventStartResizable(context, eventDef, eventUi) {
      return eventUi.durationEditable && context.options.eventResizableFromStart;
    }

    function computeEventEndResizable(context, eventDef, eventUi) {
      return eventUi.durationEditable;
    } // applies the mutation to ALL defs/instances within the event store


    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, calendar) {
      var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
      var dest = createEmptyEventStore();

      for (var defId in eventStore.defs) {
        var def = eventStore.defs[defId];
        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, calendar.pluginSystem.hooks.eventDefMutationAppliers, calendar);
      }

      for (var instanceId in eventStore.instances) {
        var instance = eventStore.instances[instanceId];
        var def = dest.defs[instance.defId]; // important to grab the newly modified def

        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, calendar);
      }

      return dest;
    }

    function applyMutationToEventDef(eventDef, eventConfig, mutation, appliers, calendar) {
      var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.
      // if duration will change, there's no way the default duration will persist,
      // and thus, we need to mark the event as having a real end

      if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
        standardProps.hasEnd = true; // TODO: is this mutation okay?
      }

      var copy = _assign({}, eventDef, standardProps, {
        ui: _assign({}, eventDef.ui, standardProps.ui)
      });

      if (mutation.extendedProps) {
        copy.extendedProps = _assign({}, copy.extendedProps, mutation.extendedProps);
      }

      for (var _i = 0, appliers_1 = appliers; _i < appliers_1.length; _i++) {
        var applier = appliers_1[_i];
        applier(copy, mutation, calendar);
      }

      if (!copy.hasEnd && calendar.opt('forceEventDuration')) {
        copy.hasEnd = true;
      }

      return copy;
    }

    function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef
    eventConfig, mutation, calendar) {
      var dateEnv = calendar.dateEnv;
      var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
      var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;

      var copy = _assign({}, eventInstance);

      if (forceAllDay) {
        copy.range = computeAlignedDayRange(copy.range);
      }

      if (mutation.datesDelta && eventConfig.startEditable) {
        copy.range = {
          start: dateEnv.add(copy.range.start, mutation.datesDelta),
          end: dateEnv.add(copy.range.end, mutation.datesDelta)
        };
      }

      if (mutation.startDelta && eventConfig.durationEditable) {
        copy.range = {
          start: dateEnv.add(copy.range.start, mutation.startDelta),
          end: copy.range.end
        };
      }

      if (mutation.endDelta && eventConfig.durationEditable) {
        copy.range = {
          start: copy.range.start,
          end: dateEnv.add(copy.range.end, mutation.endDelta)
        };
      }

      if (clearEnd) {
        copy.range = {
          start: copy.range.start,
          end: calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start)
        };
      } // in case event was all-day but the supplied deltas were not
      // better util for this?


      if (eventDef.allDay) {
        copy.range = {
          start: startOfDay(copy.range.start),
          end: startOfDay(copy.range.end)
        };
      } // handle invalid durations


      if (copy.range.end < copy.range.start) {
        copy.range.end = calendar.getDefaultEventEnd(eventDef.allDay, copy.range.start);
      }

      return copy;
    }

    function reduceEventStore(eventStore, action, eventSources, dateProfile, calendar) {
      switch (action.type) {
        case 'RECEIVE_EVENTS':
          // raw
          return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, calendar);

        case 'ADD_EVENTS':
          // already parsed, but not expanded
          return addEvent(eventStore, action.eventStore, // new ones
          dateProfile ? dateProfile.activeRange : null, calendar);

        case 'MERGE_EVENTS':
          // already parsed and expanded
          return mergeEventStores(eventStore, action.eventStore);

        case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

        case 'NEXT':
        case 'SET_DATE':
        case 'SET_VIEW_TYPE':
          if (dateProfile) {
            return expandRecurring(eventStore, dateProfile.activeRange, calendar);
          } else {
            return eventStore;
          }

        case 'CHANGE_TIMEZONE':
          return rezoneDates(eventStore, action.oldDateEnv, calendar.dateEnv);

        case 'MUTATE_EVENTS':
          return applyMutationToRelated(eventStore, action.instanceId, action.mutation, action.fromApi, calendar);

        case 'REMOVE_EVENT_INSTANCES':
          return excludeInstances(eventStore, action.instances);

        case 'REMOVE_EVENT_DEF':
          return filterEventStoreDefs(eventStore, function (eventDef) {
            return eventDef.defId !== action.defId;
          });

        case 'REMOVE_EVENT_SOURCE':
          return excludeEventsBySourceId(eventStore, action.sourceId);

        case 'REMOVE_ALL_EVENT_SOURCES':
          return filterEventStoreDefs(eventStore, function (eventDef) {
            return !eventDef.sourceId; // only keep events with no source id
          });

        case 'REMOVE_ALL_EVENTS':
          return createEmptyEventStore();

        case 'RESET_EVENTS':
          return {
            defs: eventStore.defs,
            instances: eventStore.instances
          };

        default:
          return eventStore;
      }
    }

    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, calendar) {
      if (eventSource && // not already removed
      fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources
      ) {
        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, calendar), eventSource.sourceId, calendar);

        if (fetchRange) {
          subset = expandRecurring(subset, fetchRange, calendar);
        }

        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
      }

      return eventStore;
    }

    function addEvent(eventStore, subset, expandRange, calendar) {
      if (expandRange) {
        subset = expandRecurring(subset, expandRange, calendar);
      }

      return mergeEventStores(eventStore, subset);
    }

    function rezoneDates(eventStore, oldDateEnv, newDateEnv) {
      var defs = eventStore.defs;
      var instances = mapHash(eventStore.instances, function (instance) {
        var def = defs[instance.defId];

        if (def.allDay || def.recurringDef) {
          return instance; // isn't dependent on timezone
        } else {
          return _assign({}, instance, {
            range: {
              start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
              end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
            },
            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,
            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo
          });
        }
      });
      return {
        defs: defs,
        instances: instances
      };
    }

    function applyMutationToRelated(eventStore, instanceId, mutation, fromApi, calendar) {
      var relevant = getRelevantEvents(eventStore, instanceId);
      var eventConfigBase = fromApi ? {
        '': {
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: '',
          borderColor: '',
          textColor: '',
          classNames: []
        }
      } : calendar.eventUiBases;
      relevant = applyMutationToEventStore(relevant, eventConfigBase, mutation, calendar);
      return mergeEventStores(eventStore, relevant);
    }

    function excludeEventsBySourceId(eventStore, sourceId) {
      return filterEventStoreDefs(eventStore, function (eventDef) {
        return eventDef.sourceId !== sourceId;
      });
    } // QUESTION: why not just return instances? do a general object-property-exclusion util


    function excludeInstances(eventStore, removals) {
      return {
        defs: eventStore.defs,
        instances: filterHash(eventStore.instances, function (instance) {
          return !removals[instance.instanceId];
        })
      };
    } // high-level segmenting-aware tester functions
    // ------------------------------------------------------------------------------------------------------------------------


    function isInteractionValid(interaction, calendar) {
      return isNewPropsValid({
        eventDrag: interaction
      }, calendar); // HACK: the eventDrag props is used for ALL interactions
    }

    function isDateSelectionValid(dateSelection, calendar) {
      return isNewPropsValid({
        dateSelection: dateSelection
      }, calendar);
    }

    function isNewPropsValid(newProps, calendar) {
      var view = calendar.view;

      var props = _assign({
        businessHours: view ? view.props.businessHours : createEmptyEventStore(),
        dateSelection: '',
        eventStore: calendar.state.eventStore,
        eventUiBases: calendar.eventUiBases,
        eventSelection: '',
        eventDrag: null,
        eventResize: null
      }, newProps);

      return (calendar.pluginSystem.hooks.isPropsValid || isPropsValid)(props, calendar);
    }

    function isPropsValid(state, calendar, dateSpanMeta, filterConfig) {
      if (dateSpanMeta === void 0) {
        dateSpanMeta = {};
      }

      if (state.eventDrag && !isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {
        return false;
      }

      if (state.dateSelection && !isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig)) {
        return false;
      }

      return true;
    } // Moving Event Validation
    // ------------------------------------------------------------------------------------------------------------------------


    function isInteractionPropsValid(state, calendar, dateSpanMeta, filterConfig) {
      var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions

      var subjectEventStore = interaction.mutatedEvents;
      var subjectDefs = subjectEventStore.defs;
      var subjectInstances = subjectEventStore.instances;
      var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {
        '': calendar.selectionConfig
      } // if not a real event, validate as a selection
      );

      if (filterConfig) {
        subjectConfigs = mapHash(subjectConfigs, filterConfig);
      }

      var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances); // exclude the subject events. TODO: exclude defs too?

      var otherDefs = otherEventStore.defs;
      var otherInstances = otherEventStore.instances;
      var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);

      for (var subjectInstanceId in subjectInstances) {
        var subjectInstance = subjectInstances[subjectInstanceId];
        var subjectRange = subjectInstance.range;
        var subjectConfig = subjectConfigs[subjectInstance.defId];
        var subjectDef = subjectDefs[subjectInstance.defId]; // constraint

        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, calendar)) {
          return false;
        } // overlap


        var overlapFunc = calendar.opt('eventOverlap');

        if (typeof overlapFunc !== 'function') {
          overlapFunc = null;
        }

        for (var otherInstanceId in otherInstances) {
          var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate

          if (rangesIntersect(subjectRange, otherInstance.range)) {
            var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a "real" event

            if (otherOverlap === false && interaction.isEvent) {
              return false;
            }

            if (subjectConfig.overlap === false) {
              return false;
            }

            if (overlapFunc && !overlapFunc(new EventApi(calendar, otherDefs[otherInstance.defId], otherInstance), // still event
            new EventApi(calendar, subjectDef, subjectInstance) // moving event
            )) {
              return false;
            }
          }
        } // allow (a function)


        var calendarEventStore = calendar.state.eventStore; // need global-to-calendar, not local to component (splittable)state

        for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {
          var subjectAllow = _a[_i];

          var subjectDateSpan = _assign({}, dateSpanMeta, {
            range: subjectInstance.range,
            allDay: subjectDef.allDay
          });

          var origDef = calendarEventStore.defs[subjectDef.defId];
          var origInstance = calendarEventStore.instances[subjectInstanceId];
          var eventApi = void 0;

          if (origDef) {
            // was previously in the calendar
            eventApi = new EventApi(calendar, origDef, origInstance);
          } else {
            // was an external event
            eventApi = new EventApi(calendar, subjectDef); // no instance, because had no dates
          }

          if (!subjectAllow(calendar.buildDateSpanApi(subjectDateSpan), eventApi)) {
            return false;
          }
        }
      }

      return true;
    } // Date Selection Validation
    // ------------------------------------------------------------------------------------------------------------------------


    function isDateSelectionPropsValid(state, calendar, dateSpanMeta, filterConfig) {
      var relevantEventStore = state.eventStore;
      var relevantDefs = relevantEventStore.defs;
      var relevantInstances = relevantEventStore.instances;
      var selection = state.dateSelection;
      var selectionRange = selection.range;
      var selectionConfig = calendar.selectionConfig;

      if (filterConfig) {
        selectionConfig = filterConfig(selectionConfig);
      } // constraint


      if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, calendar)) {
        return false;
      } // overlap


      var overlapFunc = calendar.opt('selectOverlap');

      if (typeof overlapFunc !== 'function') {
        overlapFunc = null;
      }

      for (var relevantInstanceId in relevantInstances) {
        var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate

        if (rangesIntersect(selectionRange, relevantInstance.range)) {
          if (selectionConfig.overlap === false) {
            return false;
          }

          if (overlapFunc && !overlapFunc(new EventApi(calendar, relevantDefs[relevantInstance.defId], relevantInstance))) {
            return false;
          }
        }
      } // allow (a function)


      for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {
        var selectionAllow = _a[_i];

        var fullDateSpan = _assign({}, dateSpanMeta, selection);

        if (!selectionAllow(calendar.buildDateSpanApi(fullDateSpan), null)) {
          return false;
        }
      }

      return true;
    } // Constraint Utils
    // ------------------------------------------------------------------------------------------------------------------------


    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, calendar) {
      for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {
        var constraint = constraints_1[_i];

        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, calendar), subjectRange)) {
          return false;
        }
      }

      return true;
    }

    function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours
    otherEventStore, // for if constraint is an even group ID
    businessHoursUnexpanded, // for if constraint is 'businessHours'
    calendar // for expanding businesshours
    ) {
      if (constraint === 'businessHours') {
        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, calendar));
      } else if (typeof constraint === 'string') {
        // an group ID
        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {
          return eventDef.groupId === constraint;
        }));
      } else if (typeof constraint === 'object' && constraint) {
        // non-null object
        return eventStoreToRanges(expandRecurring(constraint, subjectRange, calendar));
      }

      return []; // if it's false
    } // TODO: move to event-store file?


    function eventStoreToRanges(eventStore) {
      var instances = eventStore.instances;
      var ranges = [];

      for (var instanceId in instances) {
        ranges.push(instances[instanceId].range);
      }

      return ranges;
    } // TODO: move to geom file?


    function anyRangesContainRange(outerRanges, innerRange) {
      for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {
        var outerRange = outerRanges_1[_i];

        if (rangeContainsRange(outerRange, innerRange)) {
          return true;
        }
      }

      return false;
    } // Parsing
    // ------------------------------------------------------------------------------------------------------------------------


    function normalizeConstraint(input, calendar) {
      if (Array.isArray(input)) {
        return parseEvents(input, '', calendar, true); // allowOpenRange=true
      } else if (typeof input === 'object' && input) {
        // non-null object
        return parseEvents([input], '', calendar, true); // allowOpenRange=true
      } else if (input != null) {
        return String(input);
      } else {
        return null;
      }
    }

    function htmlEscape(s) {
      return (s + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#039;').replace(/"/g, '&quot;').replace(/\n/g, '<br />');
    } // Given a hash of CSS properties, returns a string of CSS.
    // Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.


    function cssToStr(cssProps) {
      var statements = [];

      for (var name_1 in cssProps) {
        var val = cssProps[name_1];

        if (val != null && val !== '') {
          statements.push(name_1 + ':' + val);
        }
      }

      return statements.join(';');
    } // Given an object hash of HTML attribute names to values,
    // generates a string that can be injected between < > in HTML


    function attrsToStr(attrs) {
      var parts = [];

      for (var name_2 in attrs) {
        var val = attrs[name_2];

        if (val != null) {
          parts.push(name_2 + '="' + htmlEscape(val) + '"');
        }
      }

      return parts.join(' ');
    }

    function parseClassName(raw) {
      if (Array.isArray(raw)) {
        return raw;
      } else if (typeof raw === 'string') {
        return raw.split(/\s+/);
      } else {
        return [];
      }
    }

    var UNSCOPED_EVENT_UI_PROPS = {
      editable: Boolean,
      startEditable: Boolean,
      durationEditable: Boolean,
      constraint: null,
      overlap: null,
      allow: null,
      className: parseClassName,
      classNames: parseClassName,
      color: String,
      backgroundColor: String,
      borderColor: String,
      textColor: String
    };

    function processUnscopedUiProps(rawProps, calendar, leftovers) {
      var props = refineProps(rawProps, UNSCOPED_EVENT_UI_PROPS, {}, leftovers);
      var constraint = normalizeConstraint(props.constraint, calendar);
      return {
        startEditable: props.startEditable != null ? props.startEditable : props.editable,
        durationEditable: props.durationEditable != null ? props.durationEditable : props.editable,
        constraints: constraint != null ? [constraint] : [],
        overlap: props.overlap,
        allows: props.allow != null ? [props.allow] : [],
        backgroundColor: props.backgroundColor || props.color,
        borderColor: props.borderColor || props.color,
        textColor: props.textColor,
        classNames: props.classNames.concat(props.className)
      };
    }

    function processScopedUiProps(prefix, rawScoped, calendar, leftovers) {
      var rawUnscoped = {};
      var wasFound = {};

      for (var key in UNSCOPED_EVENT_UI_PROPS) {
        var scopedKey = prefix + capitaliseFirstLetter(key);
        rawUnscoped[key] = rawScoped[scopedKey];
        wasFound[scopedKey] = true;
      }

      if (prefix === 'event') {
        rawUnscoped.editable = rawScoped.editable; // special case. there is no 'eventEditable', just 'editable'
      }

      if (leftovers) {
        for (var key in rawScoped) {
          if (!wasFound[key]) {
            leftovers[key] = rawScoped[key];
          }
        }
      }

      return processUnscopedUiProps(rawUnscoped, calendar);
    }

    var EMPTY_EVENT_UI = {
      startEditable: null,
      durationEditable: null,
      constraints: [],
      overlap: null,
      allows: [],
      backgroundColor: '',
      borderColor: '',
      textColor: '',
      classNames: []
    }; // prevent against problems with <2 args!

    function combineEventUis(uis) {
      return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
    }

    function combineTwoEventUis(item0, item1) {
      return {
        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
        constraints: item0.constraints.concat(item1.constraints),
        overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,
        allows: item0.allows.concat(item1.allows),
        backgroundColor: item1.backgroundColor || item0.backgroundColor,
        borderColor: item1.borderColor || item0.borderColor,
        textColor: item1.textColor || item0.textColor,
        classNames: item0.classNames.concat(item1.classNames)
      };
    }

    var NON_DATE_PROPS = {
      id: String,
      groupId: String,
      title: String,
      url: String,
      rendering: String,
      extendedProps: null
    };
    var DATE_PROPS = {
      start: null,
      date: null,
      end: null,
      allDay: null
    };
    var uid = 0;

    function parseEvent(raw, sourceId, calendar, allowOpenRange) {
      var allDayDefault = computeIsAllDayDefault(sourceId, calendar);
      var leftovers0 = {};
      var recurringRes = parseRecurring(raw, // raw, but with single-event stuff stripped out
      allDayDefault, calendar.dateEnv, calendar.pluginSystem.hooks.recurringTypes, leftovers0 // will populate with non-recurring props
      );

      if (recurringRes) {
        var def = parseEventDef(leftovers0, sourceId, recurringRes.allDay, Boolean(recurringRes.duration), calendar);
        def.recurringDef = {
          typeId: recurringRes.typeId,
          typeData: recurringRes.typeData,
          duration: recurringRes.duration
        };
        return {
          def: def,
          instance: null
        };
      } else {
        var leftovers1 = {};
        var singleRes = parseSingle(raw, allDayDefault, calendar, leftovers1, allowOpenRange);

        if (singleRes) {
          var def = parseEventDef(leftovers1, sourceId, singleRes.allDay, singleRes.hasEnd, calendar);
          var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
          return {
            def: def,
            instance: instance
          };
        }
      }

      return null;
    }
    /*
    Will NOT populate extendedProps with the leftover properties.
    Will NOT populate date-related props.
    The EventNonDateInput has been normalized (id => publicId, etc).
    */


    function parseEventDef(raw, sourceId, allDay, hasEnd, calendar) {
      var leftovers = {};
      var def = pluckNonDateProps(raw, calendar, leftovers);
      def.defId = String(uid++);
      def.sourceId = sourceId;
      def.allDay = allDay;
      def.hasEnd = hasEnd;

      for (var _i = 0, _a = calendar.pluginSystem.hooks.eventDefParsers; _i < _a.length; _i++) {
        var eventDefParser = _a[_i];
        var newLeftovers = {};
        eventDefParser(def, leftovers, newLeftovers);
        leftovers = newLeftovers;
      }

      def.extendedProps = _assign(leftovers, def.extendedProps || {}); // help out EventApi from having user modify props

      Object.freeze(def.ui.classNames);
      Object.freeze(def.extendedProps);
      return def;
    }

    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {
      return {
        instanceId: String(uid++),
        defId: defId,
        range: range,
        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
      };
    }

    function parseSingle(raw, allDayDefault, calendar, leftovers, allowOpenRange) {
      var props = pluckDateProps(raw, leftovers);
      var allDay = props.allDay;
      var startMeta;
      var startMarker = null;
      var hasEnd = false;
      var endMeta;
      var endMarker = null;
      startMeta = calendar.dateEnv.createMarkerMeta(props.start);

      if (startMeta) {
        startMarker = startMeta.marker;
      } else if (!allowOpenRange) {
        return null;
      }

      if (props.end != null) {
        endMeta = calendar.dateEnv.createMarkerMeta(props.end);
      }

      if (allDay == null) {
        if (allDayDefault != null) {
          allDay = allDayDefault;
        } else {
          // fall back to the date props LAST
          allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
        }
      }

      if (allDay && startMarker) {
        startMarker = startOfDay(startMarker);
      }

      if (endMeta) {
        endMarker = endMeta.marker;

        if (allDay) {
          endMarker = startOfDay(endMarker);
        }

        if (startMarker && endMarker <= startMarker) {
          endMarker = null;
        }
      }

      if (endMarker) {
        hasEnd = true;
      } else if (!allowOpenRange) {
        hasEnd = calendar.opt('forceEventDuration') || false;
        endMarker = calendar.dateEnv.add(startMarker, allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration);
      }

      return {
        allDay: allDay,
        hasEnd: hasEnd,
        range: {
          start: startMarker,
          end: endMarker
        },
        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
        forcedEndTzo: endMeta ? endMeta.forcedTzo : null
      };
    }

    function pluckDateProps(raw, leftovers) {
      var props = refineProps(raw, DATE_PROPS, {}, leftovers);
      props.start = props.start !== null ? props.start : props.date;
      delete props.date;
      return props;
    }

    function pluckNonDateProps(raw, calendar, leftovers) {
      var preLeftovers = {};
      var props = refineProps(raw, NON_DATE_PROPS, {}, preLeftovers);
      var ui = processUnscopedUiProps(preLeftovers, calendar, leftovers);
      props.publicId = props.id;
      delete props.id;
      props.ui = ui;
      return props;
    }

    function computeIsAllDayDefault(sourceId, calendar) {
      var res = null;

      if (sourceId) {
        var source = calendar.state.eventSources[sourceId];
        res = source.allDayDefault;
      }

      if (res == null) {
        res = calendar.opt('allDayDefault');
      }

      return res;
    }

    var DEF_DEFAULTS = {
      startTime: '09:00',
      endTime: '17:00',
      daysOfWeek: [1, 2, 3, 4, 5],
      rendering: 'inverse-background',
      classNames: 'fc-nonbusiness',
      groupId: '_businessHours' // so multiple defs get grouped

    };
    /*
    TODO: pass around as EventDefHash!!!
    */

    function parseBusinessHours(input, calendar) {
      return parseEvents(refineInputs(input), '', calendar);
    }

    function refineInputs(input) {
      var rawDefs;

      if (input === true) {
        rawDefs = [{}]; // will get DEF_DEFAULTS verbatim
      } else if (Array.isArray(input)) {
        // if specifying an array, every sub-definition NEEDS a day-of-week
        rawDefs = input.filter(function (rawDef) {
          return rawDef.daysOfWeek;
        });
      } else if (typeof input === 'object' && input) {
        // non-null object
        rawDefs = [input];
      } else {
        // is probably false
        rawDefs = [];
      }

      rawDefs = rawDefs.map(function (rawDef) {
        return _assign({}, DEF_DEFAULTS, rawDef);
      });
      return rawDefs;
    }

    function memoizeRendering(renderFunc, unrenderFunc, dependencies) {
      if (dependencies === void 0) {
        dependencies = [];
      }

      var dependents = [];
      var thisContext;
      var prevArgs;

      function unrender() {
        if (prevArgs) {
          for (var _i = 0, dependents_1 = dependents; _i < dependents_1.length; _i++) {
            var dependent = dependents_1[_i];
            dependent.unrender();
          }

          if (unrenderFunc) {
            unrenderFunc.apply(thisContext, prevArgs);
          }

          prevArgs = null;
        }
      }

      function res() {
        if (!prevArgs || !isArraysEqual(prevArgs, arguments)) {
          unrender();
          thisContext = this;
          prevArgs = arguments;
          renderFunc.apply(this, arguments);
        }
      }

      res.dependents = dependents;
      res.unrender = unrender;

      for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
        var dependency = dependencies_1[_i];
        dependency.dependents.push(res);
      }

      return res;
    }

    var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere

    var Splitter =
    /** @class */
    function () {
      function Splitter() {
        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
        this.splitDateSelection = memoize(this._splitDateSpan);
        this.splitEventStore = memoize(this._splitEventStore);
        this.splitIndividualUi = memoize(this._splitIndividualUi);
        this.splitEventDrag = memoize(this._splitInteraction);
        this.splitEventResize = memoize(this._splitInteraction);
        this.eventUiBuilders = {}; // TODO: typescript protection
      }

      Splitter.prototype.splitProps = function (props) {
        var _this = this;

        var keyInfos = this.getKeyInfo(props);
        var defKeys = this.getKeysForEventDefs(props.eventStore);
        var dateSelections = this.splitDateSelection(props.dateSelection);
        var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*

        var eventStores = this.splitEventStore(props.eventStore, defKeys);
        var eventDrags = this.splitEventDrag(props.eventDrag);
        var eventResizes = this.splitEventResize(props.eventResize);
        var splitProps = {};
        this.eventUiBuilders = mapHash(keyInfos, function (info, key) {
          return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);
        });

        for (var key in keyInfos) {
          var keyInfo = keyInfos[key];
          var eventStore = eventStores[key] || EMPTY_EVENT_STORE;
          var buildEventUi = this.eventUiBuilders[key];
          splitProps[key] = {
            businessHours: keyInfo.businessHours || props.businessHours,
            dateSelection: dateSelections[key] || null,
            eventStore: eventStore,
            eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),
            eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',
            eventDrag: eventDrags[key] || null,
            eventResize: eventResizes[key] || null
          };
        }

        return splitProps;
      };

      Splitter.prototype._splitDateSpan = function (dateSpan) {
        var dateSpans = {};

        if (dateSpan) {
          var keys = this.getKeysForDateSpan(dateSpan);

          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            dateSpans[key] = dateSpan;
          }
        }

        return dateSpans;
      };

      Splitter.prototype._getKeysForEventDefs = function (eventStore) {
        var _this = this;

        return mapHash(eventStore.defs, function (eventDef) {
          return _this.getKeysForEventDef(eventDef);
        });
      };

      Splitter.prototype._splitEventStore = function (eventStore, defKeys) {
        var defs = eventStore.defs,
            instances = eventStore.instances;
        var splitStores = {};

        for (var defId in defs) {
          for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
            var key = _a[_i];

            if (!splitStores[key]) {
              splitStores[key] = createEmptyEventStore();
            }

            splitStores[key].defs[defId] = defs[defId];
          }
        }

        for (var instanceId in instances) {
          var instance = instances[instanceId];

          for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {
            var key = _c[_b];

            if (splitStores[key]) {
              // must have already been created
              splitStores[key].instances[instanceId] = instance;
            }
          }
        }

        return splitStores;
      };

      Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {
        var splitHashes = {};

        for (var defId in eventUiBases) {
          if (defId) {
            // not the '' key
            for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {
              var key = _a[_i];

              if (!splitHashes[key]) {
                splitHashes[key] = {};
              }

              splitHashes[key][defId] = eventUiBases[defId];
            }
          }
        }

        return splitHashes;
      };

      Splitter.prototype._splitInteraction = function (interaction) {
        var splitStates = {};

        if (interaction) {
          var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents) // can't use cached. might be events from other calendar
          ); // can't rely on defKeys because event data is mutated


          var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);

          var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);

          var populate = function populate(key) {
            if (!splitStates[key]) {
              splitStates[key] = {
                affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,
                mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,
                isEvent: interaction.isEvent,
                origSeg: interaction.origSeg
              };
            }
          };

          for (var key in affectedStores_1) {
            populate(key);
          }

          for (var key in mutatedStores_1) {
            populate(key);
          }
        }

        return splitStates;
      };

      return Splitter;
    }();

    function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
      var baseParts = [];

      if (allUi) {
        baseParts.push(allUi);
      }

      if (eventUiForKey) {
        baseParts.push(eventUiForKey);
      }

      var stuff = {
        '': combineEventUis(baseParts)
      };

      if (individualUi) {
        _assign(stuff, individualUi);
      }

      return stuff;
    } // Generates HTML for an anchor to another view into the calendar.
    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
    // `gotoOptions` can either be a DateMarker, or an object with the form:
    // { date, type, forceOff }
    // `type` is a view-type like "day" or "week". default value is "day".
    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.


    function buildGotoAnchorHtml(allOptions, dateEnv, gotoOptions, attrs, innerHtml) {
      var date;
      var type;
      var forceOff;
      var finalOptions;

      if (gotoOptions instanceof Date) {
        date = gotoOptions; // a single date-like input
      } else {
        date = gotoOptions.date;
        type = gotoOptions.type;
        forceOff = gotoOptions.forceOff;
      }

      finalOptions = {
        date: dateEnv.formatIso(date, {
          omitTime: true
        }),
        type: type || 'day'
      };

      if (typeof attrs === 'string') {
        innerHtml = attrs;
        attrs = null;
      }

      attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space

      innerHtml = innerHtml || '';

      if (!forceOff && allOptions.navLinks) {
        return '<a' + attrs + ' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' + innerHtml + '</a>';
      } else {
        return '<span' + attrs + '>' + innerHtml + '</span>';
      }
    }

    function getAllDayHtml(allOptions) {
      return allOptions.allDayHtml || htmlEscape(allOptions.allDayText);
    } // Computes HTML classNames for a single-day element


    function getDayClasses(date, dateProfile, context, noThemeHighlight) {
      var calendar = context.calendar,
          options = context.options,
          theme = context.theme,
          dateEnv = context.dateEnv;
      var classes = [];
      var todayStart;
      var todayEnd;

      if (!rangeContainsMarker(dateProfile.activeRange, date)) {
        classes.push('fc-disabled-day');
      } else {
        classes.push('fc-' + DAY_IDS[date.getUTCDay()]);

        if (options.monthMode && dateEnv.getMonth(date) !== dateEnv.getMonth(dateProfile.currentRange.start)) {
          classes.push('fc-other-month');
        }

        todayStart = startOfDay(calendar.getNow());
        todayEnd = addDays(todayStart, 1);

        if (date < todayStart) {
          classes.push('fc-past');
        } else if (date >= todayEnd) {
          classes.push('fc-future');
        } else {
          classes.push('fc-today');

          if (noThemeHighlight !== true) {
            classes.push(theme.getClass('today'));
          }
        }
      }

      return classes;
    } // given a function that resolves a result asynchronously.
    // the function can either call passed-in success and failure callbacks,
    // or it can return a promise.
    // if you need to pass additional params to func, bind them first.


    function unpromisify(func, success, failure) {
      // guard against success/failure callbacks being called more than once
      // and guard against a promise AND callback being used together.
      var isResolved = false;

      var wrappedSuccess = function wrappedSuccess() {
        if (!isResolved) {
          isResolved = true;
          success.apply(this, arguments);
        }
      };

      var wrappedFailure = function wrappedFailure() {
        if (!isResolved) {
          isResolved = true;

          if (failure) {
            failure.apply(this, arguments);
          }
        }
      };

      var res = func(wrappedSuccess, wrappedFailure);

      if (res && typeof res.then === 'function') {
        res.then(wrappedSuccess, wrappedFailure);
      }
    }

    var Mixin =
    /** @class */
    function () {
      function Mixin() {} // mix into a CLASS


      Mixin.mixInto = function (destClass) {
        this.mixIntoObj(destClass.prototype);
      }; // mix into ANY object


      Mixin.mixIntoObj = function (destObj) {
        var _this = this;

        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
          if (!destObj[name]) {
            // if destination doesn't already define it
            destObj[name] = _this.prototype[name];
          }
        });
      };
      /*
      will override existing methods
      TODO: remove! not used anymore
      */


      Mixin.mixOver = function (destClass) {
        var _this = this;

        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
          destClass.prototype[name] = _this.prototype[name];
        });
      };

      return Mixin;
    }();
    /*
    USAGE:
      import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
    in class:
      on: EmitterInterface['on']
      one: EmitterInterface['one']
      off: EmitterInterface['off']
      trigger: EmitterInterface['trigger']
      triggerWith: EmitterInterface['triggerWith']
      hasHandlers: EmitterInterface['hasHandlers']
    after class:
      EmitterMixin.mixInto(TheClass)
    */


    var EmitterMixin =
    /** @class */
    function (_super) {
      __extends(EmitterMixin, _super);

      function EmitterMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      EmitterMixin.prototype.on = function (type, handler) {
        addToHash(this._handlers || (this._handlers = {}), type, handler);
        return this; // for chaining
      }; // todo: add comments


      EmitterMixin.prototype.one = function (type, handler) {
        addToHash(this._oneHandlers || (this._oneHandlers = {}), type, handler);
        return this; // for chaining
      };

      EmitterMixin.prototype.off = function (type, handler) {
        if (this._handlers) {
          removeFromHash(this._handlers, type, handler);
        }

        if (this._oneHandlers) {
          removeFromHash(this._oneHandlers, type, handler);
        }

        return this; // for chaining
      };

      EmitterMixin.prototype.trigger = function (type) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        this.triggerWith(type, this, args);
        return this; // for chaining
      };

      EmitterMixin.prototype.triggerWith = function (type, context, args) {
        if (this._handlers) {
          applyAll(this._handlers[type], context, args);
        }

        if (this._oneHandlers) {
          applyAll(this._oneHandlers[type], context, args);
          delete this._oneHandlers[type]; // will never fire again
        }

        return this; // for chaining
      };

      EmitterMixin.prototype.hasHandlers = function (type) {
        return this._handlers && this._handlers[type] && this._handlers[type].length || this._oneHandlers && this._oneHandlers[type] && this._oneHandlers[type].length;
      };

      return EmitterMixin;
    }(Mixin);

    function addToHash(hash, type, handler) {
      (hash[type] || (hash[type] = [])).push(handler);
    }

    function removeFromHash(hash, type, handler) {
      if (handler) {
        if (hash[type]) {
          hash[type] = hash[type].filter(function (func) {
            return func !== handler;
          });
        }
      } else {
        delete hash[type]; // remove all handler funcs for this type
      }
    }
    /*
    Records offset information for a set of elements, relative to an origin element.
    Can record the left/right OR the top/bottom OR both.
    Provides methods for querying the cache by position.
    */


    var PositionCache =
    /** @class */
    function () {
      function PositionCache(originEl, els, isHorizontal, isVertical) {
        this.originEl = originEl;
        this.els = els;
        this.isHorizontal = isHorizontal;
        this.isVertical = isVertical;
      } // Queries the els for coordinates and stores them.
      // Call this method before using and of the get* methods below.


      PositionCache.prototype.build = function () {
        var originEl = this.originEl;
        var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left

        if (this.isHorizontal) {
          this.buildElHorizontals(originClientRect.left);
        }

        if (this.isVertical) {
          this.buildElVerticals(originClientRect.top);
        }
      }; // Populates the left/right internal coordinate arrays


      PositionCache.prototype.buildElHorizontals = function (originClientLeft) {
        var lefts = [];
        var rights = [];

        for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
          var el = _a[_i];
          var rect = el.getBoundingClientRect();
          lefts.push(rect.left - originClientLeft);
          rights.push(rect.right - originClientLeft);
        }

        this.lefts = lefts;
        this.rights = rights;
      }; // Populates the top/bottom internal coordinate arrays


      PositionCache.prototype.buildElVerticals = function (originClientTop) {
        var tops = [];
        var bottoms = [];

        for (var _i = 0, _a = this.els; _i < _a.length; _i++) {
          var el = _a[_i];
          var rect = el.getBoundingClientRect();
          tops.push(rect.top - originClientTop);
          bottoms.push(rect.bottom - originClientTop);
        }

        this.tops = tops;
        this.bottoms = bottoms;
      }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
      // If no intersection is made, returns undefined.


      PositionCache.prototype.leftToIndex = function (leftPosition) {
        var lefts = this.lefts;
        var rights = this.rights;
        var len = lefts.length;
        var i;

        for (i = 0; i < len; i++) {
          if (leftPosition >= lefts[i] && leftPosition < rights[i]) {
            return i;
          }
        }
      }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.
      // If no intersection is made, returns undefined.


      PositionCache.prototype.topToIndex = function (topPosition) {
        var tops = this.tops;
        var bottoms = this.bottoms;
        var len = tops.length;
        var i;

        for (i = 0; i < len; i++) {
          if (topPosition >= tops[i] && topPosition < bottoms[i]) {
            return i;
          }
        }
      }; // Gets the width of the element at the given index


      PositionCache.prototype.getWidth = function (leftIndex) {
        return this.rights[leftIndex] - this.lefts[leftIndex];
      }; // Gets the height of the element at the given index


      PositionCache.prototype.getHeight = function (topIndex) {
        return this.bottoms[topIndex] - this.tops[topIndex];
      };

      return PositionCache;
    }();
    /*
    An object for getting/setting scroll-related information for an element.
    Internally, this is done very differently for window versus DOM element,
    so this object serves as a common interface.
    */


    var ScrollController =
    /** @class */
    function () {
      function ScrollController() {}

      ScrollController.prototype.getMaxScrollTop = function () {
        return this.getScrollHeight() - this.getClientHeight();
      };

      ScrollController.prototype.getMaxScrollLeft = function () {
        return this.getScrollWidth() - this.getClientWidth();
      };

      ScrollController.prototype.canScrollVertically = function () {
        return this.getMaxScrollTop() > 0;
      };

      ScrollController.prototype.canScrollHorizontally = function () {
        return this.getMaxScrollLeft() > 0;
      };

      ScrollController.prototype.canScrollUp = function () {
        return this.getScrollTop() > 0;
      };

      ScrollController.prototype.canScrollDown = function () {
        return this.getScrollTop() < this.getMaxScrollTop();
      };

      ScrollController.prototype.canScrollLeft = function () {
        return this.getScrollLeft() > 0;
      };

      ScrollController.prototype.canScrollRight = function () {
        return this.getScrollLeft() < this.getMaxScrollLeft();
      };

      return ScrollController;
    }();

    var ElementScrollController =
    /** @class */
    function (_super) {
      __extends(ElementScrollController, _super);

      function ElementScrollController(el) {
        var _this = _super.call(this) || this;

        _this.el = el;
        return _this;
      }

      ElementScrollController.prototype.getScrollTop = function () {
        return this.el.scrollTop;
      };

      ElementScrollController.prototype.getScrollLeft = function () {
        return this.el.scrollLeft;
      };

      ElementScrollController.prototype.setScrollTop = function (top) {
        this.el.scrollTop = top;
      };

      ElementScrollController.prototype.setScrollLeft = function (left) {
        this.el.scrollLeft = left;
      };

      ElementScrollController.prototype.getScrollWidth = function () {
        return this.el.scrollWidth;
      };

      ElementScrollController.prototype.getScrollHeight = function () {
        return this.el.scrollHeight;
      };

      ElementScrollController.prototype.getClientHeight = function () {
        return this.el.clientHeight;
      };

      ElementScrollController.prototype.getClientWidth = function () {
        return this.el.clientWidth;
      };

      return ElementScrollController;
    }(ScrollController);

    var WindowScrollController =
    /** @class */
    function (_super) {
      __extends(WindowScrollController, _super);

      function WindowScrollController() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      WindowScrollController.prototype.getScrollTop = function () {
        return window.pageYOffset;
      };

      WindowScrollController.prototype.getScrollLeft = function () {
        return window.pageXOffset;
      };

      WindowScrollController.prototype.setScrollTop = function (n) {
        window.scroll(window.pageXOffset, n);
      };

      WindowScrollController.prototype.setScrollLeft = function (n) {
        window.scroll(n, window.pageYOffset);
      };

      WindowScrollController.prototype.getScrollWidth = function () {
        return document.documentElement.scrollWidth;
      };

      WindowScrollController.prototype.getScrollHeight = function () {
        return document.documentElement.scrollHeight;
      };

      WindowScrollController.prototype.getClientHeight = function () {
        return document.documentElement.clientHeight;
      };

      WindowScrollController.prototype.getClientWidth = function () {
        return document.documentElement.clientWidth;
      };

      return WindowScrollController;
    }(ScrollController);
    /*
    Embodies a div that has potential scrollbars
    */


    var ScrollComponent =
    /** @class */
    function (_super) {
      __extends(ScrollComponent, _super);

      function ScrollComponent(overflowX, overflowY) {
        var _this = _super.call(this, createElement('div', {
          className: 'fc-scroller'
        })) || this;

        _this.overflowX = overflowX;
        _this.overflowY = overflowY;

        _this.applyOverflow();

        return _this;
      } // sets to natural height, unlocks overflow


      ScrollComponent.prototype.clear = function () {
        this.setHeight('auto');
        this.applyOverflow();
      };

      ScrollComponent.prototype.destroy = function () {
        removeElement(this.el);
      }; // Overflow
      // -----------------------------------------------------------------------------------------------------------------


      ScrollComponent.prototype.applyOverflow = function () {
        applyStyle(this.el, {
          overflowX: this.overflowX,
          overflowY: this.overflowY
        });
      }; // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
      // Useful for preserving scrollbar widths regardless of future resizes.
      // Can pass in scrollbarWidths for optimization.


      ScrollComponent.prototype.lockOverflow = function (scrollbarWidths) {
        var overflowX = this.overflowX;
        var overflowY = this.overflowY;
        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

        if (overflowX === 'auto') {
          overflowX = scrollbarWidths.bottom || // horizontal scrollbars?
          this.canScrollHorizontally() // OR scrolling pane with massless scrollbars?
          ? 'scroll' : 'hidden';
        }

        if (overflowY === 'auto') {
          overflowY = scrollbarWidths.left || scrollbarWidths.right || // horizontal scrollbars?
          this.canScrollVertically() // OR scrolling pane with massless scrollbars?
          ? 'scroll' : 'hidden';
        }

        applyStyle(this.el, {
          overflowX: overflowX,
          overflowY: overflowY
        });
      };

      ScrollComponent.prototype.setHeight = function (height) {
        applyStyleProp(this.el, 'height', height);
      };

      ScrollComponent.prototype.getScrollbarWidths = function () {
        var edges = computeEdges(this.el);
        return {
          left: edges.scrollbarLeft,
          right: edges.scrollbarRight,
          bottom: edges.scrollbarBottom
        };
      };

      return ScrollComponent;
    }(ElementScrollController);

    var Theme =
    /** @class */
    function () {
      function Theme(calendarOptions) {
        this.calendarOptions = calendarOptions;
        this.processIconOverride();
      }

      Theme.prototype.processIconOverride = function () {
        if (this.iconOverrideOption) {
          this.setIconOverride(this.calendarOptions[this.iconOverrideOption]);
        }
      };

      Theme.prototype.setIconOverride = function (iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;

        if (typeof iconOverrideHash === 'object' && iconOverrideHash) {
          // non-null object
          iconClassesCopy = _assign({}, this.iconClasses);

          for (buttonName in iconOverrideHash) {
            iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
          }

          this.iconClasses = iconClassesCopy;
        } else if (iconOverrideHash === false) {
          this.iconClasses = {};
        }
      };

      Theme.prototype.applyIconOverridePrefix = function (className) {
        var prefix = this.iconOverridePrefix;

        if (prefix && className.indexOf(prefix) !== 0) {
          // if not already present
          className = prefix + className;
        }

        return className;
      };

      Theme.prototype.getClass = function (key) {
        return this.classes[key] || '';
      };

      Theme.prototype.getIconClass = function (buttonName) {
        var className = this.iconClasses[buttonName];

        if (className) {
          return this.baseIconClass + ' ' + className;
        }

        return '';
      };

      Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
        var className;

        if (this.iconOverrideCustomButtonOption) {
          className = customButtonProps[this.iconOverrideCustomButtonOption];

          if (className) {
            return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
          }
        }

        return '';
      };

      return Theme;
    }();

    Theme.prototype.classes = {};
    Theme.prototype.iconClasses = {};
    Theme.prototype.baseIconClass = '';
    Theme.prototype.iconOverridePrefix = '';
    var guid = 0;

    var ComponentContext =
    /** @class */
    function () {
      function ComponentContext(calendar, theme, dateEnv, options, view) {
        this.calendar = calendar;
        this.theme = theme;
        this.dateEnv = dateEnv;
        this.options = options;
        this.view = view;
        this.isRtl = options.dir === 'rtl';
        this.eventOrderSpecs = parseFieldSpecs(options.eventOrder);
        this.nextDayThreshold = createDuration(options.nextDayThreshold);
      }

      ComponentContext.prototype.extend = function (options, view) {
        return new ComponentContext(this.calendar, this.theme, this.dateEnv, options || this.options, view || this.view);
      };

      return ComponentContext;
    }();

    var Component =
    /** @class */
    function () {
      function Component() {
        this.everRendered = false;
        this.uid = String(guid++);
      }

      Component.addEqualityFuncs = function (newFuncs) {
        this.prototype.equalityFuncs = _assign({}, this.prototype.equalityFuncs, newFuncs);
      };

      Component.prototype.receiveProps = function (props, context) {
        this.receiveContext(context);

        var _a = recycleProps(this.props || {}, props, this.equalityFuncs),
            anyChanges = _a.anyChanges,
            comboProps = _a.comboProps;

        this.props = comboProps;

        if (anyChanges) {
          if (this.everRendered) {
            this.beforeUpdate();
          }

          this.render(comboProps, context);

          if (this.everRendered) {
            this.afterUpdate();
          }
        }

        this.everRendered = true;
      };

      Component.prototype.receiveContext = function (context) {
        var oldContext = this.context;
        this.context = context;

        if (!oldContext) {
          this.firstContext(context);
        }
      };

      Component.prototype.render = function (props, context) {};

      Component.prototype.firstContext = function (context) {};

      Component.prototype.beforeUpdate = function () {};

      Component.prototype.afterUpdate = function () {}; // after destroy is called, this component won't ever be used again


      Component.prototype.destroy = function () {};

      return Component;
    }();

    Component.prototype.equalityFuncs = {};
    /*
    Reuses old values when equal. If anything is unequal, returns newProps as-is.
    Great for PureComponent, but won't be feasible with React, so just eliminate and use React's DOM diffing.
    */

    function recycleProps(oldProps, newProps, equalityFuncs) {
      var comboProps = {}; // some old, some new

      var anyChanges = false;

      for (var key in newProps) {
        if (key in oldProps && (oldProps[key] === newProps[key] || equalityFuncs[key] && equalityFuncs[key](oldProps[key], newProps[key]))) {
          // equal to old? use old prop
          comboProps[key] = oldProps[key];
        } else {
          comboProps[key] = newProps[key];
          anyChanges = true;
        }
      }

      for (var key in oldProps) {
        if (!(key in newProps)) {
          anyChanges = true;
          break;
        }
      }

      return {
        anyChanges: anyChanges,
        comboProps: comboProps
      };
    }
    /*
    PURPOSES:
    - hook up to fg, fill, and mirror renderers
    - interface for dragging and hits
    */


    var DateComponent =
    /** @class */
    function (_super) {
      __extends(DateComponent, _super);

      function DateComponent(el) {
        var _this = _super.call(this) || this;

        _this.el = el;
        return _this;
      }

      DateComponent.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        removeElement(this.el);
      }; // Hit System
      // -----------------------------------------------------------------------------------------------------------------


      DateComponent.prototype.buildPositionCaches = function () {};

      DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
        return null; // this should be abstract
      }; // Validation
      // -----------------------------------------------------------------------------------------------------------------


      DateComponent.prototype.isInteractionValid = function (interaction) {
        var calendar = this.context.calendar;
        var dateProfile = this.props.dateProfile; // HACK

        var instances = interaction.mutatedEvents.instances;

        if (dateProfile) {
          // HACK for DayTile
          for (var instanceId in instances) {
            if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
              return false;
            }
          }
        }

        return isInteractionValid(interaction, calendar);
      };

      DateComponent.prototype.isDateSelectionValid = function (selection) {
        var calendar = this.context.calendar;
        var dateProfile = this.props.dateProfile; // HACK

        if (dateProfile && // HACK for DayTile
        !rangeContainsRange(dateProfile.validRange, selection.range)) {
          return false;
        }

        return isDateSelectionValid(selection, calendar);
      }; // Pointer Interaction Utils
      // -----------------------------------------------------------------------------------------------------------------


      DateComponent.prototype.isValidSegDownEl = function (el) {
        return !this.props.eventDrag && // HACK
        !this.props.eventResize && // HACK
        !elementClosest(el, '.fc-mirror') && (this.isPopover() || !this.isInPopover(el)); // ^above line ensures we don't detect a seg interaction within a nested component.
        // it's a HACK because it only supports a popover as the nested component.
      };

      DateComponent.prototype.isValidDateDownEl = function (el) {
        var segEl = elementClosest(el, this.fgSegSelector);
        return (!segEl || segEl.classList.contains('fc-mirror')) && !elementClosest(el, '.fc-more') && // a "more.." link
        !elementClosest(el, 'a[data-goto]') && // a clickable nav link
        !this.isInPopover(el);
      };

      DateComponent.prototype.isPopover = function () {
        return this.el.classList.contains('fc-popover');
      };

      DateComponent.prototype.isInPopover = function (el) {
        return Boolean(elementClosest(el, '.fc-popover'));
      };

      return DateComponent;
    }(Component);

    DateComponent.prototype.fgSegSelector = '.fc-event-container > *';
    DateComponent.prototype.bgSegSelector = '.fc-bgevent:not(.fc-nonbusiness)';
    var uid$1 = 0;

    function createPlugin(input) {
      return {
        id: String(uid$1++),
        deps: input.deps || [],
        reducers: input.reducers || [],
        eventDefParsers: input.eventDefParsers || [],
        isDraggableTransformers: input.isDraggableTransformers || [],
        eventDragMutationMassagers: input.eventDragMutationMassagers || [],
        eventDefMutationAppliers: input.eventDefMutationAppliers || [],
        dateSelectionTransformers: input.dateSelectionTransformers || [],
        datePointTransforms: input.datePointTransforms || [],
        dateSpanTransforms: input.dateSpanTransforms || [],
        views: input.views || {},
        viewPropsTransformers: input.viewPropsTransformers || [],
        isPropsValid: input.isPropsValid || null,
        externalDefTransforms: input.externalDefTransforms || [],
        eventResizeJoinTransforms: input.eventResizeJoinTransforms || [],
        viewContainerModifiers: input.viewContainerModifiers || [],
        eventDropTransformers: input.eventDropTransformers || [],
        componentInteractions: input.componentInteractions || [],
        calendarInteractions: input.calendarInteractions || [],
        themeClasses: input.themeClasses || {},
        eventSourceDefs: input.eventSourceDefs || [],
        cmdFormatter: input.cmdFormatter,
        recurringTypes: input.recurringTypes || [],
        namedTimeZonedImpl: input.namedTimeZonedImpl,
        defaultView: input.defaultView || '',
        elementDraggingImpl: input.elementDraggingImpl,
        optionChangeHandlers: input.optionChangeHandlers || {}
      };
    }

    var PluginSystem =
    /** @class */
    function () {
      function PluginSystem() {
        this.hooks = {
          reducers: [],
          eventDefParsers: [],
          isDraggableTransformers: [],
          eventDragMutationMassagers: [],
          eventDefMutationAppliers: [],
          dateSelectionTransformers: [],
          datePointTransforms: [],
          dateSpanTransforms: [],
          views: {},
          viewPropsTransformers: [],
          isPropsValid: null,
          externalDefTransforms: [],
          eventResizeJoinTransforms: [],
          viewContainerModifiers: [],
          eventDropTransformers: [],
          componentInteractions: [],
          calendarInteractions: [],
          themeClasses: {},
          eventSourceDefs: [],
          cmdFormatter: null,
          recurringTypes: [],
          namedTimeZonedImpl: null,
          defaultView: '',
          elementDraggingImpl: null,
          optionChangeHandlers: {}
        };
        this.addedHash = {};
      }

      PluginSystem.prototype.add = function (plugin) {
        if (!this.addedHash[plugin.id]) {
          this.addedHash[plugin.id] = true;

          for (var _i = 0, _a = plugin.deps; _i < _a.length; _i++) {
            var dep = _a[_i];
            this.add(dep);
          }

          this.hooks = combineHooks(this.hooks, plugin);
        }
      };

      return PluginSystem;
    }();

    function combineHooks(hooks0, hooks1) {
      return {
        reducers: hooks0.reducers.concat(hooks1.reducers),
        eventDefParsers: hooks0.eventDefParsers.concat(hooks1.eventDefParsers),
        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
        views: _assign({}, hooks0.views, hooks1.views),
        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
        eventResizeJoinTransforms: hooks0.eventResizeJoinTransforms.concat(hooks1.eventResizeJoinTransforms),
        viewContainerModifiers: hooks0.viewContainerModifiers.concat(hooks1.viewContainerModifiers),
        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
        themeClasses: _assign({}, hooks0.themeClasses, hooks1.themeClasses),
        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
        defaultView: hooks0.defaultView || hooks1.defaultView,
        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
        optionChangeHandlers: _assign({}, hooks0.optionChangeHandlers, hooks1.optionChangeHandlers)
      };
    }

    var eventSourceDef = {
      ignoreRange: true,
      parseMeta: function parseMeta(raw) {
        if (Array.isArray(raw)) {
          // short form
          return raw;
        } else if (Array.isArray(raw.events)) {
          return raw.events;
        }

        return null;
      },
      fetch: function fetch(arg, success) {
        success({
          rawEvents: arg.eventSource.meta
        });
      }
    };
    var ArrayEventSourcePlugin = createPlugin({
      eventSourceDefs: [eventSourceDef]
    });
    var eventSourceDef$1 = {
      parseMeta: function parseMeta(raw) {
        if (typeof raw === 'function') {
          // short form
          return raw;
        } else if (typeof raw.events === 'function') {
          return raw.events;
        }

        return null;
      },
      fetch: function fetch(arg, success, failure) {
        var dateEnv = arg.calendar.dateEnv;
        var func = arg.eventSource.meta;
        unpromisify(func.bind(null, {
          start: dateEnv.toDate(arg.range.start),
          end: dateEnv.toDate(arg.range.end),
          startStr: dateEnv.formatIso(arg.range.start),
          endStr: dateEnv.formatIso(arg.range.end),
          timeZone: dateEnv.timeZone
        }), function (rawEvents) {
          success({
            rawEvents: rawEvents
          }); // needs an object response
        }, failure // send errorObj directly to failure callback
        );
      }
    };
    var FuncEventSourcePlugin = createPlugin({
      eventSourceDefs: [eventSourceDef$1]
    });

    function requestJson(method, url, params, successCallback, failureCallback) {
      method = method.toUpperCase();
      var body = null;

      if (method === 'GET') {
        url = injectQueryStringParams(url, params);
      } else {
        body = encodeParams(params);
      }

      var xhr = new XMLHttpRequest();
      xhr.open(method, url, true);

      if (method !== 'GET') {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      }

      xhr.onload = function () {
        if (xhr.status >= 200 && xhr.status < 400) {
          try {
            var res = JSON.parse(xhr.responseText);
            successCallback(res, xhr);
          } catch (err) {
            failureCallback('Failure parsing JSON', xhr);
          }
        } else {
          failureCallback('Request failed', xhr);
        }
      };

      xhr.onerror = function () {
        failureCallback('Request failed', xhr);
      };

      xhr.send(body);
    }

    function injectQueryStringParams(url, params) {
      return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);
    }

    function encodeParams(params) {
      var parts = [];

      for (var key in params) {
        parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
      }

      return parts.join('&');
    }

    var eventSourceDef$2 = {
      parseMeta: function parseMeta(raw) {
        if (typeof raw === 'string') {
          // short form
          raw = {
            url: raw
          };
        } else if (!raw || typeof raw !== 'object' || !raw.url) {
          return null;
        }

        return {
          url: raw.url,
          method: (raw.method || 'GET').toUpperCase(),
          extraParams: raw.extraParams,
          startParam: raw.startParam,
          endParam: raw.endParam,
          timeZoneParam: raw.timeZoneParam
        };
      },
      fetch: function fetch(arg, success, failure) {
        var meta = arg.eventSource.meta;
        var requestParams = buildRequestParams(meta, arg.range, arg.calendar);
        requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {
          success({
            rawEvents: rawEvents,
            xhr: xhr
          });
        }, function (errorMessage, xhr) {
          failure({
            message: errorMessage,
            xhr: xhr
          });
        });
      }
    };
    var JsonFeedEventSourcePlugin = createPlugin({
      eventSourceDefs: [eventSourceDef$2]
    });

    function buildRequestParams(meta, range, calendar) {
      var dateEnv = calendar.dateEnv;
      var startParam;
      var endParam;
      var timeZoneParam;
      var customRequestParams;
      var params = {};
      startParam = meta.startParam;

      if (startParam == null) {
        startParam = calendar.opt('startParam');
      }

      endParam = meta.endParam;

      if (endParam == null) {
        endParam = calendar.opt('endParam');
      }

      timeZoneParam = meta.timeZoneParam;

      if (timeZoneParam == null) {
        timeZoneParam = calendar.opt('timeZoneParam');
      } // retrieve any outbound GET/POST data from the options


      if (typeof meta.extraParams === 'function') {
        // supplied as a function that returns a key/value object
        customRequestParams = meta.extraParams();
      } else {
        // probably supplied as a straight key/value object
        customRequestParams = meta.extraParams || {};
      }

      _assign(params, customRequestParams);

      params[startParam] = dateEnv.formatIso(range.start);
      params[endParam] = dateEnv.formatIso(range.end);

      if (dateEnv.timeZone !== 'local') {
        params[timeZoneParam] = dateEnv.timeZone;
      }

      return params;
    }

    var recurring = {
      parse: function parse(rawEvent, leftoverProps, dateEnv) {
        var createMarker = dateEnv.createMarker.bind(dateEnv);
        var processors = {
          daysOfWeek: null,
          startTime: createDuration,
          endTime: createDuration,
          startRecur: createMarker,
          endRecur: createMarker
        };
        var props = refineProps(rawEvent, processors, {}, leftoverProps);
        var anyValid = false;

        for (var propName in props) {
          if (props[propName] != null) {
            anyValid = true;
            break;
          }
        }

        if (anyValid) {
          var duration = null;

          if ('duration' in leftoverProps) {
            duration = createDuration(leftoverProps.duration);
            delete leftoverProps.duration;
          }

          if (!duration && props.startTime && props.endTime) {
            duration = subtractDurations(props.endTime, props.startTime);
          }

          return {
            allDayGuess: Boolean(!props.startTime && !props.endTime),
            duration: duration,
            typeData: props // doesn't need endTime anymore but oh well

          };
        }

        return null;
      },
      expand: function expand(typeData, framingRange, dateEnv) {
        var clippedFramingRange = intersectRanges(framingRange, {
          start: typeData.startRecur,
          end: typeData.endRecur
        });

        if (clippedFramingRange) {
          return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
        } else {
          return [];
        }
      }
    };
    var SimpleRecurrencePlugin = createPlugin({
      recurringTypes: [recurring]
    });

    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {
      var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;
      var dayMarker = startOfDay(framingRange.start);
      var endMarker = framingRange.end;
      var instanceStarts = [];

      while (dayMarker < endMarker) {
        var instanceStart // if everyday, or this particular day-of-week
        = void 0; // if everyday, or this particular day-of-week

        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
          if (startTime) {
            instanceStart = dateEnv.add(dayMarker, startTime);
          } else {
            instanceStart = dayMarker;
          }

          instanceStarts.push(instanceStart);
        }

        dayMarker = addDays(dayMarker, 1);
      }

      return instanceStarts;
    }

    var DefaultOptionChangeHandlers = createPlugin({
      optionChangeHandlers: {
        events: function events(_events, calendar, deepEqual) {
          handleEventSources([_events], calendar, deepEqual);
        },
        eventSources: handleEventSources,
        plugins: handlePlugins
      }
    });

    function handleEventSources(inputs, calendar, deepEqual) {
      var unfoundSources = hashValuesToArray(calendar.state.eventSources);
      var newInputs = [];

      for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
        var input = inputs_1[_i];
        var inputFound = false;

        for (var i = 0; i < unfoundSources.length; i++) {
          if (deepEqual(unfoundSources[i]._raw, input)) {
            unfoundSources.splice(i, 1); // delete

            inputFound = true;
            break;
          }
        }

        if (!inputFound) {
          newInputs.push(input);
        }
      }

      for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {
        var unfoundSource = unfoundSources_1[_a];
        calendar.dispatch({
          type: 'REMOVE_EVENT_SOURCE',
          sourceId: unfoundSource.sourceId
        });
      }

      for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {
        var newInput = newInputs_1[_b];
        calendar.addEventSource(newInput);
      }
    } // shortcoming: won't remove plugins


    function handlePlugins(inputs, calendar) {
      calendar.addPluginInputs(inputs); // will gracefully handle duplicates
    }

    var config = {}; // TODO: make these options

    var globalDefaults = {
      defaultRangeSeparator: ' - ',
      titleRangeSeparator: " \u2013 ",
      defaultTimedEventDuration: '01:00:00',
      defaultAllDayEventDuration: {
        day: 1
      },
      forceEventDuration: false,
      nextDayThreshold: '00:00:00',
      // display
      columnHeader: true,
      defaultView: '',
      aspectRatio: 1.35,
      header: {
        left: 'title',
        center: '',
        right: 'today prev,next'
      },
      weekends: true,
      weekNumbers: false,
      weekNumberCalculation: 'local',
      editable: false,
      // nowIndicator: false,
      scrollTime: '06:00:00',
      minTime: '00:00:00',
      maxTime: '24:00:00',
      showNonCurrentDates: true,
      // event ajax
      lazyFetching: true,
      startParam: 'start',
      endParam: 'end',
      timeZoneParam: 'timeZone',
      timeZone: 'local',
      // allDayDefault: undefined,
      // locale
      locales: [],
      locale: '',
      // dir: will get this from the default locale
      // buttonIcons: null,
      // allows setting a min-height to the event segment to prevent short events overlapping each other
      timeGridEventMinHeight: 0,
      themeSystem: 'standard',
      // eventResizableFromStart: false,
      dragRevertDuration: 500,
      dragScroll: true,
      allDayMaintainDuration: false,
      // selectable: false,
      unselectAuto: true,
      // selectMinDistance: 0,
      dropAccept: '*',
      eventOrder: 'start,-duration,allDay,title',
      // ^ if start tie, longer events go before shorter. final tie-breaker is title text
      // rerenderDelay: null,
      eventLimit: false,
      eventLimitClick: 'popover',
      dayPopoverFormat: {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      },
      handleWindowResize: true,
      windowResizeDelay: 100,
      longPressDelay: 1000,
      eventDragMinDistance: 5 // only applies to mouse

    };
    var rtlDefaults = {
      header: {
        left: 'next,prev today',
        center: '',
        right: 'title'
      },
      buttonIcons: {
        // TODO: make RTL support the responibility of the theme
        prev: 'fc-icon-chevron-right',
        next: 'fc-icon-chevron-left',
        prevYear: 'fc-icon-chevrons-right',
        nextYear: 'fc-icon-chevrons-left'
      }
    };
    var complexOptions = ['header', 'footer', 'buttonText', 'buttonIcons']; // Merges an array of option objects into a single object

    function mergeOptions(optionObjs) {
      return mergeProps(optionObjs, complexOptions);
    } // TODO: move this stuff to a "plugin"-related file...


    var INTERNAL_PLUGINS = [ArrayEventSourcePlugin, FuncEventSourcePlugin, JsonFeedEventSourcePlugin, SimpleRecurrencePlugin, DefaultOptionChangeHandlers];

    function refinePluginDefs(pluginInputs) {
      var plugins = [];

      for (var _i = 0, pluginInputs_1 = pluginInputs; _i < pluginInputs_1.length; _i++) {
        var pluginInput = pluginInputs_1[_i];

        if (typeof pluginInput === 'string') {
          var globalName = 'FullCalendar' + capitaliseFirstLetter(pluginInput);

          if (!window[globalName]) {
            console.warn('Plugin file not loaded for ' + pluginInput);
          } else {
            plugins.push(window[globalName]["default"]); // is an ES6 module
          }
        } else {
          plugins.push(pluginInput);
        }
      }

      return INTERNAL_PLUGINS.concat(plugins);
    }

    var RAW_EN_LOCALE = {
      code: 'en',
      week: {
        dow: 0,
        doy: 4 // 4 days need to be within the year to be considered the first week

      },
      dir: 'ltr',
      buttonText: {
        prev: 'prev',
        next: 'next',
        prevYear: 'prev year',
        nextYear: 'next year',
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day',
        list: 'list'
      },
      weekLabel: 'W',
      allDayText: 'all-day',
      eventLimitText: 'more',
      noEventsMessage: 'No events to display'
    };

    function parseRawLocales(explicitRawLocales) {
      var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';
      var globalArray = window['FullCalendarLocalesAll'] || []; // from locales-all.js

      var globalObject = window['FullCalendarLocales'] || {}; // from locales/*.js. keys are meaningless

      var allRawLocales = globalArray.concat( // globalArray is low prio
      hashValuesToArray(globalObject), // medium prio
      explicitRawLocales // highest prio
      );
      var rawLocaleMap = {
        en: RAW_EN_LOCALE // necessary?

      };

      for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {
        var rawLocale = allRawLocales_1[_i];
        rawLocaleMap[rawLocale.code] = rawLocale;
      }

      return {
        map: rawLocaleMap,
        defaultCode: defaultCode
      };
    }

    function buildLocale(inputSingular, available) {
      if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {
        return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
      } else {
        return queryLocale(inputSingular, available);
      }
    }

    function queryLocale(codeArg, available) {
      var codes = [].concat(codeArg || []); // will convert to array

      var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
      return parseLocale(codeArg, codes, raw);
    }

    function queryRawLocale(codes, available) {
      for (var i = 0; i < codes.length; i++) {
        var parts = codes[i].toLocaleLowerCase().split('-');

        for (var j = parts.length; j > 0; j--) {
          var simpleId = parts.slice(0, j).join('-');

          if (available[simpleId]) {
            return available[simpleId];
          }
        }
      }

      return null;
    }

    function parseLocale(codeArg, codes, raw) {
      var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);
      delete merged.code; // don't want this part of the options

      var week = merged.week;
      delete merged.week;
      return {
        codeArg: codeArg,
        codes: codes,
        week: week,
        simpleNumberFormat: new Intl.NumberFormat(codeArg),
        options: merged
      };
    }

    var OptionsManager =
    /** @class */
    function () {
      function OptionsManager(overrides) {
        this.overrides = _assign({}, overrides); // make a copy

        this.dynamicOverrides = {};
        this.compute();
      }

      OptionsManager.prototype.mutate = function (updates, removals, isDynamic) {
        if (!Object.keys(updates).length && !removals.length) {
          return;
        }

        var overrideHash = isDynamic ? this.dynamicOverrides : this.overrides;

        _assign(overrideHash, updates);

        for (var _i = 0, removals_1 = removals; _i < removals_1.length; _i++) {
          var propName = removals_1[_i];
          delete overrideHash[propName];
        }

        this.compute();
      }; // Computes the flattened options hash for the calendar and assigns to `this.options`.
      // Assumes this.overrides and this.dynamicOverrides have already been initialized.


      OptionsManager.prototype.compute = function () {
        // TODO: not a very efficient system
        var locales = firstDefined( // explicit locale option given?
        this.dynamicOverrides.locales, this.overrides.locales, globalDefaults.locales);
        var locale = firstDefined( // explicit locales option given?
        this.dynamicOverrides.locale, this.overrides.locale, globalDefaults.locale);
        var available = parseRawLocales(locales);
        var localeDefaults = buildLocale(locale || available.defaultCode, available.map).options;
        var dir = firstDefined( // based on options computed so far, is direction RTL?
        this.dynamicOverrides.dir, this.overrides.dir, localeDefaults.dir);
        var dirDefaults = dir === 'rtl' ? rtlDefaults : {};
        this.dirDefaults = dirDefaults;
        this.localeDefaults = localeDefaults;
        this.computed = mergeOptions([globalDefaults, dirDefaults, localeDefaults, this.overrides, this.dynamicOverrides]);
      };

      return OptionsManager;
    }();

    var calendarSystemClassMap = {};

    function registerCalendarSystem(name, theClass) {
      calendarSystemClassMap[name] = theClass;
    }

    function createCalendarSystem(name) {
      return new calendarSystemClassMap[name]();
    }

    var GregorianCalendarSystem =
    /** @class */
    function () {
      function GregorianCalendarSystem() {}

      GregorianCalendarSystem.prototype.getMarkerYear = function (d) {
        return d.getUTCFullYear();
      };

      GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {
        return d.getUTCMonth();
      };

      GregorianCalendarSystem.prototype.getMarkerDay = function (d) {
        return d.getUTCDate();
      };

      GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {
        return arrayToUtcDate(arr);
      };

      GregorianCalendarSystem.prototype.markerToArray = function (marker) {
        return dateToUtcArray(marker);
      };

      return GregorianCalendarSystem;
    }();

    registerCalendarSystem('gregory', GregorianCalendarSystem);
    var ISO_RE = /^\s*(\d{4})(-(\d{2})(-(\d{2})([T ](\d{2}):(\d{2})(:(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;

    function parse(str) {
      var m = ISO_RE.exec(str);

      if (m) {
        var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number('0.' + m[12]) * 1000 : 0));

        if (isValidDate(marker)) {
          var timeZoneOffset = null;

          if (m[13]) {
            timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));
          }

          return {
            marker: marker,
            isTimeUnspecified: !m[6],
            timeZoneOffset: timeZoneOffset
          };
        }
      }

      return null;
    }

    var DateEnv =
    /** @class */
    function () {
      function DateEnv(settings) {
        var timeZone = this.timeZone = settings.timeZone;
        var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';

        if (settings.namedTimeZoneImpl && isNamedTimeZone) {
          this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
        }

        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
        this.calendarSystem = createCalendarSystem(settings.calendarSystem);
        this.locale = settings.locale;
        this.weekDow = settings.locale.week.dow;
        this.weekDoy = settings.locale.week.doy;

        if (settings.weekNumberCalculation === 'ISO') {
          this.weekDow = 1;
          this.weekDoy = 4;
        }

        if (typeof settings.firstDay === 'number') {
          this.weekDow = settings.firstDay;
        }

        if (typeof settings.weekNumberCalculation === 'function') {
          this.weekNumberFunc = settings.weekNumberCalculation;
        }

        this.weekLabel = settings.weekLabel != null ? settings.weekLabel : settings.locale.options.weekLabel;
        this.cmdFormatter = settings.cmdFormatter;
      } // Creating / Parsing


      DateEnv.prototype.createMarker = function (input) {
        var meta = this.createMarkerMeta(input);

        if (meta === null) {
          return null;
        }

        return meta.marker;
      };

      DateEnv.prototype.createNowMarker = function () {
        if (this.canComputeOffset) {
          return this.timestampToMarker(new Date().valueOf());
        } else {
          // if we can't compute the current date val for a timezone,
          // better to give the current local date vals than UTC
          return arrayToUtcDate(dateToLocalArray(new Date()));
        }
      };

      DateEnv.prototype.createMarkerMeta = function (input) {
        if (typeof input === 'string') {
          return this.parse(input);
        }

        var marker = null;

        if (typeof input === 'number') {
          marker = this.timestampToMarker(input);
        } else if (input instanceof Date) {
          input = input.valueOf();

          if (!isNaN(input)) {
            marker = this.timestampToMarker(input);
          }
        } else if (Array.isArray(input)) {
          marker = arrayToUtcDate(input);
        }

        if (marker === null || !isValidDate(marker)) {
          return null;
        }

        return {
          marker: marker,
          isTimeUnspecified: false,
          forcedTzo: null
        };
      };

      DateEnv.prototype.parse = function (s) {
        var parts = parse(s);

        if (parts === null) {
          return null;
        }

        var marker = parts.marker;
        var forcedTzo = null;

        if (parts.timeZoneOffset !== null) {
          if (this.canComputeOffset) {
            marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);
          } else {
            forcedTzo = parts.timeZoneOffset;
          }
        }

        return {
          marker: marker,
          isTimeUnspecified: parts.isTimeUnspecified,
          forcedTzo: forcedTzo
        };
      }; // Accessors


      DateEnv.prototype.getYear = function (marker) {
        return this.calendarSystem.getMarkerYear(marker);
      };

      DateEnv.prototype.getMonth = function (marker) {
        return this.calendarSystem.getMarkerMonth(marker);
      }; // Adding / Subtracting


      DateEnv.prototype.add = function (marker, dur) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] += dur.years;
        a[1] += dur.months;
        a[2] += dur.days;
        a[6] += dur.milliseconds;
        return this.calendarSystem.arrayToMarker(a);
      };

      DateEnv.prototype.subtract = function (marker, dur) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] -= dur.years;
        a[1] -= dur.months;
        a[2] -= dur.days;
        a[6] -= dur.milliseconds;
        return this.calendarSystem.arrayToMarker(a);
      };

      DateEnv.prototype.addYears = function (marker, n) {
        var a = this.calendarSystem.markerToArray(marker);
        a[0] += n;
        return this.calendarSystem.arrayToMarker(a);
      };

      DateEnv.prototype.addMonths = function (marker, n) {
        var a = this.calendarSystem.markerToArray(marker);
        a[1] += n;
        return this.calendarSystem.arrayToMarker(a);
      }; // Diffing Whole Units


      DateEnv.prototype.diffWholeYears = function (m0, m1) {
        var calendarSystem = this.calendarSystem;

        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
          return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
        }

        return null;
      };

      DateEnv.prototype.diffWholeMonths = function (m0, m1) {
        var calendarSystem = this.calendarSystem;

        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
          return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
        }

        return null;
      }; // Range / Duration


      DateEnv.prototype.greatestWholeUnit = function (m0, m1) {
        var n = this.diffWholeYears(m0, m1);

        if (n !== null) {
          return {
            unit: 'year',
            value: n
          };
        }

        n = this.diffWholeMonths(m0, m1);

        if (n !== null) {
          return {
            unit: 'month',
            value: n
          };
        }

        n = diffWholeWeeks(m0, m1);

        if (n !== null) {
          return {
            unit: 'week',
            value: n
          };
        }

        n = diffWholeDays(m0, m1);

        if (n !== null) {
          return {
            unit: 'day',
            value: n
          };
        }

        n = diffHours(m0, m1);

        if (isInt(n)) {
          return {
            unit: 'hour',
            value: n
          };
        }

        n = diffMinutes(m0, m1);

        if (isInt(n)) {
          return {
            unit: 'minute',
            value: n
          };
        }

        n = diffSeconds(m0, m1);

        if (isInt(n)) {
          return {
            unit: 'second',
            value: n
          };
        }

        return {
          unit: 'millisecond',
          value: m1.valueOf() - m0.valueOf()
        };
      };

      DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {
        // TODO: can use greatestWholeUnit
        var diff;

        if (d.years) {
          diff = this.diffWholeYears(m0, m1);

          if (diff !== null) {
            return diff / asRoughYears(d);
          }
        }

        if (d.months) {
          diff = this.diffWholeMonths(m0, m1);

          if (diff !== null) {
            return diff / asRoughMonths(d);
          }
        }

        if (d.days) {
          diff = diffWholeDays(m0, m1);

          if (diff !== null) {
            return diff / asRoughDays(d);
          }
        }

        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);
      }; // Start-Of


      DateEnv.prototype.startOf = function (m, unit) {
        if (unit === 'year') {
          return this.startOfYear(m);
        } else if (unit === 'month') {
          return this.startOfMonth(m);
        } else if (unit === 'week') {
          return this.startOfWeek(m);
        } else if (unit === 'day') {
          return startOfDay(m);
        } else if (unit === 'hour') {
          return startOfHour(m);
        } else if (unit === 'minute') {
          return startOfMinute(m);
        } else if (unit === 'second') {
          return startOfSecond(m);
        }
      };

      DateEnv.prototype.startOfYear = function (m) {
        return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);
      };

      DateEnv.prototype.startOfMonth = function (m) {
        return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);
      };

      DateEnv.prototype.startOfWeek = function (m) {
        return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);
      }; // Week Number


      DateEnv.prototype.computeWeekNumber = function (marker) {
        if (this.weekNumberFunc) {
          return this.weekNumberFunc(this.toDate(marker));
        } else {
          return weekOfYear(marker, this.weekDow, this.weekDoy);
        }
      }; // TODO: choke on timeZoneName: long


      DateEnv.prototype.format = function (marker, formatter, dateOptions) {
        if (dateOptions === void 0) {
          dateOptions = {};
        }

        return formatter.format({
          marker: marker,
          timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
        }, this);
      };

      DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {
        if (dateOptions === void 0) {
          dateOptions = {};
        }

        if (dateOptions.isEndExclusive) {
          end = addMs(end, -1);
        }

        return formatter.formatRange({
          marker: start,
          timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
        }, {
          marker: end,
          timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
        }, this);
      };

      DateEnv.prototype.formatIso = function (marker, extraOptions) {
        if (extraOptions === void 0) {
          extraOptions = {};
        }

        var timeZoneOffset = null;

        if (!extraOptions.omitTimeZoneOffset) {
          if (extraOptions.forcedTzo != null) {
            timeZoneOffset = extraOptions.forcedTzo;
          } else {
            timeZoneOffset = this.offsetForMarker(marker);
          }
        }

        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
      }; // TimeZone


      DateEnv.prototype.timestampToMarker = function (ms) {
        if (this.timeZone === 'local') {
          return arrayToUtcDate(dateToLocalArray(new Date(ms)));
        } else if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {
          return new Date(ms);
        } else {
          return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
        }
      };

      DateEnv.prototype.offsetForMarker = function (m) {
        if (this.timeZone === 'local') {
          return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert "inverse" offset to "normal" offset
        } else if (this.timeZone === 'UTC') {
          return 0;
        } else if (this.namedTimeZoneImpl) {
          return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));
        }

        return null;
      }; // Conversion


      DateEnv.prototype.toDate = function (m, forcedTzo) {
        if (this.timeZone === 'local') {
          return arrayToLocalDate(dateToUtcArray(m));
        } else if (this.timeZone === 'UTC') {
          return new Date(m.valueOf()); // make sure it's a copy
        } else if (!this.namedTimeZoneImpl) {
          return new Date(m.valueOf() - (forcedTzo || 0));
        } else {
          return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60 // convert minutes -> ms
          );
        }
      };

      return DateEnv;
    }();

    var SIMPLE_SOURCE_PROPS = {
      id: String,
      allDayDefault: Boolean,
      eventDataTransform: Function,
      success: Function,
      failure: Function
    };
    var uid$2 = 0;

    function doesSourceNeedRange(eventSource, calendar) {
      var defs = calendar.pluginSystem.hooks.eventSourceDefs;
      return !defs[eventSource.sourceDefId].ignoreRange;
    }

    function parseEventSource(raw, calendar) {
      var defs = calendar.pluginSystem.hooks.eventSourceDefs;

      for (var i = defs.length - 1; i >= 0; i--) {
        // later-added plugins take precedence
        var def = defs[i];
        var meta = def.parseMeta(raw);

        if (meta) {
          var res = parseEventSourceProps(typeof raw === 'object' ? raw : {}, meta, i, calendar);
          res._raw = raw;
          return res;
        }
      }

      return null;
    }

    function parseEventSourceProps(raw, meta, sourceDefId, calendar) {
      var leftovers0 = {};
      var props = refineProps(raw, SIMPLE_SOURCE_PROPS, {}, leftovers0);
      var leftovers1 = {};
      var ui = processUnscopedUiProps(leftovers0, calendar, leftovers1);
      props.isFetching = false;
      props.latestFetchId = '';
      props.fetchRange = null;
      props.publicId = String(raw.id || '');
      props.sourceId = String(uid$2++);
      props.sourceDefId = sourceDefId;
      props.meta = meta;
      props.ui = ui;
      props.extendedProps = leftovers1;
      return props;
    }

    function reduceEventSources(eventSources, action, dateProfile, calendar) {
      switch (action.type) {
        case 'ADD_EVENT_SOURCES':
          // already parsed
          return addSources(eventSources, action.sources, dateProfile ? dateProfile.activeRange : null, calendar);

        case 'REMOVE_EVENT_SOURCE':
          return removeSource(eventSources, action.sourceId);

        case 'PREV': // TODO: how do we track all actions that affect dateProfile :(

        case 'NEXT':
        case 'SET_DATE':
        case 'SET_VIEW_TYPE':
          if (dateProfile) {
            return fetchDirtySources(eventSources, dateProfile.activeRange, calendar);
          } else {
            return eventSources;
          }

        case 'FETCH_EVENT_SOURCES':
        case 'CHANGE_TIMEZONE':
          return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, calendar), dateProfile ? dateProfile.activeRange : null, calendar);

        case 'RECEIVE_EVENTS':
        case 'RECEIVE_EVENT_ERROR':
          return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);

        case 'REMOVE_ALL_EVENT_SOURCES':
          return {};

        default:
          return eventSources;
      }
    }

    var uid$3 = 0;

    function addSources(eventSourceHash, sources, fetchRange, calendar) {
      var hash = {};

      for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
        var source = sources_1[_i];
        hash[source.sourceId] = source;
      }

      if (fetchRange) {
        hash = fetchDirtySources(hash, fetchRange, calendar);
      }

      return _assign({}, eventSourceHash, hash);
    }

    function removeSource(eventSourceHash, sourceId) {
      return filterHash(eventSourceHash, function (eventSource) {
        return eventSource.sourceId !== sourceId;
      });
    }

    function fetchDirtySources(sourceHash, fetchRange, calendar) {
      return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {
        return isSourceDirty(eventSource, fetchRange, calendar);
      }), fetchRange, calendar);
    }

    function isSourceDirty(eventSource, fetchRange, calendar) {
      if (!doesSourceNeedRange(eventSource, calendar)) {
        return !eventSource.latestFetchId;
      } else {
        return !calendar.opt('lazyFetching') || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
        fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
      }
    }

    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, calendar) {
      var nextSources = {};

      for (var sourceId in prevSources) {
        var source = prevSources[sourceId];

        if (sourceIdHash[sourceId]) {
          nextSources[sourceId] = fetchSource(source, fetchRange, calendar);
        } else {
          nextSources[sourceId] = source;
        }
      }

      return nextSources;
    }

    function fetchSource(eventSource, fetchRange, calendar) {
      var sourceDef = calendar.pluginSystem.hooks.eventSourceDefs[eventSource.sourceDefId];
      var fetchId = String(uid$3++);
      sourceDef.fetch({
        eventSource: eventSource,
        calendar: calendar,
        range: fetchRange
      }, function (res) {
        var rawEvents = res.rawEvents;
        var calSuccess = calendar.opt('eventSourceSuccess');
        var calSuccessRes;
        var sourceSuccessRes;

        if (eventSource.success) {
          sourceSuccessRes = eventSource.success(rawEvents, res.xhr);
        }

        if (calSuccess) {
          calSuccessRes = calSuccess(rawEvents, res.xhr);
        }

        rawEvents = sourceSuccessRes || calSuccessRes || rawEvents;
        calendar.dispatch({
          type: 'RECEIVE_EVENTS',
          sourceId: eventSource.sourceId,
          fetchId: fetchId,
          fetchRange: fetchRange,
          rawEvents: rawEvents
        });
      }, function (error) {
        var callFailure = calendar.opt('eventSourceFailure');
        console.warn(error.message, error);

        if (eventSource.failure) {
          eventSource.failure(error);
        }

        if (callFailure) {
          callFailure(error);
        }

        calendar.dispatch({
          type: 'RECEIVE_EVENT_ERROR',
          sourceId: eventSource.sourceId,
          fetchId: fetchId,
          fetchRange: fetchRange,
          error: error
        });
      });
      return _assign({}, eventSource, {
        isFetching: true,
        latestFetchId: fetchId
      });
    }

    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
      var _a;

      var eventSource = sourceHash[sourceId];

      if (eventSource && // not already removed
      fetchId === eventSource.latestFetchId) {
        return _assign({}, sourceHash, (_a = {}, _a[sourceId] = _assign({}, eventSource, {
          isFetching: false,
          fetchRange: fetchRange // also serves as a marker that at least one fetch has completed

        }), _a));
      }

      return sourceHash;
    }

    function excludeStaticSources(eventSources, calendar) {
      return filterHash(eventSources, function (eventSource) {
        return doesSourceNeedRange(eventSource, calendar);
      });
    }

    var DateProfileGenerator =
    /** @class */
    function () {
      function DateProfileGenerator(viewSpec, calendar) {
        this.viewSpec = viewSpec;
        this.options = viewSpec.options;
        this.dateEnv = calendar.dateEnv;
        this.calendar = calendar;
        this.initHiddenDays();
      }
      /* Date Range Computation
      ------------------------------------------------------------------------------------------------------------------*/
      // Builds a structure with info about what the dates/ranges will be for the "prev" view.


      DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate) {
        var dateEnv = this.dateEnv;
        var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
        currentDateProfile.dateIncrement);
        return this.build(prevDate, -1);
      }; // Builds a structure with info about what the dates/ranges will be for the "next" view.


      DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate) {
        var dateEnv = this.dateEnv;
        var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month
        currentDateProfile.dateIncrement);
        return this.build(nextDate, 1);
      }; // Builds a structure holding dates/ranges for rendering around the given date.
      // Optional direction param indicates whether the date is being incremented/decremented
      // from its previous value. decremented = -1, incremented = 1 (default).


      DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {
        if (forceToValid === void 0) {
          forceToValid = false;
        }

        var validRange;
        var minTime = null;
        var maxTime = null;
        var currentInfo;
        var isRangeAllDay;
        var renderRange;
        var activeRange;
        var isValid;
        validRange = this.buildValidRange();
        validRange = this.trimHiddenDays(validRange);

        if (forceToValid) {
          currentDate = constrainMarkerToRange(currentDate, validRange);
        }

        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
        renderRange = this.trimHiddenDays(renderRange);
        activeRange = renderRange;

        if (!this.options.showNonCurrentDates) {
          activeRange = intersectRanges(activeRange, currentInfo.range);
        }

        minTime = createDuration(this.options.minTime);
        maxTime = createDuration(this.options.maxTime);
        activeRange = this.adjustActiveRange(activeRange, minTime, maxTime);
        activeRange = intersectRanges(activeRange, validRange); // might return null
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.

        isValid = rangesIntersect(currentInfo.range, validRange);
        return {
          // constraint for where prev/next operations can go and where events can be dragged/resized to.
          // an object with optional start and end properties.
          validRange: validRange,
          // range the view is formally responsible for.
          // for example, a month view might have 1st-31st, excluding padded dates
          currentRange: currentInfo.range,
          // name of largest unit being displayed, like "month" or "week"
          currentRangeUnit: currentInfo.unit,
          isRangeAllDay: isRangeAllDay,
          // dates that display events and accept drag-n-drop
          // will be `null` if no dates accept events
          activeRange: activeRange,
          // date range with a rendered skeleton
          // includes not-active days that need some sort of DOM
          renderRange: renderRange,
          // Duration object that denotes the first visible time of any given day
          minTime: minTime,
          // Duration object that denotes the exclusive visible end time of any given day
          maxTime: maxTime,
          isValid: isValid,
          // how far the current date will move for a prev/next operation
          dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^

        };
      }; // Builds an object with optional start/end properties.
      // Indicates the minimum/maximum dates to display.
      // not responsible for trimming hidden days.


      DateProfileGenerator.prototype.buildValidRange = function () {
        return this.getRangeOption('validRange', this.calendar.getNow()) || {
          start: null,
          end: null
        }; // completely open-ended
      }; // Builds a structure with info about the "current" range, the range that is
      // highlighted as being the current month for example.
      // See build() for a description of `direction`.
      // Guaranteed to have `range` and `unit` properties. `duration` is optional.


      DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
        var _a = this,
            viewSpec = _a.viewSpec,
            dateEnv = _a.dateEnv;

        var duration = null;
        var unit = null;
        var range = null;
        var dayCount;

        if (viewSpec.duration) {
          duration = viewSpec.duration;
          unit = viewSpec.durationUnit;
          range = this.buildRangeFromDuration(date, direction, duration, unit);
        } else if (dayCount = this.options.dayCount) {
          unit = 'day';
          range = this.buildRangeFromDayCount(date, direction, dayCount);
        } else if (range = this.buildCustomVisibleRange(date)) {
          unit = dateEnv.greatestWholeUnit(range.start, range.end).unit;
        } else {
          duration = this.getFallbackDuration();
          unit = greatestDurationDenominator(duration).unit;
          range = this.buildRangeFromDuration(date, direction, duration, unit);
        }

        return {
          duration: duration,
          unit: unit,
          range: range
        };
      };

      DateProfileGenerator.prototype.getFallbackDuration = function () {
        return createDuration({
          day: 1
        });
      }; // Returns a new activeRange to have time values (un-ambiguate)
      // minTime or maxTime causes the range to expand.


      DateProfileGenerator.prototype.adjustActiveRange = function (range, minTime, maxTime) {
        var dateEnv = this.dateEnv;
        var start = range.start;
        var end = range.end;

        if (this.viewSpec["class"].prototype.usesMinMaxTime) {
          // expand active range if minTime is negative (why not when positive?)
          if (asRoughDays(minTime) < 0) {
            start = startOfDay(start); // necessary?

            start = dateEnv.add(start, minTime);
          } // expand active range if maxTime is beyond one day (why not when positive?)


          if (asRoughDays(maxTime) > 1) {
            end = startOfDay(end); // necessary?

            end = addDays(end, -1);
            end = dateEnv.add(end, maxTime);
          }
        }

        return {
          start: start,
          end: end
        };
      }; // Builds the "current" range when it is specified as an explicit duration.
      // `unit` is the already-computed greatestDurationDenominator unit of duration.


      DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
        var dateEnv = this.dateEnv;
        var alignment = this.options.dateAlignment;
        var dateIncrementInput;
        var dateIncrementDuration;
        var start;
        var end;
        var res; // compute what the alignment should be

        if (!alignment) {
          dateIncrementInput = this.options.dateIncrement;

          if (dateIncrementInput) {
            dateIncrementDuration = createDuration(dateIncrementInput); // use the smaller of the two units

            if (asRoughMs(dateIncrementDuration) < asRoughMs(duration)) {
              alignment = greatestDurationDenominator(dateIncrementDuration, !getWeeksFromInput(dateIncrementInput)).unit;
            } else {
              alignment = unit;
            }
          } else {
            alignment = unit;
          }
        } // if the view displays a single day or smaller


        if (asRoughDays(duration) <= 1) {
          if (this.isHiddenDay(start)) {
            start = this.skipHiddenDays(start, direction);
            start = startOfDay(start);
          }
        }

        function computeRes() {
          start = dateEnv.startOf(date, alignment);
          end = dateEnv.add(start, duration);
          res = {
            start: start,
            end: end
          };
        }

        computeRes(); // if range is completely enveloped by hidden days, go past the hidden days

        if (!this.trimHiddenDays(res)) {
          date = this.skipHiddenDays(date, direction);
          computeRes();
        }

        return res;
      }; // Builds the "current" range when a dayCount is specified.


      DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
        var dateEnv = this.dateEnv;
        var customAlignment = this.options.dateAlignment;
        var runningCount = 0;
        var start = date;
        var end;

        if (customAlignment) {
          start = dateEnv.startOf(start, customAlignment);
        }

        start = startOfDay(start);
        start = this.skipHiddenDays(start, direction);
        end = start;

        do {
          end = addDays(end, 1);

          if (!this.isHiddenDay(end)) {
            runningCount++;
          }
        } while (runningCount < dayCount);

        return {
          start: start,
          end: end
        };
      }; // Builds a normalized range object for the "visible" range,
      // which is a way to define the currentRange and activeRange at the same time.


      DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
        var dateEnv = this.dateEnv;
        var visibleRange = this.getRangeOption('visibleRange', dateEnv.toDate(date));

        if (visibleRange && (visibleRange.start == null || visibleRange.end == null)) {
          return null;
        }

        return visibleRange;
      }; // Computes the range that will represent the element/cells for *rendering*,
      // but which may have voided days/times.
      // not responsible for trimming hidden days.


      DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
        return currentRange;
      }; // Compute the duration value that should be added/substracted to the current date
      // when a prev/next operation happens.


      DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
        var dateIncrementInput = this.options.dateIncrement;
        var customAlignment;

        if (dateIncrementInput) {
          return createDuration(dateIncrementInput);
        } else if (customAlignment = this.options.dateAlignment) {
          return createDuration(1, customAlignment);
        } else if (fallback) {
          return fallback;
        } else {
          return createDuration({
            days: 1
          });
        }
      }; // Arguments after name will be forwarded to a hypothetical function value
      // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
      // Always clone your objects if you fear mutation.


      DateProfileGenerator.prototype.getRangeOption = function (name) {
        var otherArgs = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          otherArgs[_i - 1] = arguments[_i];
        }

        var val = this.options[name];

        if (typeof val === 'function') {
          val = val.apply(null, otherArgs);
        }

        if (val) {
          val = parseRange(val, this.dateEnv);
        }

        if (val) {
          val = computeVisibleDayRange(val);
        }

        return val;
      };
      /* Hidden Days
      ------------------------------------------------------------------------------------------------------------------*/
      // Initializes internal variables related to calculating hidden days-of-week


      DateProfileGenerator.prototype.initHiddenDays = function () {
        var hiddenDays = this.options.hiddenDays || []; // array of day-of-week indices that are hidden

        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)

        var dayCnt = 0;
        var i;

        if (this.options.weekends === false) {
          hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        }

        for (i = 0; i < 7; i++) {
          if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {
            dayCnt++;
          }
        }

        if (!dayCnt) {
          throw new Error('invalid hiddenDays'); // all days were hidden? bad.
        }

        this.isHiddenDayHash = isHiddenDayHash;
      }; // Remove days from the beginning and end of the range that are computed as hidden.
      // If the whole range is trimmed off, returns null


      DateProfileGenerator.prototype.trimHiddenDays = function (range) {
        var start = range.start;
        var end = range.end;

        if (start) {
          start = this.skipHiddenDays(start);
        }

        if (end) {
          end = this.skipHiddenDays(end, -1, true);
        }

        if (start == null || end == null || start < end) {
          return {
            start: start,
            end: end
          };
        }

        return null;
      }; // Is the current day hidden?
      // `day` is a day-of-week index (0-6), or a Date (used for UTC)


      DateProfileGenerator.prototype.isHiddenDay = function (day) {
        if (day instanceof Date) {
          day = day.getUTCDay();
        }

        return this.isHiddenDayHash[day];
      }; // Incrementing the current day until it is no longer a hidden day, returning a copy.
      // DOES NOT CONSIDER validRange!
      // If the initial value of `date` is not a hidden day, don't do anything.
      // Pass `isExclusive` as `true` if you are dealing with an end date.
      // `inc` defaults to `1` (increment one day forward each time)


      DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {
        if (inc === void 0) {
          inc = 1;
        }

        if (isExclusive === void 0) {
          isExclusive = false;
        }

        while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
          date = addDays(date, inc);
        }

        return date;
      };

      return DateProfileGenerator;
    }(); // TODO: find a way to avoid comparing DateProfiles. it's tedious


    function isDateProfilesEqual(p0, p1) {
      return rangesEqual(p0.validRange, p1.validRange) && rangesEqual(p0.activeRange, p1.activeRange) && rangesEqual(p0.renderRange, p1.renderRange) && durationsEqual(p0.minTime, p1.minTime) && durationsEqual(p0.maxTime, p1.maxTime);
      /*
      TODO: compare more?
        currentRange: DateRange
        currentRangeUnit: string
        isRangeAllDay: boolean
        isValid: boolean
        dateIncrement: Duration
      */
    }

    function reduce(state, action, calendar) {
      var viewType = reduceViewType(state.viewType, action);
      var dateProfile = reduceDateProfile(state.dateProfile, action, state.currentDate, viewType, calendar);
      var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendar);

      var nextState = _assign({}, state, {
        viewType: viewType,
        dateProfile: dateProfile,
        currentDate: reduceCurrentDate(state.currentDate, action, dateProfile),
        eventSources: eventSources,
        eventStore: reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendar),
        dateSelection: reduceDateSelection(state.dateSelection, action, calendar),
        eventSelection: reduceSelectedEvent(state.eventSelection, action),
        eventDrag: reduceEventDrag(state.eventDrag, action, eventSources, calendar),
        eventResize: reduceEventResize(state.eventResize, action, eventSources, calendar),
        eventSourceLoadingLevel: computeLoadingLevel(eventSources),
        loadingLevel: computeLoadingLevel(eventSources)
      });

      for (var _i = 0, _a = calendar.pluginSystem.hooks.reducers; _i < _a.length; _i++) {
        var reducerFunc = _a[_i];
        nextState = reducerFunc(nextState, action, calendar);
      } // console.log(action.type, nextState)


      return nextState;
    }

    function reduceViewType(currentViewType, action) {
      switch (action.type) {
        case 'SET_VIEW_TYPE':
          return action.viewType;

        default:
          return currentViewType;
      }
    }

    function reduceDateProfile(currentDateProfile, action, currentDate, viewType, calendar) {
      var newDateProfile;

      switch (action.type) {
        case 'PREV':
          newDateProfile = calendar.dateProfileGenerators[viewType].buildPrev(currentDateProfile, currentDate);
          break;

        case 'NEXT':
          newDateProfile = calendar.dateProfileGenerators[viewType].buildNext(currentDateProfile, currentDate);
          break;

        case 'SET_DATE':
          if (!currentDateProfile.activeRange || !rangeContainsMarker(currentDateProfile.currentRange, action.dateMarker)) {
            newDateProfile = calendar.dateProfileGenerators[viewType].build(action.dateMarker, undefined, true // forceToValid
            );
          }

          break;

        case 'SET_VIEW_TYPE':
          var generator = calendar.dateProfileGenerators[viewType];

          if (!generator) {
            throw new Error(viewType ? 'The FullCalendar view "' + viewType + '" does not exist. Make sure your plugins are loaded correctly.' : 'No available FullCalendar view plugins.');
          }

          newDateProfile = generator.build(action.dateMarker || currentDate, undefined, true // forceToValid
          );
          break;
      }

      if (newDateProfile && newDateProfile.isValid && !(currentDateProfile && isDateProfilesEqual(currentDateProfile, newDateProfile))) {
        return newDateProfile;
      } else {
        return currentDateProfile;
      }
    }

    function reduceCurrentDate(currentDate, action, dateProfile) {
      switch (action.type) {
        case 'PREV':
        case 'NEXT':
          if (!rangeContainsMarker(dateProfile.currentRange, currentDate)) {
            return dateProfile.currentRange.start;
          } else {
            return currentDate;
          }

        case 'SET_DATE':
        case 'SET_VIEW_TYPE':
          var newDate = action.dateMarker || currentDate;

          if (dateProfile.activeRange && !rangeContainsMarker(dateProfile.activeRange, newDate)) {
            return dateProfile.currentRange.start;
          } else {
            return newDate;
          }

        default:
          return currentDate;
      }
    }

    function reduceDateSelection(currentSelection, action, calendar) {
      switch (action.type) {
        case 'SELECT_DATES':
          return action.selection;

        case 'UNSELECT_DATES':
          return null;

        default:
          return currentSelection;
      }
    }

    function reduceSelectedEvent(currentInstanceId, action) {
      switch (action.type) {
        case 'SELECT_EVENT':
          return action.eventInstanceId;

        case 'UNSELECT_EVENT':
          return '';

        default:
          return currentInstanceId;
      }
    }

    function reduceEventDrag(currentDrag, action, sources, calendar) {
      switch (action.type) {
        case 'SET_EVENT_DRAG':
          var newDrag = action.state;
          return {
            affectedEvents: newDrag.affectedEvents,
            mutatedEvents: newDrag.mutatedEvents,
            isEvent: newDrag.isEvent,
            origSeg: newDrag.origSeg
          };

        case 'UNSET_EVENT_DRAG':
          return null;

        default:
          return currentDrag;
      }
    }

    function reduceEventResize(currentResize, action, sources, calendar) {
      switch (action.type) {
        case 'SET_EVENT_RESIZE':
          var newResize = action.state;
          return {
            affectedEvents: newResize.affectedEvents,
            mutatedEvents: newResize.mutatedEvents,
            isEvent: newResize.isEvent,
            origSeg: newResize.origSeg
          };

        case 'UNSET_EVENT_RESIZE':
          return null;

        default:
          return currentResize;
      }
    }

    function computeLoadingLevel(eventSources) {
      var cnt = 0;

      for (var sourceId in eventSources) {
        if (eventSources[sourceId].isFetching) {
          cnt++;
        }
      }

      return cnt;
    }

    var STANDARD_PROPS = {
      start: null,
      end: null,
      allDay: Boolean
    };

    function parseDateSpan(raw, dateEnv, defaultDuration) {
      var span = parseOpenDateSpan(raw, dateEnv);
      var range = span.range;

      if (!range.start) {
        return null;
      }

      if (!range.end) {
        if (defaultDuration == null) {
          return null;
        } else {
          range.end = dateEnv.add(range.start, defaultDuration);
        }
      }

      return span;
    }
    /*
    TODO: somehow combine with parseRange?
    Will return null if the start/end props were present but parsed invalidly.
    */


    function parseOpenDateSpan(raw, dateEnv) {
      var leftovers = {};
      var standardProps = refineProps(raw, STANDARD_PROPS, {}, leftovers);
      var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
      var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
      var allDay = standardProps.allDay;

      if (allDay == null) {
        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
      } // use this leftover object as the selection object


      leftovers.range = {
        start: startMeta ? startMeta.marker : null,
        end: endMeta ? endMeta.marker : null
      };
      leftovers.allDay = allDay;
      return leftovers;
    }

    function isDateSpansEqual(span0, span1) {
      return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
    } // the NON-DATE-RELATED props


    function isSpanPropsEqual(span0, span1) {
      for (var propName in span1) {
        if (propName !== 'range' && propName !== 'allDay') {
          if (span0[propName] !== span1[propName]) {
            return false;
          }
        }
      } // are there any props that span0 has that span1 DOESN'T have?
      // both have range/allDay, so no need to special-case.


      for (var propName in span0) {
        if (!(propName in span1)) {
          return false;
        }
      }

      return true;
    }

    function buildDateSpanApi(span, dateEnv) {
      return {
        start: dateEnv.toDate(span.range.start),
        end: dateEnv.toDate(span.range.end),
        startStr: dateEnv.formatIso(span.range.start, {
          omitTime: span.allDay
        }),
        endStr: dateEnv.formatIso(span.range.end, {
          omitTime: span.allDay
        }),
        allDay: span.allDay
      };
    }

    function buildDatePointApi(span, dateEnv) {
      return {
        date: dateEnv.toDate(span.range.start),
        dateStr: dateEnv.formatIso(span.range.start, {
          omitTime: span.allDay
        }),
        allDay: span.allDay
      };
    }

    function fabricateEventRange(dateSpan, eventUiBases, calendar) {
      var def = parseEventDef({
        editable: false
      }, '', // sourceId
      dateSpan.allDay, true, // hasEnd
      calendar);
      return {
        def: def,
        ui: compileEventUi(def, eventUiBases),
        instance: createEventInstance(def.defId, dateSpan.range),
        range: dateSpan.range,
        isStart: true,
        isEnd: true
      };
    }

    function compileViewDefs(defaultConfigs, overrideConfigs) {
      var hash = {};
      var viewType;

      for (viewType in defaultConfigs) {
        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      }

      for (viewType in overrideConfigs) {
        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
      }

      return hash;
    }

    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
      if (hash[viewType]) {
        return hash[viewType];
      }

      var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);

      if (viewDef) {
        hash[viewType] = viewDef;
      }

      return viewDef;
    }

    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
      var defaultConfig = defaultConfigs[viewType];
      var overrideConfig = overrideConfigs[viewType];

      var queryProp = function queryProp(name) {
        return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
      };

      var theClass = queryProp('class');
      var superType = queryProp('superType');

      if (!superType && theClass) {
        superType = findViewNameBySubclass(theClass, overrideConfigs) || findViewNameBySubclass(theClass, defaultConfigs);
      }

      var superDef = null;

      if (superType) {
        if (superType === viewType) {
          throw new Error('Can\'t have a custom view type that references itself');
        }

        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
      }

      if (!theClass && superDef) {
        theClass = superDef["class"];
      }

      if (!theClass) {
        return null; // don't throw a warning, might be settings for a single-unit view
      }

      return {
        type: viewType,
        "class": theClass,
        defaults: _assign({}, superDef ? superDef.defaults : {}, defaultConfig ? defaultConfig.options : {}),
        overrides: _assign({}, superDef ? superDef.overrides : {}, overrideConfig ? overrideConfig.options : {})
      };
    }

    function findViewNameBySubclass(viewSubclass, configs) {
      var superProto = Object.getPrototypeOf(viewSubclass.prototype);

      for (var viewType in configs) {
        var parsed = configs[viewType]; // need DIRECT subclass, so instanceof won't do it

        if (parsed["class"] && parsed["class"].prototype === superProto) {
          return viewType;
        }
      }

      return '';
    }

    function parseViewConfigs(inputs) {
      return mapHash(inputs, parseViewConfig);
    }

    var VIEW_DEF_PROPS = {
      type: String,
      "class": null
    };

    function parseViewConfig(input) {
      if (typeof input === 'function') {
        input = {
          "class": input
        };
      }

      var options = {};
      var props = refineProps(input, VIEW_DEF_PROPS, {}, options);
      return {
        superType: props.type,
        "class": props["class"],
        options: options
      };
    }

    function buildViewSpecs(defaultInputs, optionsManager) {
      var defaultConfigs = parseViewConfigs(defaultInputs);
      var overrideConfigs = parseViewConfigs(optionsManager.overrides.views);
      var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
      return mapHash(viewDefs, function (viewDef) {
        return buildViewSpec(viewDef, overrideConfigs, optionsManager);
      });
    }

    function buildViewSpec(viewDef, overrideConfigs, optionsManager) {
      var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || optionsManager.dynamicOverrides.duration || optionsManager.overrides.duration;
      var duration = null;
      var durationUnit = '';
      var singleUnit = '';
      var singleUnitOverrides = {};

      if (durationInput) {
        duration = createDuration(durationInput);

        if (duration) {
          // valid?
          var denom = greatestDurationDenominator(duration, !getWeeksFromInput(durationInput));
          durationUnit = denom.unit;

          if (denom.value === 1) {
            singleUnit = durationUnit;
            singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].options : {};
          }
        }
      }

      var queryButtonText = function queryButtonText(options) {
        var buttonTextMap = options.buttonText || {};
        var buttonTextKey = viewDef.defaults.buttonTextKey;

        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
          return buttonTextMap[buttonTextKey];
        }

        if (buttonTextMap[viewDef.type] != null) {
          return buttonTextMap[viewDef.type];
        }

        if (buttonTextMap[singleUnit] != null) {
          return buttonTextMap[singleUnit];
        }
      };

      return {
        type: viewDef.type,
        "class": viewDef["class"],
        duration: duration,
        durationUnit: durationUnit,
        singleUnit: singleUnit,
        options: _assign({}, globalDefaults, viewDef.defaults, optionsManager.dirDefaults, optionsManager.localeDefaults, optionsManager.overrides, singleUnitOverrides, viewDef.overrides, optionsManager.dynamicOverrides),
        buttonTextOverride: queryButtonText(optionsManager.dynamicOverrides) || queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
        viewDef.overrides.buttonText,
        buttonTextDefault: queryButtonText(optionsManager.localeDefaults) || queryButtonText(optionsManager.dirDefaults) || viewDef.defaults.buttonText || queryButtonText(globalDefaults) || viewDef.type // fall back to given view name

      };
    }

    var Toolbar =
    /** @class */
    function (_super) {
      __extends(Toolbar, _super);

      function Toolbar(extraClassName) {
        var _this = _super.call(this) || this;

        _this._renderLayout = memoizeRendering(_this.renderLayout, _this.unrenderLayout);
        _this._updateTitle = memoizeRendering(_this.updateTitle, null, [_this._renderLayout]);
        _this._updateActiveButton = memoizeRendering(_this.updateActiveButton, null, [_this._renderLayout]);
        _this._updateToday = memoizeRendering(_this.updateToday, null, [_this._renderLayout]);
        _this._updatePrev = memoizeRendering(_this.updatePrev, null, [_this._renderLayout]);
        _this._updateNext = memoizeRendering(_this.updateNext, null, [_this._renderLayout]);
        _this.el = createElement('div', {
          className: 'fc-toolbar ' + extraClassName
        });
        return _this;
      }

      Toolbar.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this._renderLayout.unrender(); // should unrender everything else


        removeElement(this.el);
      };

      Toolbar.prototype.render = function (props) {
        this._renderLayout(props.layout);

        this._updateTitle(props.title);

        this._updateActiveButton(props.activeButton);

        this._updateToday(props.isTodayEnabled);

        this._updatePrev(props.isPrevEnabled);

        this._updateNext(props.isNextEnabled);
      };

      Toolbar.prototype.renderLayout = function (layout) {
        var el = this.el;
        this.viewsWithButtons = [];
        appendToElement(el, this.renderSection('left', layout.left));
        appendToElement(el, this.renderSection('center', layout.center));
        appendToElement(el, this.renderSection('right', layout.right));
      };

      Toolbar.prototype.unrenderLayout = function () {
        this.el.innerHTML = '';
      };

      Toolbar.prototype.renderSection = function (position, buttonStr) {
        var _this = this;

        var _a = this.context,
            theme = _a.theme,
            calendar = _a.calendar;
        var optionsManager = calendar.optionsManager;
        var viewSpecs = calendar.viewSpecs;
        var sectionEl = createElement('div', {
          className: 'fc-' + position
        });
        var calendarCustomButtons = optionsManager.computed.customButtons || {};
        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
        var calendarButtonText = optionsManager.computed.buttonText || {};

        if (buttonStr) {
          buttonStr.split(' ').forEach(function (buttonGroupStr, i) {
            var groupChildren = [];
            var isOnlyButtons = true;
            var groupEl;
            buttonGroupStr.split(',').forEach(function (buttonName, j) {
              var customButtonProps;
              var viewSpec;
              var buttonClick;
              var buttonIcon; // only one of these will be set

              var buttonText; // "

              var buttonInnerHtml;
              var buttonClasses;
              var buttonEl;
              var buttonAriaAttr;

              if (buttonName === 'title') {
                groupChildren.push(htmlToElement('<h2>&nbsp;</h2>')); // we always want it to take up height

                isOnlyButtons = false;
              } else {
                if (customButtonProps = calendarCustomButtons[buttonName]) {
                  buttonClick = function buttonClick(ev) {
                    if (customButtonProps.click) {
                      customButtonProps.click.call(buttonEl, ev);
                    }
                  };

                  (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName)) || (buttonText = customButtonProps.text);
                } else if (viewSpec = viewSpecs[buttonName]) {
                  _this.viewsWithButtons.push(buttonName);

                  buttonClick = function buttonClick() {
                    calendar.changeView(buttonName);
                  };

                  (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName)) || (buttonText = viewSpec.buttonTextDefault);
                } else if (calendar[buttonName]) {
                  // a calendar method
                  buttonClick = function buttonClick() {
                    calendar[buttonName]();
                  };

                  (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName)) || (buttonText = calendarButtonText[buttonName]); //            ^ everything else is considered default
                }

                if (buttonClick) {
                  buttonClasses = ['fc-' + buttonName + '-button', theme.getClass('button')];

                  if (buttonText) {
                    buttonInnerHtml = htmlEscape(buttonText);
                    buttonAriaAttr = '';
                  } else if (buttonIcon) {
                    buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                    buttonAriaAttr = ' aria-label="' + buttonName + '"';
                  }

                  buttonEl = htmlToElement( // type="button" so that it doesn't submit a form
                  '<button type="button" class="' + buttonClasses.join(' ') + '"' + buttonAriaAttr + '>' + buttonInnerHtml + '</button>');
                  buttonEl.addEventListener('click', buttonClick);
                  groupChildren.push(buttonEl);
                }
              }
            });

            if (groupChildren.length > 1) {
              groupEl = document.createElement('div');
              var buttonGroupClassName = theme.getClass('buttonGroup');

              if (isOnlyButtons && buttonGroupClassName) {
                groupEl.classList.add(buttonGroupClassName);
              }

              appendToElement(groupEl, groupChildren);
              sectionEl.appendChild(groupEl);
            } else {
              appendToElement(sectionEl, groupChildren); // 1 or 0 children
            }
          });
        }

        return sectionEl;
      };

      Toolbar.prototype.updateToday = function (isTodayEnabled) {
        this.toggleButtonEnabled('today', isTodayEnabled);
      };

      Toolbar.prototype.updatePrev = function (isPrevEnabled) {
        this.toggleButtonEnabled('prev', isPrevEnabled);
      };

      Toolbar.prototype.updateNext = function (isNextEnabled) {
        this.toggleButtonEnabled('next', isNextEnabled);
      };

      Toolbar.prototype.updateTitle = function (text) {
        findElements(this.el, 'h2').forEach(function (titleEl) {
          titleEl.innerText = text;
        });
      };

      Toolbar.prototype.updateActiveButton = function (buttonName) {
        var theme = this.context.theme;
        var className = theme.getClass('buttonActive');
        findElements(this.el, 'button').forEach(function (buttonEl) {
          if (buttonName && buttonEl.classList.contains('fc-' + buttonName + '-button')) {
            buttonEl.classList.add(className);
          } else {
            buttonEl.classList.remove(className);
          }
        });
      };

      Toolbar.prototype.toggleButtonEnabled = function (buttonName, bool) {
        findElements(this.el, '.fc-' + buttonName + '-button').forEach(function (buttonEl) {
          buttonEl.disabled = !bool;
        });
      };

      return Toolbar;
    }(Component);

    var CalendarComponent =
    /** @class */
    function (_super) {
      __extends(CalendarComponent, _super);

      function CalendarComponent(el) {
        var _this = _super.call(this) || this;

        _this.elClassNames = [];
        _this.renderSkeleton = memoizeRendering(_this._renderSkeleton, _this._unrenderSkeleton);
        _this.renderToolbars = memoizeRendering(_this._renderToolbars, _this._unrenderToolbars, [_this.renderSkeleton]);
        _this.buildComponentContext = memoize(buildComponentContext);
        _this.buildViewPropTransformers = memoize(buildViewPropTransformers);
        _this.el = el;
        _this.computeTitle = memoize(computeTitle);
        _this.parseBusinessHours = memoize(function (input) {
          return parseBusinessHours(input, _this.context.calendar);
        });
        return _this;
      }

      CalendarComponent.prototype.render = function (props, context) {
        this.freezeHeight();
        var title = this.computeTitle(props.dateProfile, props.viewSpec.options);
        this.renderSkeleton(context);
        this.renderToolbars(props.viewSpec, props.dateProfile, props.currentDate, title);
        this.renderView(props, title);
        this.updateSize();
        this.thawHeight();
      };

      CalendarComponent.prototype.destroy = function () {
        if (this.header) {
          this.header.destroy();
        }

        if (this.footer) {
          this.footer.destroy();
        }

        this.renderSkeleton.unrender(); // will call destroyView

        _super.prototype.destroy.call(this);
      };

      CalendarComponent.prototype._renderSkeleton = function (context) {
        this.updateElClassNames(context);
        prependToElement(this.el, this.contentEl = createElement('div', {
          className: 'fc-view-container'
        }));
        var calendar = context.calendar;

        for (var _i = 0, _a = calendar.pluginSystem.hooks.viewContainerModifiers; _i < _a.length; _i++) {
          var modifyViewContainer = _a[_i];
          modifyViewContainer(this.contentEl, calendar);
        }
      };

      CalendarComponent.prototype._unrenderSkeleton = function () {
        // weird to have this here
        if (this.view) {
          this.savedScroll = this.view.queryScroll();
          this.view.destroy();
          this.view = null;
        }

        removeElement(this.contentEl);
        this.removeElClassNames();
      };

      CalendarComponent.prototype.removeElClassNames = function () {
        var classList = this.el.classList;

        for (var _i = 0, _a = this.elClassNames; _i < _a.length; _i++) {
          var className = _a[_i];
          classList.remove(className);
        }

        this.elClassNames = [];
      };

      CalendarComponent.prototype.updateElClassNames = function (context) {
        this.removeElClassNames();
        var theme = context.theme,
            options = context.options;
        this.elClassNames = ['fc', 'fc-' + options.dir, theme.getClass('widget')];
        var classList = this.el.classList;

        for (var _i = 0, _a = this.elClassNames; _i < _a.length; _i++) {
          var className = _a[_i];
          classList.add(className);
        }
      };

      CalendarComponent.prototype._renderToolbars = function (viewSpec, dateProfile, currentDate, title) {
        var _a = this,
            context = _a.context,
            header = _a.header,
            footer = _a.footer;

        var options = context.options,
            calendar = context.calendar;
        var headerLayout = options.header;
        var footerLayout = options.footer;
        var dateProfileGenerator = this.props.dateProfileGenerator;
        var now = calendar.getNow();
        var todayInfo = dateProfileGenerator.build(now);
        var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate);
        var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate);
        var toolbarProps = {
          title: title,
          activeButton: viewSpec.type,
          isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
          isPrevEnabled: prevInfo.isValid,
          isNextEnabled: nextInfo.isValid
        };

        if (headerLayout) {
          if (!header) {
            header = this.header = new Toolbar('fc-header-toolbar');
            prependToElement(this.el, header.el);
          }

          header.receiveProps(_assign({
            layout: headerLayout
          }, toolbarProps), context);
        } else if (header) {
          header.destroy();
          header = this.header = null;
        }

        if (footerLayout) {
          if (!footer) {
            footer = this.footer = new Toolbar('fc-footer-toolbar');
            appendToElement(this.el, footer.el);
          }

          footer.receiveProps(_assign({
            layout: footerLayout
          }, toolbarProps), context);
        } else if (footer) {
          footer.destroy();
          footer = this.footer = null;
        }
      };

      CalendarComponent.prototype._unrenderToolbars = function () {
        if (this.header) {
          this.header.destroy();
          this.header = null;
        }

        if (this.footer) {
          this.footer.destroy();
          this.footer = null;
        }
      };

      CalendarComponent.prototype.renderView = function (props, title) {
        var view = this.view;
        var _a = this.context,
            calendar = _a.calendar,
            options = _a.options;
        var viewSpec = props.viewSpec,
            dateProfileGenerator = props.dateProfileGenerator;

        if (!view || view.viewSpec !== viewSpec) {
          if (view) {
            view.destroy();
          }

          view = this.view = new viewSpec['class'](viewSpec, this.contentEl);

          if (this.savedScroll) {
            view.addScroll(this.savedScroll, true);
            this.savedScroll = null;
          }
        }

        view.title = title; // for the API

        var viewProps = {
          dateProfileGenerator: dateProfileGenerator,
          dateProfile: props.dateProfile,
          businessHours: this.parseBusinessHours(viewSpec.options.businessHours),
          eventStore: props.eventStore,
          eventUiBases: props.eventUiBases,
          dateSelection: props.dateSelection,
          eventSelection: props.eventSelection,
          eventDrag: props.eventDrag,
          eventResize: props.eventResize
        };
        var transformers = this.buildViewPropTransformers(calendar.pluginSystem.hooks.viewPropsTransformers);

        for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {
          var transformer = transformers_1[_i];

          _assign(viewProps, transformer.transform(viewProps, viewSpec, props, options));
        }

        view.receiveProps(viewProps, this.buildComponentContext(this.context, viewSpec, view));
      }; // Sizing
      // -----------------------------------------------------------------------------------------------------------------


      CalendarComponent.prototype.updateSize = function (isResize) {
        if (isResize === void 0) {
          isResize = false;
        }

        var view = this.view;

        if (!view) {
          return; // why?
        }

        if (isResize || this.isHeightAuto == null) {
          this.computeHeightVars();
        }

        view.updateSize(isResize, this.viewHeight, this.isHeightAuto);
        view.updateNowIndicator(); // we need to guarantee this will run after updateSize

        view.popScroll(isResize);
      };

      CalendarComponent.prototype.computeHeightVars = function () {
        var calendar = this.context.calendar; // yuck. need to handle dynamic options

        var heightInput = calendar.opt('height');
        var contentHeightInput = calendar.opt('contentHeight');
        this.isHeightAuto = heightInput === 'auto' || contentHeightInput === 'auto';

        if (typeof contentHeightInput === 'number') {
          // exists and not 'auto'
          this.viewHeight = contentHeightInput;
        } else if (typeof contentHeightInput === 'function') {
          // exists and is a function
          this.viewHeight = contentHeightInput();
        } else if (typeof heightInput === 'number') {
          // exists and not 'auto'
          this.viewHeight = heightInput - this.queryToolbarsHeight();
        } else if (typeof heightInput === 'function') {
          // exists and is a function
          this.viewHeight = heightInput() - this.queryToolbarsHeight();
        } else if (heightInput === 'parent') {
          // set to height of parent element
          var parentEl = this.el.parentNode;
          this.viewHeight = parentEl.getBoundingClientRect().height - this.queryToolbarsHeight();
        } else {
          this.viewHeight = Math.round(this.contentEl.getBoundingClientRect().width / Math.max(calendar.opt('aspectRatio'), .5));
        }
      };

      CalendarComponent.prototype.queryToolbarsHeight = function () {
        var height = 0;

        if (this.header) {
          height += computeHeightAndMargins(this.header.el);
        }

        if (this.footer) {
          height += computeHeightAndMargins(this.footer.el);
        }

        return height;
      }; // Height "Freezing"
      // -----------------------------------------------------------------------------------------------------------------


      CalendarComponent.prototype.freezeHeight = function () {
        applyStyle(this.el, {
          height: this.el.getBoundingClientRect().height,
          overflow: 'hidden'
        });
      };

      CalendarComponent.prototype.thawHeight = function () {
        applyStyle(this.el, {
          height: '',
          overflow: ''
        });
      };

      return CalendarComponent;
    }(Component); // Title and Date Formatting
    // -----------------------------------------------------------------------------------------------------------------
    // Computes what the title at the top of the calendar should be for this view


    function computeTitle(dateProfile, viewOptions) {
      var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after

      if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
        range = dateProfile.currentRange;
      } else {
        // for day units or smaller, use the actual day range
        range = dateProfile.activeRange;
      }

      return this.context.dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || computeTitleFormat(dateProfile), viewOptions.titleRangeSeparator), {
        isEndExclusive: dateProfile.isRangeAllDay
      });
    } // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.


    function computeTitleFormat(dateProfile) {
      var currentRangeUnit = dateProfile.currentRangeUnit;

      if (currentRangeUnit === 'year') {
        return {
          year: 'numeric'
        };
      } else if (currentRangeUnit === 'month') {
        return {
          year: 'numeric',
          month: 'long'
        }; // like "September 2014"
      } else {
        var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);

        if (days !== null && days > 1) {
          // multi-day range. shorter, like "Sep 9 - 10 2014"
          return {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
          };
        } else {
          // one day. longer, like "September 9 2014"
          return {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
          };
        }
      }
    } // build a context scoped to the view


    function buildComponentContext(context, viewSpec, view) {
      return context.extend(viewSpec.options, view);
    } // Plugin
    // -----------------------------------------------------------------------------------------------------------------


    function buildViewPropTransformers(theClasses) {
      return theClasses.map(function (theClass) {
        return new theClass();
      });
    }

    var Interaction =
    /** @class */
    function () {
      function Interaction(settings) {
        this.component = settings.component;
      }

      Interaction.prototype.destroy = function () {};

      return Interaction;
    }();

    function parseInteractionSettings(component, input) {
      return {
        component: component,
        el: input.el,
        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true
      };
    }

    function interactionSettingsToStore(settings) {
      var _a;

      return _a = {}, _a[settings.component.uid] = settings, _a;
    } // global state


    var interactionSettingsStore = {};
    /*
    Detects when the user clicks on an event within a DateComponent
    */

    var EventClicking =
    /** @class */
    function (_super) {
      __extends(EventClicking, _super);

      function EventClicking(settings) {
        var _this = _super.call(this, settings) || this;

        _this.handleSegClick = function (ev, segEl) {
          var component = _this.component;
          var _a = component.context,
              calendar = _a.calendar,
              view = _a.view;
          var seg = getElSeg(segEl);

          if (seg && // might be the <div> surrounding the more link
          component.isValidSegDownEl(ev.target)) {
            // our way to simulate a link click for elements that can't be <a> tags
            // grab before trigger fired in case trigger trashes DOM thru rerendering
            var hasUrlContainer = elementClosest(ev.target, '.fc-has-url');
            var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';
            calendar.publiclyTrigger('eventClick', [{
              el: segEl,
              event: new EventApi(component.context.calendar, seg.eventRange.def, seg.eventRange.instance),
              jsEvent: ev,
              view: view
            }]);

            if (url && !ev.defaultPrevented) {
              window.location.href = url;
            }
          }
        };

        var component = settings.component;
        _this.destroy = listenBySelector(component.el, 'click', component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegClick);
        return _this;
      }

      return EventClicking;
    }(Interaction);
    /*
    Triggers events and adds/removes core classNames when the user's pointer
    enters/leaves event-elements of a component.
    */


    var EventHovering =
    /** @class */
    function (_super) {
      __extends(EventHovering, _super);

      function EventHovering(settings) {
        var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it


        _this.handleEventElRemove = function (el) {
          if (el === _this.currentSegEl) {
            _this.handleSegLeave(null, _this.currentSegEl);
          }
        };

        _this.handleSegEnter = function (ev, segEl) {
          if (getElSeg(segEl)) {
            // TODO: better way to make sure not hovering over more+ link or its wrapper
            segEl.classList.add('fc-allow-mouse-resize');
            _this.currentSegEl = segEl;

            _this.triggerEvent('eventMouseEnter', ev, segEl);
          }
        };

        _this.handleSegLeave = function (ev, segEl) {
          if (_this.currentSegEl) {
            segEl.classList.remove('fc-allow-mouse-resize');
            _this.currentSegEl = null;

            _this.triggerEvent('eventMouseLeave', ev, segEl);
          }
        };

        var component = settings.component;
        _this.removeHoverListeners = listenToHoverBySelector(component.el, component.fgSegSelector + ',' + component.bgSegSelector, _this.handleSegEnter, _this.handleSegLeave); // how to make sure component already has context?

        component.context.calendar.on('eventElRemove', _this.handleEventElRemove);
        return _this;
      }

      EventHovering.prototype.destroy = function () {
        this.removeHoverListeners();
        this.component.context.calendar.off('eventElRemove', this.handleEventElRemove);
      };

      EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {
        var component = this.component;
        var _a = component.context,
            calendar = _a.calendar,
            view = _a.view;
        var seg = getElSeg(segEl);

        if (!ev || component.isValidSegDownEl(ev.target)) {
          calendar.publiclyTrigger(publicEvName, [{
            el: segEl,
            event: new EventApi(calendar, seg.eventRange.def, seg.eventRange.instance),
            jsEvent: ev,
            view: view
          }]);
        }
      };

      return EventHovering;
    }(Interaction);

    var StandardTheme =
    /** @class */
    function (_super) {
      __extends(StandardTheme, _super);

      function StandardTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      return StandardTheme;
    }(Theme);

    StandardTheme.prototype.classes = {
      widget: 'fc-unthemed',
      widgetHeader: 'fc-widget-header',
      widgetContent: 'fc-widget-content',
      buttonGroup: 'fc-button-group',
      button: 'fc-button fc-button-primary',
      buttonActive: 'fc-button-active',
      popoverHeader: 'fc-widget-header',
      popoverContent: 'fc-widget-content',
      // day grid
      headerRow: 'fc-widget-header',
      dayRow: 'fc-widget-content',
      // list view
      listView: 'fc-widget-content'
    };
    StandardTheme.prototype.baseIconClass = 'fc-icon';
    StandardTheme.prototype.iconClasses = {
      close: 'fc-icon-x',
      prev: 'fc-icon-chevron-left',
      next: 'fc-icon-chevron-right',
      prevYear: 'fc-icon-chevrons-left',
      nextYear: 'fc-icon-chevrons-right'
    };
    StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';

    var Calendar =
    /** @class */
    function () {
      function Calendar(el, overrides) {
        var _this = this;

        this.buildComponentContext = memoize(buildComponentContext$1);
        this.parseRawLocales = memoize(parseRawLocales);
        this.buildLocale = memoize(buildLocale);
        this.buildDateEnv = memoize(buildDateEnv);
        this.buildTheme = memoize(buildTheme);
        this.buildEventUiSingleBase = memoize(this._buildEventUiSingleBase);
        this.buildSelectionConfig = memoize(this._buildSelectionConfig);
        this.buildEventUiBySource = memoizeOutput(buildEventUiBySource, isPropsEqual);
        this.buildEventUiBases = memoize(buildEventUiBases);
        this.interactionsStore = {};
        this.actionQueue = [];
        this.isReducing = false; // isDisplaying: boolean = false // installed in DOM? accepting renders?

        this.needsRerender = false; // needs a render?

        this.isRendering = false; // currently in the executeRender function?

        this.renderingPauseDepth = 0;
        this.buildDelayedRerender = memoize(buildDelayedRerender);
        this.afterSizingTriggers = {};
        this.isViewUpdated = false;
        this.isDatesUpdated = false;
        this.isEventsUpdated = false;
        this.el = el;
        this.optionsManager = new OptionsManager(overrides || {});
        this.pluginSystem = new PluginSystem(); // only do once. don't do in handleOptions. because can't remove plugins

        this.addPluginInputs(this.optionsManager.computed.plugins || []);
        this.handleOptions(this.optionsManager.computed);
        this.publiclyTrigger('_init'); // for tests

        this.hydrate();
        this.calendarInteractions = this.pluginSystem.hooks.calendarInteractions.map(function (calendarInteractionClass) {
          return new calendarInteractionClass(_this);
        });
      }

      Calendar.prototype.addPluginInputs = function (pluginInputs) {
        var pluginDefs = refinePluginDefs(pluginInputs);

        for (var _i = 0, pluginDefs_1 = pluginDefs; _i < pluginDefs_1.length; _i++) {
          var pluginDef = pluginDefs_1[_i];
          this.pluginSystem.add(pluginDef);
        }
      };

      Object.defineProperty(Calendar.prototype, "view", {
        // public API
        get: function get() {
          return this.component ? this.component.view : null;
        },
        enumerable: true,
        configurable: true
      }); // Public API for rendering
      // -----------------------------------------------------------------------------------------------------------------

      Calendar.prototype.render = function () {
        if (!this.component) {
          this.component = new CalendarComponent(this.el);
          this.renderableEventStore = createEmptyEventStore();
          this.bindHandlers();
          this.executeRender();
        } else {
          this.requestRerender();
        }
      };

      Calendar.prototype.destroy = function () {
        if (this.component) {
          this.unbindHandlers();
          this.component.destroy(); // don't null-out. in case API needs access

          this.component = null; // umm ???

          for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {
            var interaction = _a[_i];
            interaction.destroy();
          }

          this.publiclyTrigger('_destroyed');
        }
      }; // Handlers
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.bindHandlers = function () {
        var _this = this; // event delegation for nav links


        this.removeNavLinkListener = listenBySelector(this.el, 'click', 'a[data-goto]', function (ev, anchorEl) {
          var gotoOptions = anchorEl.getAttribute('data-goto');
          gotoOptions = gotoOptions ? JSON.parse(gotoOptions) : {};
          var dateEnv = _this.dateEnv;
          var dateMarker = dateEnv.createMarker(gotoOptions.date);
          var viewType = gotoOptions.type; // property like "navLinkDayClick". might be a string or a function

          var customAction = _this.viewOpt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

          if (typeof customAction === 'function') {
            customAction(dateEnv.toDate(dateMarker), ev);
          } else {
            if (typeof customAction === 'string') {
              viewType = customAction;
            }

            _this.zoomTo(dateMarker, viewType);
          }
        });

        if (this.opt('handleWindowResize')) {
          window.addEventListener('resize', this.windowResizeProxy = debounce( // prevents rapid calls
          this.windowResize.bind(this), this.opt('windowResizeDelay')));
        }
      };

      Calendar.prototype.unbindHandlers = function () {
        this.removeNavLinkListener();

        if (this.windowResizeProxy) {
          window.removeEventListener('resize', this.windowResizeProxy);
          this.windowResizeProxy = null;
        }
      }; // Dispatcher
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.hydrate = function () {
        var _this = this;

        this.state = this.buildInitialState();
        var rawSources = this.opt('eventSources') || [];
        var singleRawSource = this.opt('events');
        var sources = []; // parsed

        if (singleRawSource) {
          rawSources.unshift(singleRawSource);
        }

        for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {
          var rawSource = rawSources_1[_i];
          var source = parseEventSource(rawSource, this);

          if (source) {
            sources.push(source);
          }
        }

        this.batchRendering(function () {
          _this.dispatch({
            type: 'INIT'
          }); // pass in sources here?


          _this.dispatch({
            type: 'ADD_EVENT_SOURCES',
            sources: sources
          });

          _this.dispatch({
            type: 'SET_VIEW_TYPE',
            viewType: _this.opt('defaultView') || _this.pluginSystem.hooks.defaultView
          });
        });
      };

      Calendar.prototype.buildInitialState = function () {
        return {
          viewType: null,
          loadingLevel: 0,
          eventSourceLoadingLevel: 0,
          currentDate: this.getInitialDate(),
          dateProfile: null,
          eventSources: {},
          eventStore: createEmptyEventStore(),
          dateSelection: null,
          eventSelection: '',
          eventDrag: null,
          eventResize: null
        };
      };

      Calendar.prototype.dispatch = function (action) {
        this.actionQueue.push(action);

        if (!this.isReducing) {
          this.isReducing = true;
          var oldState = this.state;

          while (this.actionQueue.length) {
            this.state = this.reduce(this.state, this.actionQueue.shift(), this);
          }

          var newState = this.state;
          this.isReducing = false;

          if (!oldState.loadingLevel && newState.loadingLevel) {
            this.publiclyTrigger('loading', [true]);
          } else if (oldState.loadingLevel && !newState.loadingLevel) {
            this.publiclyTrigger('loading', [false]);
          }

          var view = this.component && this.component.view;

          if (oldState.eventStore !== newState.eventStore) {
            if (oldState.eventStore) {
              this.isEventsUpdated = true;
            }
          }

          if (oldState.dateProfile !== newState.dateProfile) {
            if (oldState.dateProfile && view) {
              // why would view be null!?
              this.publiclyTrigger('datesDestroy', [{
                view: view,
                el: view.el
              }]);
            }

            this.isDatesUpdated = true;
          }

          if (oldState.viewType !== newState.viewType) {
            if (oldState.viewType && view) {
              // why would view be null!?
              this.publiclyTrigger('viewSkeletonDestroy', [{
                view: view,
                el: view.el
              }]);
            }

            this.isViewUpdated = true;
          }

          this.requestRerender();
        }
      };

      Calendar.prototype.reduce = function (state, action, calendar) {
        return reduce(state, action, calendar);
      }; // Render Queue
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.requestRerender = function () {
        this.needsRerender = true;
        this.delayedRerender(); // will call a debounced-version of tryRerender
      };

      Calendar.prototype.tryRerender = function () {
        if (this.component && // must be accepting renders
        this.needsRerender && // indicates that a rerender was requested
        !this.renderingPauseDepth && // not paused
        !this.isRendering // not currently in the render loop
        ) {
          this.executeRender();
        }
      };

      Calendar.prototype.batchRendering = function (func) {
        this.renderingPauseDepth++;
        func();
        this.renderingPauseDepth--;

        if (this.needsRerender) {
          this.requestRerender();
        }
      }; // Rendering
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.executeRender = function () {
        // clear these BEFORE the render so that new values will accumulate during render
        this.needsRerender = false;
        this.isRendering = true;
        this.renderComponent();
        this.isRendering = false; // received a rerender request while rendering

        if (this.needsRerender) {
          this.delayedRerender();
        }
      };
      /*
      don't call this directly. use executeRender instead
      */


      Calendar.prototype.renderComponent = function () {
        var _a = this,
            state = _a.state,
            component = _a.component;

        var viewType = state.viewType;
        var viewSpec = this.viewSpecs[viewType];

        if (!viewSpec) {
          throw new Error("View type \"" + viewType + "\" is not valid");
        } // if event sources are still loading and progressive rendering hasn't been enabled,
        // keep rendering the last fully loaded set of events


        var renderableEventStore = this.renderableEventStore = state.eventSourceLoadingLevel && !this.opt('progressiveEventRendering') ? this.renderableEventStore : state.eventStore;
        var eventUiSingleBase = this.buildEventUiSingleBase(viewSpec.options);
        var eventUiBySource = this.buildEventUiBySource(state.eventSources);
        var eventUiBases = this.eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
        component.receiveProps(_assign({}, state, {
          viewSpec: viewSpec,
          dateProfileGenerator: this.dateProfileGenerators[viewType],
          dateProfile: state.dateProfile,
          eventStore: renderableEventStore,
          eventUiBases: eventUiBases,
          dateSelection: state.dateSelection,
          eventSelection: state.eventSelection,
          eventDrag: state.eventDrag,
          eventResize: state.eventResize
        }), this.buildComponentContext(this.theme, this.dateEnv, this.optionsManager.computed));

        if (this.isViewUpdated) {
          this.isViewUpdated = false;
          this.publiclyTrigger('viewSkeletonRender', [{
            view: component.view,
            el: component.view.el
          }]);
        }

        if (this.isDatesUpdated) {
          this.isDatesUpdated = false;
          this.publiclyTrigger('datesRender', [{
            view: component.view,
            el: component.view.el
          }]);
        }

        if (this.isEventsUpdated) {
          this.isEventsUpdated = false;
        }

        this.releaseAfterSizingTriggers();
      }; // Options
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.setOption = function (name, val) {
        var _a;

        this.mutateOptions((_a = {}, _a[name] = val, _a), [], true);
      };

      Calendar.prototype.getOption = function (name) {
        return this.optionsManager.computed[name];
      };

      Calendar.prototype.opt = function (name) {
        return this.optionsManager.computed[name];
      };

      Calendar.prototype.viewOpt = function (name) {
        return this.viewOpts()[name];
      };

      Calendar.prototype.viewOpts = function () {
        return this.viewSpecs[this.state.viewType].options;
      };
      /*
      handles option changes (like a diff)
      */


      Calendar.prototype.mutateOptions = function (updates, removals, isDynamic, deepEqual) {
        var _this = this;

        var changeHandlers = this.pluginSystem.hooks.optionChangeHandlers;
        var normalUpdates = {};
        var specialUpdates = {};
        var oldDateEnv = this.dateEnv; // do this before handleOptions

        var isTimeZoneDirty = false;
        var isSizeDirty = false;
        var anyDifficultOptions = Boolean(removals.length);

        for (var name_1 in updates) {
          if (changeHandlers[name_1]) {
            specialUpdates[name_1] = updates[name_1];
          } else {
            normalUpdates[name_1] = updates[name_1];
          }
        }

        for (var name_2 in normalUpdates) {
          if (/^(height|contentHeight|aspectRatio)$/.test(name_2)) {
            isSizeDirty = true;
          } else if (/^(defaultDate|defaultView)$/.test(name_2)) ;else {
            anyDifficultOptions = true;

            if (name_2 === 'timeZone') {
              isTimeZoneDirty = true;
            }
          }
        }

        this.optionsManager.mutate(normalUpdates, removals, isDynamic);

        if (anyDifficultOptions) {
          this.handleOptions(this.optionsManager.computed);
        }

        this.batchRendering(function () {
          if (anyDifficultOptions) {
            if (isTimeZoneDirty) {
              _this.dispatch({
                type: 'CHANGE_TIMEZONE',
                oldDateEnv: oldDateEnv
              });
            }
            /* HACK
            has the same effect as calling this.requestRerender()
            but recomputes the state's dateProfile
            */


            _this.dispatch({
              type: 'SET_VIEW_TYPE',
              viewType: _this.state.viewType
            });
          } else if (isSizeDirty) {
            _this.updateSize();
          } // special updates


          if (deepEqual) {
            for (var name_3 in specialUpdates) {
              changeHandlers[name_3](specialUpdates[name_3], _this, deepEqual);
            }
          }
        });
      };
      /*
      rebuilds things based off of a complete set of refined options
      */


      Calendar.prototype.handleOptions = function (options) {
        var _this = this;

        var pluginHooks = this.pluginSystem.hooks;
        this.defaultAllDayEventDuration = createDuration(options.defaultAllDayEventDuration);
        this.defaultTimedEventDuration = createDuration(options.defaultTimedEventDuration);
        this.delayedRerender = this.buildDelayedRerender(options.rerenderDelay);
        this.theme = this.buildTheme(options);
        var available = this.parseRawLocales(options.locales);
        this.availableRawLocales = available.map;
        var locale = this.buildLocale(options.locale || available.defaultCode, available.map);
        this.dateEnv = this.buildDateEnv(locale, options.timeZone, pluginHooks.namedTimeZonedImpl, options.firstDay, options.weekNumberCalculation, options.weekLabel, pluginHooks.cmdFormatter);
        this.selectionConfig = this.buildSelectionConfig(options); // needs dateEnv. do after :(
        // ineffecient to do every time?

        this.viewSpecs = buildViewSpecs(pluginHooks.views, this.optionsManager); // ineffecient to do every time?

        this.dateProfileGenerators = mapHash(this.viewSpecs, function (viewSpec) {
          return new viewSpec["class"].prototype.dateProfileGeneratorClass(viewSpec, _this);
        });
      };

      Calendar.prototype.getAvailableLocaleCodes = function () {
        return Object.keys(this.availableRawLocales);
      };

      Calendar.prototype._buildSelectionConfig = function (rawOpts) {
        return processScopedUiProps('select', rawOpts, this);
      };

      Calendar.prototype._buildEventUiSingleBase = function (rawOpts) {
        if (rawOpts.editable) {
          // so 'editable' affected events
          rawOpts = _assign({}, rawOpts, {
            eventEditable: true
          });
        }

        return processScopedUiProps('event', rawOpts, this);
      }; // Trigger
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.hasPublicHandlers = function (name) {
        return this.hasHandlers(name) || this.opt(name); // handler specified in options
      };

      Calendar.prototype.publiclyTrigger = function (name, args) {
        var optHandler = this.opt(name);
        this.triggerWith(name, this, args);

        if (optHandler) {
          return optHandler.apply(this, args);
        }
      };

      Calendar.prototype.publiclyTriggerAfterSizing = function (name, args) {
        var afterSizingTriggers = this.afterSizingTriggers;
        (afterSizingTriggers[name] || (afterSizingTriggers[name] = [])).push(args);
      };

      Calendar.prototype.releaseAfterSizingTriggers = function () {
        var afterSizingTriggers = this.afterSizingTriggers;

        for (var name_4 in afterSizingTriggers) {
          for (var _i = 0, _a = afterSizingTriggers[name_4]; _i < _a.length; _i++) {
            var args = _a[_i];
            this.publiclyTrigger(name_4, args);
          }
        }

        this.afterSizingTriggers = {};
      }; // View
      // -----------------------------------------------------------------------------------------------------------------
      // Returns a boolean about whether the view is okay to instantiate at some point


      Calendar.prototype.isValidViewType = function (viewType) {
        return Boolean(this.viewSpecs[viewType]);
      };

      Calendar.prototype.changeView = function (viewType, dateOrRange) {
        var dateMarker = null;

        if (dateOrRange) {
          if (dateOrRange.start && dateOrRange.end) {
            // a range
            this.optionsManager.mutate({
              visibleRange: dateOrRange
            }, []); // will not rerender

            this.handleOptions(this.optionsManager.computed); // ...but yuck
          } else {
            // a date
            dateMarker = this.dateEnv.createMarker(dateOrRange); // just like gotoDate
          }
        }

        this.unselect();
        this.dispatch({
          type: 'SET_VIEW_TYPE',
          viewType: viewType,
          dateMarker: dateMarker
        });
      }; // Forces navigation to a view for the given date.
      // `viewType` can be a specific view name or a generic one like "week" or "day".
      // needs to change


      Calendar.prototype.zoomTo = function (dateMarker, viewType) {
        var spec;
        viewType = viewType || 'day'; // day is default zoom

        spec = this.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
        this.unselect();

        if (spec) {
          this.dispatch({
            type: 'SET_VIEW_TYPE',
            viewType: spec.type,
            dateMarker: dateMarker
          });
        } else {
          this.dispatch({
            type: 'SET_DATE',
            dateMarker: dateMarker
          });
        }
      }; // Given a duration singular unit, like "week" or "day", finds a matching view spec.
      // Preference is given to views that have corresponding buttons.


      Calendar.prototype.getUnitViewSpec = function (unit) {
        var component = this.component;
        var viewTypes = [];
        var i;
        var spec; // put views that have buttons first. there will be duplicates, but oh

        if (component.header) {
          viewTypes.push.apply(viewTypes, component.header.viewsWithButtons);
        }

        if (component.footer) {
          viewTypes.push.apply(viewTypes, component.footer.viewsWithButtons);
        }

        for (var viewType in this.viewSpecs) {
          viewTypes.push(viewType);
        }

        for (i = 0; i < viewTypes.length; i++) {
          spec = this.viewSpecs[viewTypes[i]];

          if (spec) {
            if (spec.singleUnit === unit) {
              return spec;
            }
          }
        }
      }; // Current Date
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.getInitialDate = function () {
        var defaultDateInput = this.opt('defaultDate'); // compute the initial ambig-timezone date

        if (defaultDateInput != null) {
          return this.dateEnv.createMarker(defaultDateInput);
        } else {
          return this.getNow(); // getNow already returns unzoned
        }
      };

      Calendar.prototype.prev = function () {
        this.unselect();
        this.dispatch({
          type: 'PREV'
        });
      };

      Calendar.prototype.next = function () {
        this.unselect();
        this.dispatch({
          type: 'NEXT'
        });
      };

      Calendar.prototype.prevYear = function () {
        this.unselect();
        this.dispatch({
          type: 'SET_DATE',
          dateMarker: this.dateEnv.addYears(this.state.currentDate, -1)
        });
      };

      Calendar.prototype.nextYear = function () {
        this.unselect();
        this.dispatch({
          type: 'SET_DATE',
          dateMarker: this.dateEnv.addYears(this.state.currentDate, 1)
        });
      };

      Calendar.prototype.today = function () {
        this.unselect();
        this.dispatch({
          type: 'SET_DATE',
          dateMarker: this.getNow()
        });
      };

      Calendar.prototype.gotoDate = function (zonedDateInput) {
        this.unselect();
        this.dispatch({
          type: 'SET_DATE',
          dateMarker: this.dateEnv.createMarker(zonedDateInput)
        });
      };

      Calendar.prototype.incrementDate = function (deltaInput) {
        var delta = createDuration(deltaInput);

        if (delta) {
          // else, warn about invalid input?
          this.unselect();
          this.dispatch({
            type: 'SET_DATE',
            dateMarker: this.dateEnv.add(this.state.currentDate, delta)
          });
        }
      }; // for external API


      Calendar.prototype.getDate = function () {
        return this.dateEnv.toDate(this.state.currentDate);
      }; // Date Formatting Utils
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.formatDate = function (d, formatter) {
        var dateEnv = this.dateEnv;
        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));
      }; // `settings` is for formatter AND isEndExclusive


      Calendar.prototype.formatRange = function (d0, d1, settings) {
        var dateEnv = this.dateEnv;
        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings, this.opt('defaultRangeSeparator')), settings);
      };

      Calendar.prototype.formatIso = function (d, omitTime) {
        var dateEnv = this.dateEnv;
        return dateEnv.formatIso(dateEnv.createMarker(d), {
          omitTime: omitTime
        });
      }; // Sizing
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.windowResize = function (ev) {
        if (!this.isHandlingWindowResize && this.component && // why?
        ev.target === window // not a jqui resize event
        ) {
          this.isHandlingWindowResize = true;
          this.updateSize();
          this.publiclyTrigger('windowResize', [this.view]);
          this.isHandlingWindowResize = false;
        }
      };

      Calendar.prototype.updateSize = function () {
        if (this.component) {
          // when?
          this.component.updateSize(true);
        }
      }; // Component Registration
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.registerInteractiveComponent = function (component, settingsInput) {
        var settings = parseInteractionSettings(component, settingsInput);
        var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];
        var interactionClasses = DEFAULT_INTERACTIONS.concat(this.pluginSystem.hooks.componentInteractions);
        var interactions = interactionClasses.map(function (interactionClass) {
          return new interactionClass(settings);
        });
        this.interactionsStore[component.uid] = interactions;
        interactionSettingsStore[component.uid] = settings;
      };

      Calendar.prototype.unregisterInteractiveComponent = function (component) {
        for (var _i = 0, _a = this.interactionsStore[component.uid]; _i < _a.length; _i++) {
          var listener = _a[_i];
          listener.destroy();
        }

        delete this.interactionsStore[component.uid];
        delete interactionSettingsStore[component.uid];
      }; // Date Selection / Event Selection / DayClick
      // -----------------------------------------------------------------------------------------------------------------
      // this public method receives start/end dates in any format, with any timezone
      // NOTE: args were changed from v3


      Calendar.prototype.select = function (dateOrObj, endDate) {
        var selectionInput;

        if (endDate == null) {
          if (dateOrObj.start != null) {
            selectionInput = dateOrObj;
          } else {
            selectionInput = {
              start: dateOrObj,
              end: null
            };
          }
        } else {
          selectionInput = {
            start: dateOrObj,
            end: endDate
          };
        }

        var selection = parseDateSpan(selectionInput, this.dateEnv, createDuration({
          days: 1
        }) // TODO: cache this?
        );

        if (selection) {
          // throw parse error otherwise?
          this.dispatch({
            type: 'SELECT_DATES',
            selection: selection
          });
          this.triggerDateSelect(selection);
        }
      }; // public method


      Calendar.prototype.unselect = function (pev) {
        if (this.state.dateSelection) {
          this.dispatch({
            type: 'UNSELECT_DATES'
          });
          this.triggerDateUnselect(pev);
        }
      };

      Calendar.prototype.triggerDateSelect = function (selection, pev) {
        var arg = _assign({}, this.buildDateSpanApi(selection), {
          jsEvent: pev ? pev.origEvent : null,
          view: this.view
        });

        this.publiclyTrigger('select', [arg]);
      };

      Calendar.prototype.triggerDateUnselect = function (pev) {
        this.publiclyTrigger('unselect', [{
          jsEvent: pev ? pev.origEvent : null,
          view: this.view
        }]);
      }; // TODO: receive pev?


      Calendar.prototype.triggerDateClick = function (dateSpan, dayEl, view, ev) {
        var arg = _assign({}, this.buildDatePointApi(dateSpan), {
          dayEl: dayEl,
          jsEvent: ev,
          // Is this always a mouse event? See #4655
          view: view
        });

        this.publiclyTrigger('dateClick', [arg]);
      };

      Calendar.prototype.buildDatePointApi = function (dateSpan) {
        var props = {};

        for (var _i = 0, _a = this.pluginSystem.hooks.datePointTransforms; _i < _a.length; _i++) {
          var transform = _a[_i];

          _assign(props, transform(dateSpan, this));
        }

        _assign(props, buildDatePointApi(dateSpan, this.dateEnv));

        return props;
      };

      Calendar.prototype.buildDateSpanApi = function (dateSpan) {
        var props = {};

        for (var _i = 0, _a = this.pluginSystem.hooks.dateSpanTransforms; _i < _a.length; _i++) {
          var transform = _a[_i];

          _assign(props, transform(dateSpan, this));
        }

        _assign(props, buildDateSpanApi(dateSpan, this.dateEnv));

        return props;
      }; // Date Utils
      // -----------------------------------------------------------------------------------------------------------------
      // Returns a DateMarker for the current date, as defined by the client's computer or from the `now` option


      Calendar.prototype.getNow = function () {
        var now = this.opt('now');

        if (typeof now === 'function') {
          now = now();
        }

        if (now == null) {
          return this.dateEnv.createNowMarker();
        }

        return this.dateEnv.createMarker(now);
      }; // Event-Date Utilities
      // -----------------------------------------------------------------------------------------------------------------
      // Given an event's allDay status and start date, return what its fallback end date should be.
      // TODO: rename to computeDefaultEventEnd


      Calendar.prototype.getDefaultEventEnd = function (allDay, marker) {
        var end = marker;

        if (allDay) {
          end = startOfDay(end);
          end = this.dateEnv.add(end, this.defaultAllDayEventDuration);
        } else {
          end = this.dateEnv.add(end, this.defaultTimedEventDuration);
        }

        return end;
      }; // Public Events API
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.addEvent = function (eventInput, sourceInput) {
        if (eventInput instanceof EventApi) {
          var def = eventInput._def;
          var instance = eventInput._instance; // not already present? don't want to add an old snapshot

          if (!this.state.eventStore.defs[def.defId]) {
            this.dispatch({
              type: 'ADD_EVENTS',
              eventStore: eventTupleToStore({
                def: def,
                instance: instance
              }) // TODO: better util for two args?

            });
          }

          return eventInput;
        }

        var sourceId;

        if (sourceInput instanceof EventSourceApi) {
          sourceId = sourceInput.internalEventSource.sourceId;
        } else if (sourceInput != null) {
          var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function

          if (!sourceApi) {
            console.warn('Could not find an event source with ID "' + sourceInput + '"'); // TODO: test

            return null;
          } else {
            sourceId = sourceApi.internalEventSource.sourceId;
          }
        }

        var tuple = parseEvent(eventInput, sourceId, this);

        if (tuple) {
          this.dispatch({
            type: 'ADD_EVENTS',
            eventStore: eventTupleToStore(tuple)
          });
          return new EventApi(this, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
        }

        return null;
      }; // TODO: optimize


      Calendar.prototype.getEventById = function (id) {
        var _a = this.state.eventStore,
            defs = _a.defs,
            instances = _a.instances;
        id = String(id);

        for (var defId in defs) {
          var def = defs[defId];

          if (def.publicId === id) {
            if (def.recurringDef) {
              return new EventApi(this, def, null);
            } else {
              for (var instanceId in instances) {
                var instance = instances[instanceId];

                if (instance.defId === def.defId) {
                  return new EventApi(this, def, instance);
                }
              }
            }
          }
        }

        return null;
      };

      Calendar.prototype.getEvents = function () {
        var _a = this.state.eventStore,
            defs = _a.defs,
            instances = _a.instances;
        var eventApis = [];

        for (var id in instances) {
          var instance = instances[id];
          var def = defs[instance.defId];
          eventApis.push(new EventApi(this, def, instance));
        }

        return eventApis;
      };

      Calendar.prototype.removeAllEvents = function () {
        this.dispatch({
          type: 'REMOVE_ALL_EVENTS'
        });
      };

      Calendar.prototype.rerenderEvents = function () {
        this.dispatch({
          type: 'RESET_EVENTS'
        });
      }; // Public Event Sources API
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.getEventSources = function () {
        var sourceHash = this.state.eventSources;
        var sourceApis = [];

        for (var internalId in sourceHash) {
          sourceApis.push(new EventSourceApi(this, sourceHash[internalId]));
        }

        return sourceApis;
      };

      Calendar.prototype.getEventSourceById = function (id) {
        var sourceHash = this.state.eventSources;
        id = String(id);

        for (var sourceId in sourceHash) {
          if (sourceHash[sourceId].publicId === id) {
            return new EventSourceApi(this, sourceHash[sourceId]);
          }
        }

        return null;
      };

      Calendar.prototype.addEventSource = function (sourceInput) {
        if (sourceInput instanceof EventSourceApi) {
          // not already present? don't want to add an old snapshot
          if (!this.state.eventSources[sourceInput.internalEventSource.sourceId]) {
            this.dispatch({
              type: 'ADD_EVENT_SOURCES',
              sources: [sourceInput.internalEventSource]
            });
          }

          return sourceInput;
        }

        var eventSource = parseEventSource(sourceInput, this);

        if (eventSource) {
          // TODO: error otherwise?
          this.dispatch({
            type: 'ADD_EVENT_SOURCES',
            sources: [eventSource]
          });
          return new EventSourceApi(this, eventSource);
        }

        return null;
      };

      Calendar.prototype.removeAllEventSources = function () {
        this.dispatch({
          type: 'REMOVE_ALL_EVENT_SOURCES'
        });
      };

      Calendar.prototype.refetchEvents = function () {
        this.dispatch({
          type: 'FETCH_EVENT_SOURCES'
        });
      }; // Scroll
      // -----------------------------------------------------------------------------------------------------------------


      Calendar.prototype.scrollToTime = function (timeInput) {
        var duration = createDuration(timeInput);

        if (duration) {
          this.component.view.scrollToDuration(duration);
        }
      };

      return Calendar;
    }();

    EmitterMixin.mixInto(Calendar); // for memoizers
    // -----------------------------------------------------------------------------------------------------------------

    function buildComponentContext$1(theme, dateEnv, options) {
      return new ComponentContext(this, theme, dateEnv, options, null);
    }

    function buildDateEnv(locale, timeZone, namedTimeZoneImpl, firstDay, weekNumberCalculation, weekLabel, cmdFormatter) {
      return new DateEnv({
        calendarSystem: 'gregory',
        timeZone: timeZone,
        namedTimeZoneImpl: namedTimeZoneImpl,
        locale: locale,
        weekNumberCalculation: weekNumberCalculation,
        firstDay: firstDay,
        weekLabel: weekLabel,
        cmdFormatter: cmdFormatter
      });
    }

    function buildTheme(calendarOptions) {
      var themeClass = this.pluginSystem.hooks.themeClasses[calendarOptions.themeSystem] || StandardTheme;
      return new themeClass(calendarOptions);
    }

    function buildDelayedRerender(wait) {
      var func = this.tryRerender.bind(this);

      if (wait != null) {
        func = debounce(func, wait);
      }

      return func;
    }

    function buildEventUiBySource(eventSources) {
      return mapHash(eventSources, function (eventSource) {
        return eventSource.ui;
      });
    }

    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
      var eventUiBases = {
        '': eventUiSingleBase
      };

      for (var defId in eventDefs) {
        var def = eventDefs[defId];

        if (def.sourceId && eventUiBySource[def.sourceId]) {
          eventUiBases[defId] = eventUiBySource[def.sourceId];
        }
      }

      return eventUiBases;
    }

    var View =
    /** @class */
    function (_super) {
      __extends(View, _super);

      function View(viewSpec, parentEl) {
        var _this = _super.call(this, createElement('div', {
          className: 'fc-view fc-' + viewSpec.type + '-view'
        })) || this;

        _this.renderDatesMem = memoizeRendering(_this.renderDatesWrap, _this.unrenderDatesWrap);
        _this.renderBusinessHoursMem = memoizeRendering(_this.renderBusinessHours, _this.unrenderBusinessHours, [_this.renderDatesMem]);
        _this.renderDateSelectionMem = memoizeRendering(_this.renderDateSelectionWrap, _this.unrenderDateSelectionWrap, [_this.renderDatesMem]);
        _this.renderEventsMem = memoizeRendering(_this.renderEvents, _this.unrenderEvents, [_this.renderDatesMem]);
        _this.renderEventSelectionMem = memoizeRendering(_this.renderEventSelectionWrap, _this.unrenderEventSelectionWrap, [_this.renderEventsMem]);
        _this.renderEventDragMem = memoizeRendering(_this.renderEventDragWrap, _this.unrenderEventDragWrap, [_this.renderDatesMem]);
        _this.renderEventResizeMem = memoizeRendering(_this.renderEventResizeWrap, _this.unrenderEventResizeWrap, [_this.renderDatesMem]);
        _this.viewSpec = viewSpec;
        _this.type = viewSpec.type;
        parentEl.appendChild(_this.el);

        _this.initialize();

        return _this;
      }

      View.prototype.initialize = function () {};

      Object.defineProperty(View.prototype, "activeStart", {
        // Date Setting/Unsetting
        // -----------------------------------------------------------------------------------------------------------------
        get: function get() {
          return this.context.dateEnv.toDate(this.props.dateProfile.activeRange.start);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(View.prototype, "activeEnd", {
        get: function get() {
          return this.context.dateEnv.toDate(this.props.dateProfile.activeRange.end);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(View.prototype, "currentStart", {
        get: function get() {
          return this.context.dateEnv.toDate(this.props.dateProfile.currentRange.start);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(View.prototype, "currentEnd", {
        get: function get() {
          return this.context.dateEnv.toDate(this.props.dateProfile.currentRange.end);
        },
        enumerable: true,
        configurable: true
      }); // General Rendering
      // -----------------------------------------------------------------------------------------------------------------

      View.prototype.render = function (props, context) {
        this.renderDatesMem(props.dateProfile);
        this.renderBusinessHoursMem(props.businessHours);
        this.renderDateSelectionMem(props.dateSelection);
        this.renderEventsMem(props.eventStore);
        this.renderEventSelectionMem(props.eventSelection);
        this.renderEventDragMem(props.eventDrag);
        this.renderEventResizeMem(props.eventResize);
      };

      View.prototype.beforeUpdate = function () {
        this.addScroll(this.queryScroll());
      };

      View.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.renderDatesMem.unrender(); // should unrender everything else
      }; // Sizing
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.updateSize = function (isResize, viewHeight, isAuto) {
        var calendar = this.context.calendar;

        if (isResize) {
          this.addScroll(this.queryScroll()); // NOTE: same code as in beforeUpdate
        }

        if (isResize || // HACKS...
        calendar.isViewUpdated || calendar.isDatesUpdated || calendar.isEventsUpdated) {
          // sort of the catch-all sizing
          // anything that might cause dimension changes
          this.updateBaseSize(isResize, viewHeight, isAuto);
        } // NOTE: popScroll is called by CalendarComponent

      };

      View.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {}; // Date Rendering
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderDatesWrap = function (dateProfile) {
        this.renderDates(dateProfile);
        this.addScroll({
          duration: createDuration(this.context.options.scrollTime)
        });
      };

      View.prototype.unrenderDatesWrap = function () {
        this.stopNowIndicator();
        this.unrenderDates();
      };

      View.prototype.renderDates = function (dateProfile) {};

      View.prototype.unrenderDates = function () {}; // Business Hours
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderBusinessHours = function (businessHours) {};

      View.prototype.unrenderBusinessHours = function () {}; // Date Selection
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderDateSelectionWrap = function (selection) {
        if (selection) {
          this.renderDateSelection(selection);
        }
      };

      View.prototype.unrenderDateSelectionWrap = function (selection) {
        if (selection) {
          this.unrenderDateSelection(selection);
        }
      };

      View.prototype.renderDateSelection = function (selection) {};

      View.prototype.unrenderDateSelection = function (selection) {}; // Event Rendering
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderEvents = function (eventStore) {};

      View.prototype.unrenderEvents = function () {}; // util for subclasses


      View.prototype.sliceEvents = function (eventStore, allDay) {
        var props = this.props;
        return sliceEventStore(eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? this.context.nextDayThreshold : null).fg;
      }; // Event Selection
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderEventSelectionWrap = function (instanceId) {
        if (instanceId) {
          this.renderEventSelection(instanceId);
        }
      };

      View.prototype.unrenderEventSelectionWrap = function (instanceId) {
        if (instanceId) {
          this.unrenderEventSelection(instanceId);
        }
      };

      View.prototype.renderEventSelection = function (instanceId) {};

      View.prototype.unrenderEventSelection = function (instanceId) {}; // Event Drag
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderEventDragWrap = function (state) {
        if (state) {
          this.renderEventDrag(state);
        }
      };

      View.prototype.unrenderEventDragWrap = function (state) {
        if (state) {
          this.unrenderEventDrag(state);
        }
      };

      View.prototype.renderEventDrag = function (state) {};

      View.prototype.unrenderEventDrag = function (state) {}; // Event Resize
      // -----------------------------------------------------------------------------------------------------------------


      View.prototype.renderEventResizeWrap = function (state) {
        if (state) {
          this.renderEventResize(state);
        }
      };

      View.prototype.unrenderEventResizeWrap = function (state) {
        if (state) {
          this.unrenderEventResize(state);
        }
      };

      View.prototype.renderEventResize = function (state) {};

      View.prototype.unrenderEventResize = function (state) {};
      /* Now Indicator
      ------------------------------------------------------------------------------------------------------------------*/
      // Immediately render the current time indicator and begins re-rendering it at an interval,
      // which is defined by this.getNowIndicatorUnit().
      // TODO: somehow do this for the current whole day's background too
      // USAGE: must be called manually from subclasses' render methods! don't need to call stopNowIndicator tho


      View.prototype.startNowIndicator = function (dateProfile, dateProfileGenerator) {
        var _this = this;

        var _a = this.context,
            calendar = _a.calendar,
            dateEnv = _a.dateEnv,
            options = _a.options;
        var unit;
        var update;
        var delay; // ms wait value

        if (options.nowIndicator && !this.initialNowDate) {
          unit = this.getNowIndicatorUnit(dateProfile, dateProfileGenerator);

          if (unit) {
            update = this.updateNowIndicator.bind(this);
            this.initialNowDate = calendar.getNow();
            this.initialNowQueriedMs = new Date().valueOf(); // wait until the beginning of the next interval

            delay = dateEnv.add(dateEnv.startOf(this.initialNowDate, unit), createDuration(1, unit)).valueOf() - this.initialNowDate.valueOf(); // TODO: maybe always use setTimeout, waiting until start of next unit

            this.nowIndicatorTimeoutID = setTimeout(function () {
              _this.nowIndicatorTimeoutID = null;
              update();

              if (unit === 'second') {
                delay = 1000; // every second
              } else {
                delay = 1000 * 60; // otherwise, every minute
              }

              _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
            }, delay);
          } // rendering will be initiated in updateSize

        }
      }; // rerenders the now indicator, computing the new current time from the amount of time that has passed
      // since the initial getNow call.


      View.prototype.updateNowIndicator = function () {
        if (this.props.dateProfile && // a way to determine if dates were rendered yet
        this.initialNowDate // activated before?
        ) {
          this.unrenderNowIndicator(); // won't unrender if unnecessary

          this.renderNowIndicator(addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs));
          this.isNowIndicatorRendered = true;
        }
      }; // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
      // Won't cause side effects if indicator isn't rendered.


      View.prototype.stopNowIndicator = function () {
        if (this.nowIndicatorTimeoutID) {
          clearTimeout(this.nowIndicatorTimeoutID);
          this.nowIndicatorTimeoutID = null;
        }

        if (this.nowIndicatorIntervalID) {
          clearInterval(this.nowIndicatorIntervalID);
          this.nowIndicatorIntervalID = null;
        }

        if (this.isNowIndicatorRendered) {
          this.unrenderNowIndicator();
          this.isNowIndicatorRendered = false;
        }
      };

      View.prototype.getNowIndicatorUnit = function (dateProfile, dateProfileGenerator) {// subclasses should implement
      }; // Renders a current time indicator at the given datetime


      View.prototype.renderNowIndicator = function (date) {// SUBCLASSES MUST PASS TO CHILDREN!
      }; // Undoes the rendering actions from renderNowIndicator


      View.prototype.unrenderNowIndicator = function () {// SUBCLASSES MUST PASS TO CHILDREN!
      };
      /* Scroller
      ------------------------------------------------------------------------------------------------------------------*/


      View.prototype.addScroll = function (scroll, isForced) {
        if (isForced) {
          scroll.isForced = isForced;
        }

        _assign(this.queuedScroll || (this.queuedScroll = {}), scroll);
      };

      View.prototype.popScroll = function (isResize) {
        this.applyQueuedScroll(isResize);
        this.queuedScroll = null;
      };

      View.prototype.applyQueuedScroll = function (isResize) {
        if (this.queuedScroll) {
          this.applyScroll(this.queuedScroll, isResize);
        }
      };

      View.prototype.queryScroll = function () {
        var scroll = {};

        if (this.props.dateProfile) {
          // dates rendered yet?
          _assign(scroll, this.queryDateScroll());
        }

        return scroll;
      };

      View.prototype.applyScroll = function (scroll, isResize) {
        var duration = scroll.duration,
            isForced = scroll.isForced;

        if (duration != null && !isForced) {
          delete scroll.duration;

          if (this.props.dateProfile) {
            // dates rendered yet?
            _assign(scroll, this.computeDateScroll(duration));
          }
        }

        if (this.props.dateProfile) {
          // dates rendered yet?
          this.applyDateScroll(scroll);
        }
      };

      View.prototype.computeDateScroll = function (duration) {
        return {}; // subclasses must implement
      };

      View.prototype.queryDateScroll = function () {
        return {}; // subclasses must implement
      };

      View.prototype.applyDateScroll = function (scroll) {// subclasses must implement
      }; // for API


      View.prototype.scrollToDuration = function (duration) {
        this.applyScroll({
          duration: duration
        }, false);
      };

      return View;
    }(DateComponent);

    EmitterMixin.mixInto(View);
    View.prototype.usesMinMaxTime = false;
    View.prototype.dateProfileGeneratorClass = DateProfileGenerator;

    var FgEventRenderer =
    /** @class */
    function () {
      function FgEventRenderer() {
        this.segs = [];
        this.isSizeDirty = false;
      }

      FgEventRenderer.prototype.renderSegs = function (context, segs, mirrorInfo) {
        this.context = context;
        this.rangeUpdated(); // called too frequently :(
        // render an `.el` on each seg
        // returns a subset of the segs. segs that were actually rendered

        segs = this.renderSegEls(segs, mirrorInfo);
        this.segs = segs;
        this.attachSegs(segs, mirrorInfo);
        this.isSizeDirty = true;
        triggerRenderedSegs(this.context, this.segs, Boolean(mirrorInfo));
      };

      FgEventRenderer.prototype.unrender = function (context, _segs, mirrorInfo) {
        triggerWillRemoveSegs(this.context, this.segs, Boolean(mirrorInfo));
        this.detachSegs(this.segs);
        this.segs = [];
      }; // Updates values that rely on options and also relate to range


      FgEventRenderer.prototype.rangeUpdated = function () {
        var options = this.context.options;
        var displayEventTime;
        var displayEventEnd;
        this.eventTimeFormat = createFormatter(options.eventTimeFormat || this.computeEventTimeFormat(), options.defaultRangeSeparator);
        displayEventTime = options.displayEventTime;

        if (displayEventTime == null) {
          displayEventTime = this.computeDisplayEventTime(); // might be based off of range
        }

        displayEventEnd = options.displayEventEnd;

        if (displayEventEnd == null) {
          displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
        }

        this.displayEventTime = displayEventTime;
        this.displayEventEnd = displayEventEnd;
      }; // Renders and assigns an `el` property for each foreground event segment.
      // Only returns segments that successfully rendered.


      FgEventRenderer.prototype.renderSegEls = function (segs, mirrorInfo) {
        var html = '';
        var i;

        if (segs.length) {
          // don't build an empty html string
          // build a large concatenation of event segment HTML
          for (i = 0; i < segs.length; i++) {
            html += this.renderSegHtml(segs[i], mirrorInfo);
          } // Grab individual elements from the combined HTML string. Use each as the default rendering.
          // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.


          htmlToElements(html).forEach(function (el, i) {
            var seg = segs[i];

            if (el) {
              seg.el = el;
            }
          });
          segs = filterSegsViaEls(this.context, segs, Boolean(mirrorInfo));
        }

        return segs;
      }; // Generic utility for generating the HTML classNames for an event segment's element


      FgEventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable, mirrorInfo) {
        var classes = ['fc-event', seg.isStart ? 'fc-start' : 'fc-not-start', seg.isEnd ? 'fc-end' : 'fc-not-end'].concat(seg.eventRange.ui.classNames);

        if (isDraggable) {
          classes.push('fc-draggable');
        }

        if (isResizable) {
          classes.push('fc-resizable');
        }

        if (mirrorInfo) {
          classes.push('fc-mirror');

          if (mirrorInfo.isDragging) {
            classes.push('fc-dragging');
          }

          if (mirrorInfo.isResizing) {
            classes.push('fc-resizing');
          }
        }

        return classes;
      }; // Compute the text that should be displayed on an event's element.
      // `range` can be the Event object itself, or something range-like, with at least a `start`.
      // If event times are disabled, or the event has no time, will return a blank string.
      // If not specified, formatter will default to the eventTimeFormat setting,
      // and displayEnd will default to the displayEventEnd setting.


      FgEventRenderer.prototype.getTimeText = function (eventRange, formatter, displayEnd) {
        var def = eventRange.def,
            instance = eventRange.instance;
        return this._getTimeText(instance.range.start, def.hasEnd ? instance.range.end : null, def.allDay, formatter, displayEnd, instance.forcedStartTzo, instance.forcedEndTzo);
      };

      FgEventRenderer.prototype._getTimeText = function (start, end, allDay, formatter, displayEnd, forcedStartTzo, forcedEndTzo) {
        var dateEnv = this.context.dateEnv;

        if (formatter == null) {
          formatter = this.eventTimeFormat;
        }

        if (displayEnd == null) {
          displayEnd = this.displayEventEnd;
        }

        if (this.displayEventTime && !allDay) {
          if (displayEnd && end) {
            return dateEnv.formatRange(start, end, formatter, {
              forcedStartTzo: forcedStartTzo,
              forcedEndTzo: forcedEndTzo
            });
          } else {
            return dateEnv.format(start, formatter, {
              forcedTzo: forcedStartTzo
            });
          }
        }

        return '';
      };

      FgEventRenderer.prototype.computeEventTimeFormat = function () {
        return {
          hour: 'numeric',
          minute: '2-digit',
          omitZeroMinute: true
        };
      };

      FgEventRenderer.prototype.computeDisplayEventTime = function () {
        return true;
      };

      FgEventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
      }; // Utility for generating event skin-related CSS properties


      FgEventRenderer.prototype.getSkinCss = function (ui) {
        return {
          'background-color': ui.backgroundColor,
          'border-color': ui.borderColor,
          color: ui.textColor
        };
      };

      FgEventRenderer.prototype.sortEventSegs = function (segs) {
        var specs = this.context.eventOrderSpecs;
        var objs = segs.map(buildSegCompareObj);
        objs.sort(function (obj0, obj1) {
          return compareByFieldSpecs(obj0, obj1, specs);
        });
        return objs.map(function (c) {
          return c._seg;
        });
      };

      FgEventRenderer.prototype.computeSizes = function (force) {
        if (force || this.isSizeDirty) {
          this.computeSegSizes(this.segs);
        }
      };

      FgEventRenderer.prototype.assignSizes = function (force) {
        if (force || this.isSizeDirty) {
          this.assignSegSizes(this.segs);
          this.isSizeDirty = false;
        }
      };

      FgEventRenderer.prototype.computeSegSizes = function (segs) {};

      FgEventRenderer.prototype.assignSegSizes = function (segs) {}; // Manipulation on rendered segs


      FgEventRenderer.prototype.hideByHash = function (hash) {
        if (hash) {
          for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
            var seg = _a[_i];

            if (hash[seg.eventRange.instance.instanceId]) {
              seg.el.style.visibility = 'hidden';
            }
          }
        }
      };

      FgEventRenderer.prototype.showByHash = function (hash) {
        if (hash) {
          for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
            var seg = _a[_i];

            if (hash[seg.eventRange.instance.instanceId]) {
              seg.el.style.visibility = '';
            }
          }
        }
      };

      FgEventRenderer.prototype.selectByInstanceId = function (instanceId) {
        if (instanceId) {
          for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
            var seg = _a[_i];
            var eventInstance = seg.eventRange.instance;

            if (eventInstance && eventInstance.instanceId === instanceId && seg.el // necessary?
            ) {
              seg.el.classList.add('fc-selected');
            }
          }
        }
      };

      FgEventRenderer.prototype.unselectByInstanceId = function (instanceId) {
        if (instanceId) {
          for (var _i = 0, _a = this.segs; _i < _a.length; _i++) {
            var seg = _a[_i];

            if (seg.el) {
              // necessary?
              seg.el.classList.remove('fc-selected');
            }
          }
        }
      };

      return FgEventRenderer;
    }(); // returns a object with all primitive props that can be compared


    function buildSegCompareObj(seg) {
      var eventDef = seg.eventRange.def;
      var range = seg.eventRange.instance.range;
      var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events

      var end = range.end ? range.end.valueOf() : 0; // "

      return _assign({}, eventDef.extendedProps, eventDef, {
        id: eventDef.publicId,
        start: start,
        end: end,
        duration: end - start,
        allDay: Number(eventDef.allDay),
        _seg: seg // for later retrieval

      });
    }
    /*
    TODO: when refactoring this class, make a new FillRenderer instance for each `type`
    */


    var FillRenderer =
    /** @class */
    function () {
      function FillRenderer() {
        this.fillSegTag = 'div';
        this.dirtySizeFlags = {};
        this.containerElsByType = {};
        this.segsByType = {};
      }

      FillRenderer.prototype.getSegsByType = function (type) {
        return this.segsByType[type] || [];
      };

      FillRenderer.prototype.renderSegs = function (type, context, segs) {
        var _a;

        this.context = context;
        var renderedSegs = this.renderSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

        var containerEls = this.attachSegs(type, renderedSegs);

        if (containerEls) {
          (_a = this.containerElsByType[type] || (this.containerElsByType[type] = [])).push.apply(_a, containerEls);
        }

        this.segsByType[type] = renderedSegs;

        if (type === 'bgEvent') {
          triggerRenderedSegs(context, renderedSegs, false); // isMirror=false
        }

        this.dirtySizeFlags[type] = true;
      }; // Unrenders a specific type of fill that is currently rendered on the grid


      FillRenderer.prototype.unrender = function (type, context) {
        var segs = this.segsByType[type];

        if (segs) {
          if (type === 'bgEvent') {
            triggerWillRemoveSegs(context, segs, false); // isMirror=false
          }

          this.detachSegs(type, segs);
        }
      }; // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
      // Only returns segments that successfully rendered.


      FillRenderer.prototype.renderSegEls = function (type, segs) {
        var _this = this;

        var html = '';
        var i;

        if (segs.length) {
          // build a large concatenation of segment HTML
          for (i = 0; i < segs.length; i++) {
            html += this.renderSegHtml(type, segs[i]);
          } // Grab individual elements from the combined HTML string. Use each as the default rendering.
          // Then, compute the 'el' for each segment.


          htmlToElements(html).forEach(function (el, i) {
            var seg = segs[i];

            if (el) {
              seg.el = el;
            }
          });

          if (type === 'bgEvent') {
            segs = filterSegsViaEls(this.context, segs, false // isMirror. background events can never be mirror elements
            );
          } // correct element type? (would be bad if a non-TD were inserted into a table for example)


          segs = segs.filter(function (seg) {
            return elementMatches(seg.el, _this.fillSegTag);
          });
        }

        return segs;
      }; // Builds the HTML needed for one fill segment. Generic enough to work with different types.


      FillRenderer.prototype.renderSegHtml = function (type, seg) {
        var css = null;
        var classNames = [];

        if (type !== 'highlight' && type !== 'businessHours') {
          css = {
            'background-color': seg.eventRange.ui.backgroundColor
          };
        }

        if (type !== 'highlight') {
          classNames = classNames.concat(seg.eventRange.ui.classNames);
        }

        if (type === 'businessHours') {
          classNames.push('fc-bgevent');
        } else {
          classNames.push('fc-' + type.toLowerCase());
        }

        return '<' + this.fillSegTag + (classNames.length ? ' class="' + classNames.join(' ') + '"' : '') + (css ? ' style="' + cssToStr(css) + '"' : '') + '></' + this.fillSegTag + '>';
      };

      FillRenderer.prototype.detachSegs = function (type, segs) {
        var containerEls = this.containerElsByType[type];

        if (containerEls) {
          containerEls.forEach(removeElement);
          delete this.containerElsByType[type];
        }
      };

      FillRenderer.prototype.computeSizes = function (force) {
        for (var type in this.segsByType) {
          if (force || this.dirtySizeFlags[type]) {
            this.computeSegSizes(this.segsByType[type]);
          }
        }
      };

      FillRenderer.prototype.assignSizes = function (force) {
        for (var type in this.segsByType) {
          if (force || this.dirtySizeFlags[type]) {
            this.assignSegSizes(this.segsByType[type]);
          }
        }

        this.dirtySizeFlags = {};
      };

      FillRenderer.prototype.computeSegSizes = function (segs) {};

      FillRenderer.prototype.assignSegSizes = function (segs) {};

      return FillRenderer;
    }();

    var NamedTimeZoneImpl =
    /** @class */
    function () {
      function NamedTimeZoneImpl(timeZoneName) {
        this.timeZoneName = timeZoneName;
      }

      return NamedTimeZoneImpl;
    }();
    /*
    An abstraction for a dragging interaction originating on an event.
    Does higher-level things than PointerDragger, such as possibly:
    - a "mirror" that moves with the pointer
    - a minimum number of pixels or other criteria for a true drag to begin
    
    subclasses must emit:
    - pointerdown
    - dragstart
    - dragmove
    - pointerup
    - dragend
    */


    var ElementDragging =
    /** @class */
    function () {
      function ElementDragging(el) {
        this.emitter = new EmitterMixin();
      }

      ElementDragging.prototype.destroy = function () {};

      ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror
      };

      ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror
      };

      ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional
      };

      return ElementDragging;
    }();

    function formatDate(dateInput, settings) {
      if (settings === void 0) {
        settings = {};
      }

      var dateEnv = buildDateEnv$1(settings);
      var formatter = createFormatter(settings);
      var dateMeta = dateEnv.createMarkerMeta(dateInput);

      if (!dateMeta) {
        // TODO: warning?
        return '';
      }

      return dateEnv.format(dateMeta.marker, formatter, {
        forcedTzo: dateMeta.forcedTzo
      });
    }

    function formatRange(startInput, endInput, settings // mixture of env and formatter settings
    ) {
      var dateEnv = buildDateEnv$1(typeof settings === 'object' && settings ? settings : {}); // pass in if non-null object

      var formatter = createFormatter(settings, globalDefaults.defaultRangeSeparator);
      var startMeta = dateEnv.createMarkerMeta(startInput);
      var endMeta = dateEnv.createMarkerMeta(endInput);

      if (!startMeta || !endMeta) {
        // TODO: warning?
        return '';
      }

      return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {
        forcedStartTzo: startMeta.forcedTzo,
        forcedEndTzo: endMeta.forcedTzo,
        isEndExclusive: settings.isEndExclusive
      });
    } // TODO: more DRY and optimized


    function buildDateEnv$1(settings) {
      var locale = buildLocale(settings.locale || 'en', parseRawLocales([]).map); // TODO: don't hardcode 'en' everywhere
      // ensure required settings

      settings = _assign({
        timeZone: globalDefaults.timeZone,
        calendarSystem: 'gregory'
      }, settings, {
        locale: locale
      });
      return new DateEnv(settings);
    }

    var DRAG_META_PROPS = {
      startTime: createDuration,
      duration: createDuration,
      create: Boolean,
      sourceId: String
    };
    var DRAG_META_DEFAULTS = {
      create: true
    };

    function parseDragMeta(raw) {
      var leftoverProps = {};
      var refined = refineProps(raw, DRAG_META_PROPS, DRAG_META_DEFAULTS, leftoverProps);
      refined.leftoverProps = leftoverProps;
      return refined;
    } // Computes a default column header formatting string if `colFormat` is not explicitly defined


    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
      // if more than one week row, or if there are a lot of columns with not much space,
      // put just the day numbers will be in each cell
      if (!datesRepDistinctDays || dayCnt > 10) {
        return {
          weekday: 'short'
        }; // "Sat"
      } else if (dayCnt > 1) {
        return {
          weekday: 'short',
          month: 'numeric',
          day: 'numeric',
          omitCommas: true
        }; // "Sat 11/12"
      } else {
        return {
          weekday: 'long'
        }; // "Saturday"
      }
    }

    function renderDateCell(dateMarker, dateProfile, datesRepDistinctDays, colCnt, colHeadFormat, context, colspan, otherAttrs) {
      var dateEnv = context.dateEnv,
          theme = context.theme,
          options = context.options;
      var isDateValid = rangeContainsMarker(dateProfile.activeRange, dateMarker); // TODO: called too frequently. cache somehow.

      var classNames = ['fc-day-header', theme.getClass('widgetHeader')];
      var innerHtml;

      if (typeof options.columnHeaderHtml === 'function') {
        innerHtml = options.columnHeaderHtml(dateEnv.toDate(dateMarker));
      } else if (typeof options.columnHeaderText === 'function') {
        innerHtml = htmlEscape(options.columnHeaderText(dateEnv.toDate(dateMarker)));
      } else {
        innerHtml = htmlEscape(dateEnv.format(dateMarker, colHeadFormat));
      } // if only one row of days, the classNames on the header can represent the specific days beneath


      if (datesRepDistinctDays) {
        classNames = classNames.concat( // includes the day-of-week class
        // noThemeHighlight=true (don't highlight the header)
        getDayClasses(dateMarker, dateProfile, context, true));
      } else {
        classNames.push('fc-' + DAY_IDS[dateMarker.getUTCDay()]); // only add the day-of-week class
      }

      return '' + '<th class="' + classNames.join(' ') + '"' + (isDateValid && datesRepDistinctDays ? ' data-date="' + dateEnv.formatIso(dateMarker, {
        omitTime: true
      }) + '"' : '') + (colspan > 1 ? ' colspan="' + colspan + '"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '>' + (isDateValid ? // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
      buildGotoAnchorHtml(options, dateEnv, {
        date: dateMarker,
        forceOff: !datesRepDistinctDays || colCnt === 1
      }, innerHtml) : // if not valid, display text, but no link
      innerHtml) + '</th>';
    }

    var DayHeader =
    /** @class */
    function (_super) {
      __extends(DayHeader, _super);

      function DayHeader(parentEl) {
        var _this = _super.call(this) || this;

        _this.renderSkeleton = memoizeRendering(_this._renderSkeleton, _this._unrenderSkeleton);
        _this.parentEl = parentEl;
        return _this;
      }

      DayHeader.prototype.render = function (props, context) {
        var dates = props.dates,
            datesRepDistinctDays = props.datesRepDistinctDays;
        var parts = [];
        this.renderSkeleton(context);

        if (props.renderIntroHtml) {
          parts.push(props.renderIntroHtml());
        }

        var colHeadFormat = createFormatter(context.options.columnHeaderFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dates.length));

        for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {
          var date = dates_1[_i];
          parts.push(renderDateCell(date, props.dateProfile, datesRepDistinctDays, dates.length, colHeadFormat, context));
        }

        if (context.isRtl) {
          parts.reverse();
        }

        this.thead.innerHTML = '<tr>' + parts.join('') + '</tr>';
      };

      DayHeader.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.renderSkeleton.unrender();
      };

      DayHeader.prototype._renderSkeleton = function (context) {
        var theme = context.theme;
        var parentEl = this.parentEl;
        parentEl.innerHTML = ''; // because might be nbsp

        parentEl.appendChild(this.el = htmlToElement('<div class="fc-row ' + theme.getClass('headerRow') + '">' + '<table class="' + theme.getClass('tableGrid') + '">' + '<thead></thead>' + '</table>' + '</div>'));
        this.thead = this.el.querySelector('thead');
      };

      DayHeader.prototype._unrenderSkeleton = function () {
        removeElement(this.el);
      };

      return DayHeader;
    }(Component);

    var DaySeries =
    /** @class */
    function () {
      function DaySeries(range, dateProfileGenerator) {
        var date = range.start;
        var end = range.end;
        var indices = [];
        var dates = [];
        var dayIndex = -1;

        while (date < end) {
          // loop each day from start to end
          if (dateProfileGenerator.isHiddenDay(date)) {
            indices.push(dayIndex + 0.5); // mark that it's between indices
          } else {
            dayIndex++;
            indices.push(dayIndex);
            dates.push(date);
          }

          date = addDays(date, 1);
        }

        this.dates = dates;
        this.indices = indices;
        this.cnt = dates.length;
      }

      DaySeries.prototype.sliceRange = function (range) {
        var firstIndex = this.getDateDayIndex(range.start); // inclusive first index

        var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index

        var clippedFirstIndex = Math.max(0, firstIndex);
        var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices

        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell

        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell

        if (clippedFirstIndex <= clippedLastIndex) {
          return {
            firstIndex: clippedFirstIndex,
            lastIndex: clippedLastIndex,
            isStart: firstIndex === clippedFirstIndex,
            isEnd: lastIndex === clippedLastIndex
          };
        } else {
          return null;
        }
      }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.
      // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
      // If before the first offset, returns a negative number.
      // If after the last offset, returns an offset past the last cell offset.
      // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.


      DaySeries.prototype.getDateDayIndex = function (date) {
        var indices = this.indices;
        var dayOffset = Math.floor(diffDays(this.dates[0], date));

        if (dayOffset < 0) {
          return indices[0] - 1;
        } else if (dayOffset >= indices.length) {
          return indices[indices.length - 1] + 1;
        } else {
          return indices[dayOffset];
        }
      };

      return DaySeries;
    }();

    var DayTable =
    /** @class */
    function () {
      function DayTable(daySeries, breakOnWeeks) {
        var dates = daySeries.dates;
        var daysPerRow;
        var firstDay;
        var rowCnt;

        if (breakOnWeeks) {
          // count columns until the day-of-week repeats
          firstDay = dates[0].getUTCDay();

          for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow++) {
            if (dates[daysPerRow].getUTCDay() === firstDay) {
              break;
            }
          }

          rowCnt = Math.ceil(dates.length / daysPerRow);
        } else {
          rowCnt = 1;
          daysPerRow = dates.length;
        }

        this.rowCnt = rowCnt;
        this.colCnt = daysPerRow;
        this.daySeries = daySeries;
        this.cells = this.buildCells();
        this.headerDates = this.buildHeaderDates();
      }

      DayTable.prototype.buildCells = function () {
        var rows = [];

        for (var row = 0; row < this.rowCnt; row++) {
          var cells = [];

          for (var col = 0; col < this.colCnt; col++) {
            cells.push(this.buildCell(row, col));
          }

          rows.push(cells);
        }

        return rows;
      };

      DayTable.prototype.buildCell = function (row, col) {
        return {
          date: this.daySeries.dates[row * this.colCnt + col]
        };
      };

      DayTable.prototype.buildHeaderDates = function () {
        var dates = [];

        for (var col = 0; col < this.colCnt; col++) {
          dates.push(this.cells[0][col].date);
        }

        return dates;
      };

      DayTable.prototype.sliceRange = function (range) {
        var colCnt = this.colCnt;
        var seriesSeg = this.daySeries.sliceRange(range);
        var segs = [];

        if (seriesSeg) {
          var firstIndex = seriesSeg.firstIndex,
              lastIndex = seriesSeg.lastIndex;
          var index = firstIndex;

          while (index <= lastIndex) {
            var row = Math.floor(index / colCnt);
            var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
            segs.push({
              row: row,
              firstCol: index % colCnt,
              lastCol: (nextIndex - 1) % colCnt,
              isStart: seriesSeg.isStart && index === firstIndex,
              isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
            });
            index = nextIndex;
          }
        }

        return segs;
      };

      return DayTable;
    }();

    var Slicer =
    /** @class */
    function () {
      function Slicer() {
        this.sliceBusinessHours = memoize(this._sliceBusinessHours);
        this.sliceDateSelection = memoize(this._sliceDateSpan);
        this.sliceEventStore = memoize(this._sliceEventStore);
        this.sliceEventDrag = memoize(this._sliceInteraction);
        this.sliceEventResize = memoize(this._sliceInteraction);
      }

      Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, calendar, component) {
        var extraArgs = [];

        for (var _i = 5; _i < arguments.length; _i++) {
          extraArgs[_i - 5] = arguments[_i];
        }

        var eventUiBases = props.eventUiBases;
        var eventSegs = this.sliceEventStore.apply(this, [props.eventStore, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs));
        return {
          dateSelectionSegs: this.sliceDateSelection.apply(this, [props.dateSelection, eventUiBases, component].concat(extraArgs)),
          businessHourSegs: this.sliceBusinessHours.apply(this, [props.businessHours, dateProfile, nextDayThreshold, calendar, component].concat(extraArgs)),
          fgEventSegs: eventSegs.fg,
          bgEventSegs: eventSegs.bg,
          eventDrag: this.sliceEventDrag.apply(this, [props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),
          eventResize: this.sliceEventResize.apply(this, [props.eventResize, eventUiBases, dateProfile, nextDayThreshold, component].concat(extraArgs)),
          eventSelection: props.eventSelection
        }; // TODO: give interactionSegs?
      };

      Slicer.prototype.sliceNowDate = function ( // does not memoize
      date, component) {
        var extraArgs = [];

        for (var _i = 2; _i < arguments.length; _i++) {
          extraArgs[_i - 2] = arguments[_i];
        }

        return this._sliceDateSpan.apply(this, [{
          range: {
            start: date,
            end: addMs(date, 1)
          },
          allDay: false
        }, {}, component].concat(extraArgs));
      };

      Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, calendar, component) {
        var extraArgs = [];

        for (var _i = 5; _i < arguments.length; _i++) {
          extraArgs[_i - 5] = arguments[_i];
        }

        if (!businessHours) {
          return [];
        }

        return this._sliceEventStore.apply(this, [expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), calendar), {}, dateProfile, nextDayThreshold, component].concat(extraArgs)).bg;
      };

      Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold, component) {
        var extraArgs = [];

        for (var _i = 5; _i < arguments.length; _i++) {
          extraArgs[_i - 5] = arguments[_i];
        }

        if (eventStore) {
          var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
          return {
            bg: this.sliceEventRanges(rangeRes.bg, component, extraArgs),
            fg: this.sliceEventRanges(rangeRes.fg, component, extraArgs)
          };
        } else {
          return {
            bg: [],
            fg: []
          };
        }
      };

      Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold, component) {
        var extraArgs = [];

        for (var _i = 5; _i < arguments.length; _i++) {
          extraArgs[_i - 5] = arguments[_i];
        }

        if (!interaction) {
          return null;
        }

        var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
        return {
          segs: this.sliceEventRanges(rangeRes.fg, component, extraArgs),
          affectedInstances: interaction.affectedEvents.instances,
          isEvent: interaction.isEvent,
          sourceSeg: interaction.origSeg
        };
      };

      Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, component) {
        var extraArgs = [];

        for (var _i = 3; _i < arguments.length; _i++) {
          extraArgs[_i - 3] = arguments[_i];
        }

        if (!dateSpan) {
          return [];
        }

        var eventRange = fabricateEventRange(dateSpan, eventUiBases, component.context.calendar);
        var segs = this.sliceRange.apply(this, [dateSpan.range].concat(extraArgs));

        for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {
          var seg = segs_1[_a];
          seg.component = component;
          seg.eventRange = eventRange;
        }

        return segs;
      };
      /*
      "complete" seg means it has component and eventRange
      */


      Slicer.prototype.sliceEventRanges = function (eventRanges, component, // TODO: kill
      extraArgs) {
        var segs = [];

        for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {
          var eventRange = eventRanges_1[_i];
          segs.push.apply(segs, this.sliceEventRange(eventRange, component, extraArgs));
        }

        return segs;
      };
      /*
      "complete" seg means it has component and eventRange
      */


      Slicer.prototype.sliceEventRange = function (eventRange, component, // TODO: kill
      extraArgs) {
        var segs = this.sliceRange.apply(this, [eventRange.range].concat(extraArgs));

        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
          var seg = segs_2[_i];
          seg.component = component;
          seg.eventRange = eventRange;
          seg.isStart = eventRange.isStart && seg.isStart;
          seg.isEnd = eventRange.isEnd && seg.isEnd;
        }

        return segs;
      };

      return Slicer;
    }();
    /*
    for incorporating minTime/maxTime if appropriate
    TODO: should be part of DateProfile!
    TimelineDateProfile already does this btw
    */


    function computeActiveRange(dateProfile, isComponentAllDay) {
      var range = dateProfile.activeRange;

      if (isComponentAllDay) {
        return range;
      }

      return {
        start: addMs(range.start, dateProfile.minTime.milliseconds),
        end: addMs(range.end, dateProfile.maxTime.milliseconds - 864e5) // 864e5 = ms in a day

      };
    } // exports
    // --------------------------------------------------------------------------------------------------


    var version = '4.4.2';
    /***/
  },

  /***/
  "./node_modules/@fullcalendar/daygrid/main.esm.js":
  /*!********************************************************!*\
    !*** ./node_modules/@fullcalendar/daygrid/main.esm.js ***!
    \********************************************************/

  /*! exports provided: default, AbstractDayGridView, DayBgRow, DayGrid, DayGridSlicer, DayGridView, SimpleDayGrid, buildBasicDayTable */

  /***/
  function node_modulesFullcalendarDaygridMainEsmJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AbstractDayGridView", function () {
      return AbstractDayGridView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DayBgRow", function () {
      return DayBgRow;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DayGrid", function () {
      return DayGrid;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DayGridSlicer", function () {
      return DayGridSlicer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DayGridView", function () {
      return DayGridView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SimpleDayGrid", function () {
      return SimpleDayGrid;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buildBasicDayTable", function () {
      return buildDayTable;
    });
    /* harmony import */


    var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @fullcalendar/core */
    "./node_modules/@fullcalendar/core/main.esm.js");
    /*!
    FullCalendar Day Grid Plugin v4.4.2
    Docs & License: https://fullcalendar.io/
    (c) 2019 Adam Shaw
    */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */


    var _extendStatics2 = function extendStatics(d, b) {
      _extendStatics2 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return _extendStatics2(d, b);
    };

    function __extends(d, b) {
      _extendStatics2(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign2 = function __assign() {
      _assign2 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return _assign2.apply(this, arguments);
    };

    var DayGridDateProfileGenerator =
    /** @class */
    function (_super) {
      __extends(DayGridDateProfileGenerator, _super);

      function DayGridDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
      } // Computes the date range that will be rendered.


      DayGridDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {
        var dateEnv = this.dateEnv;

        var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);

        var start = renderRange.start;
        var end = renderRange.end;
        var endOfWeek; // year and month views should be aligned with weeks. this is already done for week

        if (/^(year|month)$/.test(currentRangeUnit)) {
          start = dateEnv.startOfWeek(start); // make end-of-week if not already

          endOfWeek = dateEnv.startOfWeek(end);

          if (endOfWeek.valueOf() !== end.valueOf()) {
            end = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addWeeks"])(endOfWeek, 1);
          }
        } // ensure 6 weeks


        if (this.options.monthMode && this.options.fixedWeekCount) {
          var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["diffWeeks"])(start, end));
          end = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addWeeks"])(end, 6 - rowCnt);
        }

        return {
          start: start,
          end: end
        };
      };

      return DayGridDateProfileGenerator;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DateProfileGenerator"]);
    /* A rectangular panel that is absolutely positioned over other content
    ------------------------------------------------------------------------------------------------------------------------
    Options:
      - className (string)
      - content (HTML string, element, or element array)
      - parentEl
      - top
      - left
      - right (the x coord of where the right edge should be. not a "CSS" right)
      - autoHide (boolean)
      - show (callback)
      - hide (callback)
    */


    var Popover =
    /** @class */
    function () {
      function Popover(options) {
        var _this = this;

        this.isHidden = true;
        this.margin = 10; // the space required between the popover and the edges of the scroll container
        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature

        this.documentMousedown = function (ev) {
          // only hide the popover if the click happened outside the popover
          if (_this.el && !_this.el.contains(ev.target)) {
            _this.hide();
          }
        };

        this.options = options;
      } // Shows the popover on the specified position. Renders it if not already


      Popover.prototype.show = function () {
        if (this.isHidden) {
          if (!this.el) {
            this.render();
          }

          this.el.style.display = '';
          this.position();
          this.isHidden = false;
          this.trigger('show');
        }
      }; // Hides the popover, through CSS, but does not remove it from the DOM


      Popover.prototype.hide = function () {
        if (!this.isHidden) {
          this.el.style.display = 'none';
          this.isHidden = true;
          this.trigger('hide');
        }
      }; // Creates `this.el` and renders content inside of it


      Popover.prototype.render = function () {
        var _this = this;

        var options = this.options;
        var el = this.el = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', {
          className: 'fc-popover ' + (options.className || ''),
          style: {
            top: '0',
            left: '0'
          }
        });

        if (typeof options.content === 'function') {
          options.content(el);
        }

        options.parentEl.appendChild(el); // when a click happens on anything inside with a 'fc-close' className, hide the popover

        Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["listenBySelector"])(el, 'click', '.fc-close', function (ev) {
          _this.hide();
        });

        if (options.autoHide) {
          document.addEventListener('mousedown', this.documentMousedown);
        }
      }; // Hides and unregisters any handlers


      Popover.prototype.destroy = function () {
        this.hide();

        if (this.el) {
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"])(this.el);
          this.el = null;
        }

        document.removeEventListener('mousedown', this.documentMousedown);
      }; // Positions the popover optimally, using the top/left/right options


      Popover.prototype.position = function () {
        var options = this.options;
        var el = this.el;
        var elDims = el.getBoundingClientRect(); // only used for width,height

        var origin = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeRect"])(el.offsetParent);
        var clippingRect = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeClippingRect"])(options.parentEl);
        var top; // the "position" (not "offset") values for the popover

        var left; //
        // compute top and left

        top = options.top || 0;

        if (options.left !== undefined) {
          left = options.left;
        } else if (options.right !== undefined) {
          left = options.right - elDims.width; // derive the left value from the right value
        } else {
          left = 0;
        } // constrain to the view port. if constrained by two edges, give precedence to top/left


        top = Math.min(top, clippingRect.bottom - elDims.height - this.margin);
        top = Math.max(top, clippingRect.top + this.margin);
        left = Math.min(left, clippingRect.right - elDims.width - this.margin);
        left = Math.max(left, clippingRect.left + this.margin);
        Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(el, {
          top: top - origin.top,
          left: left - origin.left
        });
      }; // Triggers a callback. Calls a function in the option hash of the same name.
      // Arguments beyond the first `name` are forwarded on.
      // TODO: better code reuse for this. Repeat code
      // can kill this???


      Popover.prototype.trigger = function (name) {
        if (this.options[name]) {
          this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
        }
      };

      return Popover;
    }();
    /* Event-rendering methods for the DayGrid class
    ----------------------------------------------------------------------------------------------------------------------*/
    // "Simple" is bad a name. has nothing to do with SimpleDayGrid


    var SimpleDayGridEventRenderer =
    /** @class */
    function (_super) {
      __extends(SimpleDayGridEventRenderer, _super);

      function SimpleDayGridEventRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
      } // Builds the HTML to be used for the default element for an individual segment


      SimpleDayGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {
        var context = this.context;
        var eventRange = seg.eventRange;
        var eventDef = eventRange.def;
        var eventUi = eventRange.ui;
        var allDay = eventDef.allDay;
        var isDraggable = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeEventDraggable"])(context, eventDef, eventUi);
        var isResizableFromStart = allDay && seg.isStart && Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeEventStartResizable"])(context, eventDef, eventUi);
        var isResizableFromEnd = allDay && seg.isEnd && Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeEventEndResizable"])(context, eventDef, eventUi);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);
        var skinCss = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["cssToStr"])(this.getSkinCss(eventUi));
        var timeHtml = '';
        var timeText;
        var titleHtml;
        classes.unshift('fc-day-grid-event', 'fc-h-event'); // Only display a timed events time if it is the starting segment

        if (seg.isStart) {
          timeText = this.getTimeText(eventRange);

          if (timeText) {
            timeHtml = '<span class="fc-time">' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(timeText) + '</span>';
          }
        }

        titleHtml = '<span class="fc-title">' + (Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(eventDef.title || '') || '&nbsp;') + // we always want one line of height
        '</span>';
        return '<a class="' + classes.join(' ') + '"' + (eventDef.url ? ' href="' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(eventDef.url) + '"' : '') + (skinCss ? ' style="' + skinCss + '"' : '') + '>' + '<div class="fc-content">' + (context.options.dir === 'rtl' ? titleHtml + ' ' + timeHtml : // put a natural space in between
        timeHtml + ' ' + titleHtml //
        ) + '</div>' + (isResizableFromStart ? '<div class="fc-resizer fc-start-resizer"></div>' : '') + (isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer"></div>' : '') + '</a>';
      }; // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined


      SimpleDayGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return {
          hour: 'numeric',
          minute: '2-digit',
          omitZeroMinute: true,
          meridiem: 'narrow'
        };
      };

      SimpleDayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return false; // TODO: somehow consider the originating DayGrid's column count
      };

      return SimpleDayGridEventRenderer;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["FgEventRenderer"]);
    /* Event-rendering methods for the DayGrid class
    ----------------------------------------------------------------------------------------------------------------------*/


    var DayGridEventRenderer =
    /** @class */
    function (_super) {
      __extends(DayGridEventRenderer, _super);

      function DayGridEventRenderer(dayGrid) {
        var _this = _super.call(this) || this;

        _this.dayGrid = dayGrid;
        return _this;
      } // Renders the given foreground event segments onto the grid


      DayGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
        var rowStructs = this.rowStructs = this.renderSegRows(segs); // append to each row's content skeleton

        this.dayGrid.rowEls.forEach(function (rowNode, i) {
          rowNode.querySelector('.fc-content-skeleton > table').appendChild(rowStructs[i].tbodyEl);
        }); // removes the "more.." events popover

        if (!mirrorInfo) {
          this.dayGrid.removeSegPopover();
        }
      }; // Unrenders all currently rendered foreground event segments


      DayGridEventRenderer.prototype.detachSegs = function () {
        var rowStructs = this.rowStructs || [];
        var rowStruct;

        while (rowStruct = rowStructs.pop()) {
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"])(rowStruct.tbodyEl);
        }

        this.rowStructs = null;
      }; // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
      // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
      // PRECONDITION: each segment shoud already have a rendered and assigned `.el`


      DayGridEventRenderer.prototype.renderSegRows = function (segs) {
        var rowStructs = [];
        var segRows;
        var row;
        segRows = this.groupSegRows(segs); // group into nested arrays
        // iterate each row of segment groupings

        for (row = 0; row < segRows.length; row++) {
          rowStructs.push(this.renderSegRow(row, segRows[row]));
        }

        return rowStructs;
      }; // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
      // the segments. Returns object with a bunch of internal data about how the render was calculated.
      // NOTE: modifies rowSegs


      DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
        var isRtl = this.context.isRtl;
        var dayGrid = this.dayGrid;
        var colCnt = dayGrid.colCnt;
        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels

        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level

        var tbody = document.createElement('tbody');
        var segMatrix = []; // lookup for which segments are rendered into which level+col cells

        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix

        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column

        var i;
        var levelSegs;
        var col;
        var tr;
        var j;
        var seg;
        var td; // populates empty cells from the current column (`col`) to `endCol`

        function emptyCellsUntil(endCol) {
          while (col < endCol) {
            // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
            td = (loneCellMatrix[i - 1] || [])[col];

            if (td) {
              td.rowSpan = (td.rowSpan || 1) + 1;
            } else {
              td = document.createElement('td');
              tr.appendChild(td);
            }

            cellMatrix[i][col] = td;
            loneCellMatrix[i][col] = td;
            col++;
          }
        }

        for (i = 0; i < levelCnt; i++) {
          // iterate through all levels
          levelSegs = segLevels[i];
          col = 0;
          tr = document.createElement('tr');
          segMatrix.push([]);
          cellMatrix.push([]);
          loneCellMatrix.push([]); // levelCnt might be 1 even though there are no actual levels. protect against this.
          // this single empty row is useful for styling.

          if (levelSegs) {
            for (j = 0; j < levelSegs.length; j++) {
              // iterate through segments in level
              seg = levelSegs[j];
              var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;
              var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;
              emptyCellsUntil(leftCol); // create a container that occupies or more columns. append the event element.

              td = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('td', {
                className: 'fc-event-container'
              }, seg.el);

              if (leftCol !== rightCol) {
                td.colSpan = rightCol - leftCol + 1;
              } else {
                // a single-column segment
                loneCellMatrix[i][col] = td;
              }

              while (col <= rightCol) {
                cellMatrix[i][col] = td;
                segMatrix[i][col] = seg;
                col++;
              }

              tr.appendChild(td);
            }
          }

          emptyCellsUntil(colCnt); // finish off the row

          var introHtml = dayGrid.renderProps.renderIntroHtml();

          if (introHtml) {
            if (isRtl) {
              Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["appendToElement"])(tr, introHtml);
            } else {
              Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["prependToElement"])(tr, introHtml);
            }
          }

          tbody.appendChild(tr);
        }

        return {
          row: row,
          tbodyEl: tbody,
          cellMatrix: cellMatrix,
          segMatrix: segMatrix,
          segLevels: segLevels,
          segs: rowSegs
        };
      }; // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
      // NOTE: modifies segs


      DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
        var isRtl = this.context.isRtl;
        var colCnt = this.dayGrid.colCnt;
        var levels = [];
        var i;
        var seg;
        var j; // Give preference to elements with certain criteria, so they have
        // a chance to be closer to the top.

        segs = this.sortEventSegs(segs);

        for (i = 0; i < segs.length; i++) {
          seg = segs[i]; // loop through levels, starting with the topmost, until the segment doesn't collide with other segments

          for (j = 0; j < levels.length; j++) {
            if (!isDaySegCollision(seg, levels[j])) {
              break;
            }
          } // `j` now holds the desired subrow index


          seg.level = j;
          seg.leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol; // for sorting only

          seg.rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol // for sorting only
          ;
          (levels[j] || (levels[j] = [])).push(seg);
        } // order segments left-to-right. very important if calendar is RTL


        for (j = 0; j < levels.length; j++) {
          levels[j].sort(compareDaySegCols);
        }

        return levels;
      }; // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row


      DayGridEventRenderer.prototype.groupSegRows = function (segs) {
        var segRows = [];
        var i;

        for (i = 0; i < this.dayGrid.rowCnt; i++) {
          segRows.push([]);
        }

        for (i = 0; i < segs.length; i++) {
          segRows[segs[i].row].push(segs[i]);
        }

        return segRows;
      }; // Computes a default `displayEventEnd` value if one is not expliclty defined


      DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
      };

      return DayGridEventRenderer;
    }(SimpleDayGridEventRenderer); // Computes whether two segments' columns collide. They are assumed to be in the same row.


    function isDaySegCollision(seg, otherSegs) {
      var i;
      var otherSeg;

      for (i = 0; i < otherSegs.length; i++) {
        otherSeg = otherSegs[i];

        if (otherSeg.firstCol <= seg.lastCol && otherSeg.lastCol >= seg.firstCol) {
          return true;
        }
      }

      return false;
    } // A cmp function for determining the leftmost event


    function compareDaySegCols(a, b) {
      return a.leftCol - b.leftCol;
    }

    var DayGridMirrorRenderer =
    /** @class */
    function (_super) {
      __extends(DayGridMirrorRenderer, _super);

      function DayGridMirrorRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      DayGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
        var sourceSeg = mirrorInfo.sourceSeg;
        var rowStructs = this.rowStructs = this.renderSegRows(segs); // inject each new event skeleton into each associated row

        this.dayGrid.rowEls.forEach(function (rowNode, row) {
          var skeletonEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlToElement"])('<div class="fc-mirror-skeleton"><table></table></div>'); // will be absolutely positioned

          var skeletonTopEl;
          var skeletonTop; // If there is an original segment, match the top position. Otherwise, put it at the row's top level

          if (sourceSeg && sourceSeg.row === row) {
            skeletonTopEl = sourceSeg.el;
          } else {
            skeletonTopEl = rowNode.querySelector('.fc-content-skeleton tbody');

            if (!skeletonTopEl) {
              // when no events
              skeletonTopEl = rowNode.querySelector('.fc-content-skeleton table');
            }
          }

          skeletonTop = skeletonTopEl.getBoundingClientRect().top - rowNode.getBoundingClientRect().top; // the offsetParent origin

          skeletonEl.style.top = skeletonTop + 'px';
          skeletonEl.querySelector('table').appendChild(rowStructs[row].tbodyEl);
          rowNode.appendChild(skeletonEl);
        });
      };

      return DayGridMirrorRenderer;
    }(DayGridEventRenderer);

    var EMPTY_CELL_HTML = '<td style="pointer-events:none"></td>';

    var DayGridFillRenderer =
    /** @class */
    function (_super) {
      __extends(DayGridFillRenderer, _super);

      function DayGridFillRenderer(dayGrid) {
        var _this = _super.call(this) || this;

        _this.fillSegTag = 'td'; // override the default tag name

        _this.dayGrid = dayGrid;
        return _this;
      }

      DayGridFillRenderer.prototype.renderSegs = function (type, context, segs) {
        // don't render timed background events
        if (type === 'bgEvent') {
          segs = segs.filter(function (seg) {
            return seg.eventRange.def.allDay;
          });
        }

        _super.prototype.renderSegs.call(this, type, context, segs);
      };

      DayGridFillRenderer.prototype.attachSegs = function (type, segs) {
        var els = [];
        var i;
        var seg;
        var skeletonEl;

        for (i = 0; i < segs.length; i++) {
          seg = segs[i];
          skeletonEl = this.renderFillRow(type, seg);
          this.dayGrid.rowEls[seg.row].appendChild(skeletonEl);
          els.push(skeletonEl);
        }

        return els;
      }; // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.


      DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
        var dayGrid = this.dayGrid;
        var isRtl = this.context.isRtl;
        var colCnt = dayGrid.colCnt;
        var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;
        var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;
        var startCol = leftCol;
        var endCol = rightCol + 1;
        var className;
        var skeletonEl;
        var trEl;

        if (type === 'businessHours') {
          className = 'bgevent';
        } else {
          className = type.toLowerCase();
        }

        skeletonEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlToElement"])('<div class="fc-' + className + '-skeleton">' + '<table><tr></tr></table>' + '</div>');
        trEl = skeletonEl.getElementsByTagName('tr')[0];

        if (startCol > 0) {
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["appendToElement"])(trEl, // will create (startCol + 1) td's
          new Array(startCol + 1).join(EMPTY_CELL_HTML));
        }

        seg.el.colSpan = endCol - startCol;
        trEl.appendChild(seg.el);

        if (endCol < colCnt) {
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["appendToElement"])(trEl, // will create (colCnt - endCol) td's
          new Array(colCnt - endCol + 1).join(EMPTY_CELL_HTML));
        }

        var introHtml = dayGrid.renderProps.renderIntroHtml();

        if (introHtml) {
          if (isRtl) {
            Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["appendToElement"])(trEl, introHtml);
          } else {
            Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["prependToElement"])(trEl, introHtml);
          }
        }

        return skeletonEl;
      };

      return DayGridFillRenderer;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["FillRenderer"]);

    var DayTile =
    /** @class */
    function (_super) {
      __extends(DayTile, _super);

      function DayTile(el) {
        var _this = _super.call(this, el) || this;

        var eventRenderer = _this.eventRenderer = new DayTileEventRenderer(_this);
        var renderFrame = _this.renderFrame = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderFrame);
        _this.renderFgEvents = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderFrame]);
        _this.renderEventSelection = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
        _this.renderEventDrag = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);
        _this.renderEventResize = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.hideByHash.bind(eventRenderer), eventRenderer.showByHash.bind(eventRenderer), [renderFrame]);
        return _this;
      }

      DayTile.prototype.firstContext = function (context) {
        context.calendar.registerInteractiveComponent(this, {
          el: this.el,
          useEventCenter: false
        });
      };

      DayTile.prototype.render = function (props, context) {
        this.renderFrame(props.date);
        this.renderFgEvents(context, props.fgSegs);
        this.renderEventSelection(props.eventSelection);
        this.renderEventDrag(props.eventDragInstances);
        this.renderEventResize(props.eventResizeInstances);
      };

      DayTile.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.renderFrame.unrender(); // should unrender everything else

        this.context.calendar.unregisterInteractiveComponent(this);
      };

      DayTile.prototype._renderFrame = function (date) {
        var _a = this.context,
            theme = _a.theme,
            dateEnv = _a.dateEnv,
            options = _a.options;
        var title = dateEnv.format(date, Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])(options.dayPopoverFormat) // TODO: cache
        );
        this.el.innerHTML = '<div class="fc-header ' + theme.getClass('popoverHeader') + '">' + '<span class="fc-title">' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(title) + '</span>' + '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' + '</div>' + '<div class="fc-body ' + theme.getClass('popoverContent') + '">' + '<div class="fc-event-container"></div>' + '</div>';
        this.segContainerEl = this.el.querySelector('.fc-event-container');
      };

      DayTile.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {
        var date = this.props.date; // HACK

        if (positionLeft < elWidth && positionTop < elHeight) {
          return {
            component: this,
            dateSpan: {
              allDay: true,
              range: {
                start: date,
                end: Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addDays"])(date, 1)
              }
            },
            dayEl: this.el,
            rect: {
              left: 0,
              top: 0,
              right: elWidth,
              bottom: elHeight
            },
            layer: 1
          };
        }
      };

      return DayTile;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DateComponent"]);

    var DayTileEventRenderer =
    /** @class */
    function (_super) {
      __extends(DayTileEventRenderer, _super);

      function DayTileEventRenderer(dayTile) {
        var _this = _super.call(this) || this;

        _this.dayTile = dayTile;
        return _this;
      }

      DayTileEventRenderer.prototype.attachSegs = function (segs) {
        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
          var seg = segs_1[_i];
          this.dayTile.segContainerEl.appendChild(seg.el);
        }
      };

      DayTileEventRenderer.prototype.detachSegs = function (segs) {
        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {
          var seg = segs_2[_i];
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"])(seg.el);
        }
      };

      return DayTileEventRenderer;
    }(SimpleDayGridEventRenderer);

    var DayBgRow =
    /** @class */
    function () {
      function DayBgRow(context) {
        this.context = context;
      }

      DayBgRow.prototype.renderHtml = function (props) {
        var parts = [];

        if (props.renderIntroHtml) {
          parts.push(props.renderIntroHtml());
        }

        for (var _i = 0, _a = props.cells; _i < _a.length; _i++) {
          var cell = _a[_i];
          parts.push(renderCellHtml(cell.date, props.dateProfile, this.context, cell.htmlAttrs));
        }

        if (!props.cells.length) {
          parts.push('<td class="fc-day ' + this.context.theme.getClass('widgetContent') + '"></td>');
        }

        if (this.context.options.dir === 'rtl') {
          parts.reverse();
        }

        return '<tr>' + parts.join('') + '</tr>';
      };

      return DayBgRow;
    }();

    function renderCellHtml(date, dateProfile, context, otherAttrs) {
      var dateEnv = context.dateEnv,
          theme = context.theme;
      var isDateValid = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["rangeContainsMarker"])(dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.

      var classes = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["getDayClasses"])(date, dateProfile, context);
      classes.unshift('fc-day', theme.getClass('widgetContent'));
      return '<td class="' + classes.join(' ') + '"' + (isDateValid ? ' data-date="' + dateEnv.formatIso(date, {
        omitTime: true
      }) + '"' : '') + (otherAttrs ? ' ' + otherAttrs : '') + '></td>';
    }

    var DAY_NUM_FORMAT = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])({
      day: 'numeric'
    });
    var WEEK_NUM_FORMAT = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])({
      week: 'numeric'
    });

    var DayGrid =
    /** @class */
    function (_super) {
      __extends(DayGrid, _super);

      function DayGrid(el, renderProps) {
        var _this = _super.call(this, el) || this;

        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid

        _this.isCellSizesDirty = false;
        _this.renderProps = renderProps;
        var eventRenderer = _this.eventRenderer = new DayGridEventRenderer(_this);
        var fillRenderer = _this.fillRenderer = new DayGridFillRenderer(_this);
        _this.mirrorRenderer = new DayGridMirrorRenderer(_this);
        var renderCells = _this.renderCells = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderCells, _this._unrenderCells);
        _this.renderBusinessHours = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderCells]);
        _this.renderDateSelection = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'), [renderCells]);
        _this.renderBgEvents = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderCells]);
        _this.renderFgEvents = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderCells]);
        _this.renderEventSelection = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
        _this.renderEventDrag = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderEventDrag, _this._unrenderEventDrag, [renderCells]);
        _this.renderEventResize = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderEventResize, _this._unrenderEventResize, [renderCells]);
        return _this;
      }

      DayGrid.prototype.render = function (props, context) {
        var cells = props.cells;
        this.rowCnt = cells.length;
        this.colCnt = cells[0].length;
        this.renderCells(cells, props.isRigid);
        this.renderBusinessHours(context, props.businessHourSegs);
        this.renderDateSelection(context, props.dateSelectionSegs);
        this.renderBgEvents(context, props.bgEventSegs);
        this.renderFgEvents(context, props.fgEventSegs);
        this.renderEventSelection(props.eventSelection);
        this.renderEventDrag(props.eventDrag);
        this.renderEventResize(props.eventResize);

        if (this.segPopoverTile) {
          this.updateSegPopoverTile();
        }
      };

      DayGrid.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.renderCells.unrender(); // will unrender everything else
      };

      DayGrid.prototype.getCellRange = function (row, col) {
        var start = this.props.cells[row][col].date;
        var end = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addDays"])(start, 1);
        return {
          start: start,
          end: end
        };
      };

      DayGrid.prototype.updateSegPopoverTile = function (date, segs) {
        var ownProps = this.props;
        this.segPopoverTile.receiveProps({
          date: date || this.segPopoverTile.props.date,
          fgSegs: segs || this.segPopoverTile.props.fgSegs,
          eventSelection: ownProps.eventSelection,
          eventDragInstances: ownProps.eventDrag ? ownProps.eventDrag.affectedInstances : null,
          eventResizeInstances: ownProps.eventResize ? ownProps.eventResize.affectedInstances : null
        }, this.context);
      };
      /* Date Rendering
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype._renderCells = function (cells, isRigid) {
        var _a = this.context,
            calendar = _a.calendar,
            view = _a.view,
            isRtl = _a.isRtl,
            dateEnv = _a.dateEnv;

        var _b = this,
            rowCnt = _b.rowCnt,
            colCnt = _b.colCnt;

        var html = '';
        var row;
        var col;

        for (row = 0; row < rowCnt; row++) {
          html += this.renderDayRowHtml(row, isRigid);
        }

        this.el.innerHTML = html;
        this.rowEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.el, '.fc-row');
        this.cellEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.el, '.fc-day, .fc-disabled-day');

        if (isRtl) {
          this.cellEls.reverse();
        }

        this.rowPositions = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["PositionCache"](this.el, this.rowEls, false, true // vertical
        );
        this.colPositions = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["PositionCache"](this.el, this.cellEls.slice(0, colCnt), // only the first row
        true, false // horizontal
        ); // trigger dayRender with each cell's element

        for (row = 0; row < rowCnt; row++) {
          for (col = 0; col < colCnt; col++) {
            calendar.publiclyTrigger('dayRender', [{
              date: dateEnv.toDate(cells[row][col].date),
              el: this.getCellEl(row, col),
              view: view
            }]);
          }
        }

        this.isCellSizesDirty = true;
      };

      DayGrid.prototype._unrenderCells = function () {
        this.removeSegPopover();
      }; // Generates the HTML for a single row, which is a div that wraps a table.
      // `row` is the row number.


      DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
        var theme = this.context.theme;
        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];

        if (isRigid) {
          classes.push('fc-rigid');
        }

        var bgRow = new DayBgRow(this.context);
        return '' + '<div class="' + classes.join(' ') + '">' + '<div class="fc-bg">' + '<table class="' + theme.getClass('tableGrid') + '">' + bgRow.renderHtml({
          cells: this.props.cells[row],
          dateProfile: this.props.dateProfile,
          renderIntroHtml: this.renderProps.renderBgIntroHtml
        }) + '</table>' + '</div>' + '<div class="fc-content-skeleton">' + '<table>' + (this.getIsNumbersVisible() ? '<thead>' + this.renderNumberTrHtml(row) + '</thead>' : '') + '</table>' + '</div>' + '</div>';
      };

      DayGrid.prototype.getIsNumbersVisible = function () {
        return this.getIsDayNumbersVisible() || this.renderProps.cellWeekNumbersVisible || this.renderProps.colWeekNumbersVisible;
      };

      DayGrid.prototype.getIsDayNumbersVisible = function () {
        return this.rowCnt > 1;
      };
      /* Grid Number Rendering
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype.renderNumberTrHtml = function (row) {
        var isRtl = this.context.isRtl;
        var intro = this.renderProps.renderNumberIntroHtml(row, this);
        return '' + '<tr>' + (isRtl ? '' : intro) + this.renderNumberCellsHtml(row) + (isRtl ? intro : '') + '</tr>';
      };

      DayGrid.prototype.renderNumberCellsHtml = function (row) {
        var htmls = [];
        var col;
        var date;

        for (col = 0; col < this.colCnt; col++) {
          date = this.props.cells[row][col].date;
          htmls.push(this.renderNumberCellHtml(date));
        }

        if (this.context.isRtl) {
          htmls.reverse();
        }

        return htmls.join('');
      }; // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
      // The number row will only exist if either day numbers or week numbers are turned on.


      DayGrid.prototype.renderNumberCellHtml = function (date) {
        var _a = this.context,
            dateEnv = _a.dateEnv,
            options = _a.options;
        var html = '';
        var isDateValid = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["rangeContainsMarker"])(this.props.dateProfile.activeRange, date); // TODO: called too frequently. cache somehow.

        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
        var classes;
        var weekCalcFirstDow;

        if (!isDayNumberVisible && !this.renderProps.cellWeekNumbersVisible) {
          // no numbers in day cell (week number must be along the side)
          return '<td></td>'; //  will create an empty space above events :(
        }

        classes = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["getDayClasses"])(date, this.props.dateProfile, this.context);
        classes.unshift('fc-day-top');

        if (this.renderProps.cellWeekNumbersVisible) {
          weekCalcFirstDow = dateEnv.weekDow;
        }

        html += '<td class="' + classes.join(' ') + '"' + (isDateValid ? ' data-date="' + dateEnv.formatIso(date, {
          omitTime: true
        }) + '"' : '') + '>';

        if (this.renderProps.cellWeekNumbersVisible && date.getUTCDay() === weekCalcFirstDow) {
          html += Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["buildGotoAnchorHtml"])(options, dateEnv, {
            date: date,
            type: 'week'
          }, {
            'class': 'fc-week-number'
          }, dateEnv.format(date, WEEK_NUM_FORMAT) // inner HTML
          );
        }

        if (isDayNumberVisible) {
          html += Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["buildGotoAnchorHtml"])(options, dateEnv, date, {
            'class': 'fc-day-number'
          }, dateEnv.format(date, DAY_NUM_FORMAT) // inner HTML
          );
        }

        html += '</td>';
        return html;
      };
      /* Sizing
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype.updateSize = function (isResize) {
        var calendar = this.context.calendar;

        var _a = this,
            fillRenderer = _a.fillRenderer,
            eventRenderer = _a.eventRenderer,
            mirrorRenderer = _a.mirrorRenderer;

        if (isResize || this.isCellSizesDirty || calendar.isEventsUpdated // hack
        ) {
          this.buildPositionCaches();
          this.isCellSizesDirty = false;
        }

        fillRenderer.computeSizes(isResize);
        eventRenderer.computeSizes(isResize);
        mirrorRenderer.computeSizes(isResize);
        fillRenderer.assignSizes(isResize);
        eventRenderer.assignSizes(isResize);
        mirrorRenderer.assignSizes(isResize);
      };

      DayGrid.prototype.buildPositionCaches = function () {
        this.buildColPositions();
        this.buildRowPositions();
      };

      DayGrid.prototype.buildColPositions = function () {
        this.colPositions.build();
      };

      DayGrid.prototype.buildRowPositions = function () {
        this.rowPositions.build();
        this.rowPositions.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
      };
      /* Hit System
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype.positionToHit = function (leftPosition, topPosition) {
        var _a = this,
            colPositions = _a.colPositions,
            rowPositions = _a.rowPositions;

        var col = colPositions.leftToIndex(leftPosition);
        var row = rowPositions.topToIndex(topPosition);

        if (row != null && col != null) {
          return {
            row: row,
            col: col,
            dateSpan: {
              range: this.getCellRange(row, col),
              allDay: true
            },
            dayEl: this.getCellEl(row, col),
            relativeRect: {
              left: colPositions.lefts[col],
              right: colPositions.rights[col],
              top: rowPositions.tops[row],
              bottom: rowPositions.bottoms[row]
            }
          };
        }
      };
      /* Cell System
      ------------------------------------------------------------------------------------------------------------------*/
      // FYI: the first column is the leftmost column, regardless of date


      DayGrid.prototype.getCellEl = function (row, col) {
        return this.cellEls[row * this.colCnt + col];
      };
      /* Event Drag Visualization
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype._renderEventDrag = function (state) {
        if (state) {
          this.eventRenderer.hideByHash(state.affectedInstances);
          this.fillRenderer.renderSegs('highlight', this.context, state.segs);
        }
      };

      DayGrid.prototype._unrenderEventDrag = function (state) {
        if (state) {
          this.eventRenderer.showByHash(state.affectedInstances);
          this.fillRenderer.unrender('highlight', this.context);
        }
      };
      /* Event Resize Visualization
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype._renderEventResize = function (state) {
        if (state) {
          this.eventRenderer.hideByHash(state.affectedInstances);
          this.fillRenderer.renderSegs('highlight', this.context, state.segs);
          this.mirrorRenderer.renderSegs(this.context, state.segs, {
            isResizing: true,
            sourceSeg: state.sourceSeg
          });
        }
      };

      DayGrid.prototype._unrenderEventResize = function (state) {
        if (state) {
          this.eventRenderer.showByHash(state.affectedInstances);
          this.fillRenderer.unrender('highlight', this.context);
          this.mirrorRenderer.unrender(this.context, state.segs, {
            isResizing: true,
            sourceSeg: state.sourceSeg
          });
        }
      };
      /* More+ Link Popover
      ------------------------------------------------------------------------------------------------------------------*/


      DayGrid.prototype.removeSegPopover = function () {
        if (this.segPopover) {
          this.segPopover.hide(); // in handler, will call segPopover's removeElement
        }
      }; // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
      // `levelLimit` can be false (don't limit), a number, or true (should be computed).


      DayGrid.prototype.limitRows = function (levelLimit) {
        var rowStructs = this.eventRenderer.rowStructs || [];
        var row; // row #

        var rowLevelLimit;

        for (row = 0; row < rowStructs.length; row++) {
          this.unlimitRow(row);

          if (!levelLimit) {
            rowLevelLimit = false;
          } else if (typeof levelLimit === 'number') {
            rowLevelLimit = levelLimit;
          } else {
            rowLevelLimit = this.computeRowLevelLimit(row);
          }

          if (rowLevelLimit !== false) {
            this.limitRow(row, rowLevelLimit);
          }
        }
      }; // Computes the number of levels a row will accomodate without going outside its bounds.
      // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
      // `row` is the row number.


      DayGrid.prototype.computeRowLevelLimit = function (row) {
        var rowEl = this.rowEls[row]; // the containing "fake" row div

        var rowBottom = rowEl.getBoundingClientRect().bottom; // relative to viewport!

        var trEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findChildren"])(this.eventRenderer.rowStructs[row].tbodyEl);
        var i;
        var trEl; // Reveal one level <tr> at a time and stop when we find one out of bounds

        for (i = 0; i < trEls.length; i++) {
          trEl = trEls[i];
          trEl.classList.remove('fc-limited'); // reset to original state (reveal)

          if (trEl.getBoundingClientRect().bottom > rowBottom) {
            return i;
          }
        }

        return false; // should not limit at all
      }; // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
      // `row` is the row number.
      // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.


      DayGrid.prototype.limitRow = function (row, levelLimit) {
        var _this = this;

        var colCnt = this.colCnt;
        var isRtl = this.context.isRtl;
        var rowStruct = this.eventRenderer.rowStructs[row];
        var moreNodes = []; // array of "more" <a> links and <td> DOM nodes

        var col = 0; // col #, left-to-right (not chronologically)

        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right

        var cellMatrix; // a matrix (by level, then column) of all <td> elements in the row

        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes

        var i;
        var seg;
        var segsBelow; // array of segment objects below `seg` in the current `col`

        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies

        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)

        var td;
        var rowSpan;
        var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell

        var j;
        var moreTd;
        var moreWrap;
        var moreLink; // Iterates through empty level cells and places "more" links inside if need be

        var emptyCellsUntil = function emptyCellsUntil(endCol) {
          while (col < endCol) {
            segsBelow = _this.getCellSegs(row, col, levelLimit);

            if (segsBelow.length) {
              td = cellMatrix[levelLimit - 1][col];
              moreLink = _this.renderMoreLink(row, col, segsBelow);
              moreWrap = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', null, moreLink);
              td.appendChild(moreWrap);
              moreNodes.push(moreWrap);
            }

            col++;
          }
        };

        if (levelLimit && levelLimit < rowStruct.segLevels.length) {
          // is it actually over the limit?
          levelSegs = rowStruct.segLevels[levelLimit - 1];
          cellMatrix = rowStruct.cellMatrix;
          limitedNodes = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findChildren"])(rowStruct.tbodyEl).slice(levelLimit); // get level <tr> elements past the limit

          limitedNodes.forEach(function (node) {
            node.classList.add('fc-limited'); // hide elements and get a simple DOM-nodes array
          }); // iterate though segments in the last allowable level

          for (i = 0; i < levelSegs.length; i++) {
            seg = levelSegs[i];
            var leftCol = isRtl ? colCnt - 1 - seg.lastCol : seg.firstCol;
            var rightCol = isRtl ? colCnt - 1 - seg.firstCol : seg.lastCol;
            emptyCellsUntil(leftCol); // process empty cells before the segment
            // determine *all* segments below `seg` that occupy the same columns

            colSegsBelow = [];
            totalSegsBelow = 0;

            while (col <= rightCol) {
              segsBelow = this.getCellSegs(row, col, levelLimit);
              colSegsBelow.push(segsBelow);
              totalSegsBelow += segsBelow.length;
              col++;
            }

            if (totalSegsBelow) {
              // do we need to replace this segment with one or many "more" links?
              td = cellMatrix[levelLimit - 1][leftCol]; // the segment's parent cell

              rowSpan = td.rowSpan || 1;
              segMoreNodes = []; // make a replacement <td> for each column the segment occupies. will be one for each colspan

              for (j = 0; j < colSegsBelow.length; j++) {
                moreTd = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('td', {
                  className: 'fc-more-cell',
                  rowSpan: rowSpan
                });
                segsBelow = colSegsBelow[j];
                moreLink = this.renderMoreLink(row, leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                );
                moreWrap = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', null, moreLink);
                moreTd.appendChild(moreWrap);
                segMoreNodes.push(moreTd);
                moreNodes.push(moreTd);
              }

              td.classList.add('fc-limited');
              Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["insertAfterElement"])(td, segMoreNodes);
              limitedNodes.push(td);
            }
          }

          emptyCellsUntil(this.colCnt); // finish off the level

          rowStruct.moreEls = moreNodes; // for easy undoing later

          rowStruct.limitedEls = limitedNodes; // for easy undoing later
        }
      }; // Reveals all levels and removes all "more"-related elements for a grid's row.
      // `row` is a row number.


      DayGrid.prototype.unlimitRow = function (row) {
        var rowStruct = this.eventRenderer.rowStructs[row];

        if (rowStruct.moreEls) {
          rowStruct.moreEls.forEach(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"]);
          rowStruct.moreEls = null;
        }

        if (rowStruct.limitedEls) {
          rowStruct.limitedEls.forEach(function (limitedEl) {
            limitedEl.classList.remove('fc-limited');
          });
          rowStruct.limitedEls = null;
        }
      }; // Renders an <a> element that represents hidden event element for a cell.
      // Responsible for attaching click handler as well.


      DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
        var _this = this;

        var _a = this.context,
            calendar = _a.calendar,
            view = _a.view,
            dateEnv = _a.dateEnv,
            options = _a.options,
            isRtl = _a.isRtl;
        var a = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('a', {
          className: 'fc-more'
        });
        a.innerText = this.getMoreLinkText(hiddenSegs.length);
        a.addEventListener('click', function (ev) {
          var clickOption = options.eventLimitClick;

          var _col = isRtl ? _this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?


          var date = _this.props.cells[row][_col].date;
          var moreEl = ev.currentTarget;

          var dayEl = _this.getCellEl(row, col);

          var allSegs = _this.getCellSegs(row, col); // rescope the segments to be within the cell's date


          var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);

          var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

          if (typeof clickOption === 'function') {
            // the returned value can be an atomic option
            clickOption = calendar.publiclyTrigger('eventLimitClick', [{
              date: dateEnv.toDate(date),
              allDay: true,
              dayEl: dayEl,
              moreEl: moreEl,
              segs: reslicedAllSegs,
              hiddenSegs: reslicedHiddenSegs,
              jsEvent: ev,
              view: view
            }]);
          }

          if (clickOption === 'popover') {
            _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
          } else if (typeof clickOption === 'string') {
            // a view name
            calendar.zoomTo(date, clickOption);
          }
        });
        return a;
      }; // Reveals the popover that displays all events within a cell


      DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
        var _this = this;

        var _a = this.context,
            calendar = _a.calendar,
            view = _a.view,
            theme = _a.theme,
            isRtl = _a.isRtl;

        var _col = isRtl ? this.colCnt - col - 1 : col; // HACK: props.cells has different dir system?


        var moreWrap = moreLink.parentNode; // the <div> wrapper around the <a>

        var topEl; // the element we want to match the top coordinate of

        var options;

        if (this.rowCnt === 1) {
          topEl = view.el; // will cause the popover to cover any sort of header
        } else {
          topEl = this.rowEls[row]; // will align with top of row
        }

        options = {
          className: 'fc-more-popover ' + theme.getClass('popover'),
          parentEl: view.el,
          top: Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeRect"])(topEl).top,
          autoHide: true,
          content: function content(el) {
            _this.segPopoverTile = new DayTile(el);

            _this.updateSegPopoverTile(_this.props.cells[row][_col].date, segs);
          },
          hide: function hide() {
            _this.segPopoverTile.destroy();

            _this.segPopoverTile = null;

            _this.segPopover.destroy();

            _this.segPopover = null;
          }
        }; // Determine horizontal coordinate.
        // We use the moreWrap instead of the <td> to avoid border confusion.

        if (isRtl) {
          options.right = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeRect"])(moreWrap).right + 1; // +1 to be over cell border
        } else {
          options.left = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeRect"])(moreWrap).left - 1; // -1 to be over cell border
        }

        this.segPopover = new Popover(options);
        this.segPopover.show();
        calendar.releaseAfterSizingTriggers(); // hack for eventPositioned
      }; // Given the events within an array of segment objects, reslice them to be in a single day


      DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
        var dayStart = dayDate;
        var dayEnd = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addDays"])(dayStart, 1);
        var dayRange = {
          start: dayStart,
          end: dayEnd
        };
        var newSegs = [];

        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
          var seg = segs_1[_i];
          var eventRange = seg.eventRange;
          var origRange = eventRange.range;
          var slicedRange = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["intersectRanges"])(origRange, dayRange);

          if (slicedRange) {
            newSegs.push(_assign2({}, seg, {
              eventRange: {
                def: eventRange.def,
                ui: _assign2({}, eventRange.ui, {
                  durationEditable: false
                }),
                instance: eventRange.instance,
                range: slicedRange
              },
              isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),
              isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()
            }));
          }
        }

        return newSegs;
      }; // Generates the text that should be inside a "more" link, given the number of events it represents


      DayGrid.prototype.getMoreLinkText = function (num) {
        var opt = this.context.options.eventLimitText;

        if (typeof opt === 'function') {
          return opt(num);
        } else {
          return '+' + num + ' ' + opt;
        }
      }; // Returns segments within a given cell.
      // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.


      DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
        var level = startLevel || 0;
        var segs = [];
        var seg;

        while (level < segMatrix.length) {
          seg = segMatrix[level][col];

          if (seg) {
            segs.push(seg);
          }

          level++;
        }

        return segs;
      };

      return DayGrid;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DateComponent"]);

    var WEEK_NUM_FORMAT$1 = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])({
      week: 'numeric'
    });
    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.
    ----------------------------------------------------------------------------------------------------------------------*/
    // It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
    // It is responsible for managing width/height.

    var AbstractDayGridView =
    /** @class */
    function (_super) {
      __extends(AbstractDayGridView, _super);

      function AbstractDayGridView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.processOptions = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoize"])(_this._processOptions);
        _this.renderSkeleton = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderSkeleton, _this._unrenderSkeleton);
        /* Header Rendering
        ------------------------------------------------------------------------------------------------------------------*/
        // Generates the HTML that will go before the day-of week header cells

        _this.renderHeadIntroHtml = function () {
          var _a = _this.context,
              theme = _a.theme,
              options = _a.options;

          if (_this.colWeekNumbersVisible) {
            return '' + '<th class="fc-week-number ' + theme.getClass('widgetHeader') + '" ' + _this.weekNumberStyleAttr() + '>' + '<span>' + // needed for matchCellWidths
            Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(options.weekLabel) + '</span>' + '</th>';
          }

          return '';
        };
        /* Day Grid Rendering
        ------------------------------------------------------------------------------------------------------------------*/
        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers


        _this.renderDayGridNumberIntroHtml = function (row, dayGrid) {
          var _a = _this.context,
              options = _a.options,
              dateEnv = _a.dateEnv;
          var weekStart = dayGrid.props.cells[row][0].date;

          if (_this.colWeekNumbersVisible) {
            return '' + '<td class="fc-week-number" ' + _this.weekNumberStyleAttr() + '>' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["buildGotoAnchorHtml"])( // aside from link, important for matchCellWidths
            options, dateEnv, {
              date: weekStart,
              type: 'week',
              forceOff: dayGrid.colCnt === 1
            }, dateEnv.format(weekStart, WEEK_NUM_FORMAT$1) // inner HTML
            ) + '</td>';
          }

          return '';
        }; // Generates the HTML that goes before the day bg cells for each day-row


        _this.renderDayGridBgIntroHtml = function () {
          var theme = _this.context.theme;

          if (_this.colWeekNumbersVisible) {
            return '<td class="fc-week-number ' + theme.getClass('widgetContent') + '" ' + _this.weekNumberStyleAttr() + '></td>';
          }

          return '';
        }; // Generates the HTML that goes before every other type of row generated by DayGrid.
        // Affects mirror-skeleton and highlight-skeleton rows.


        _this.renderDayGridIntroHtml = function () {
          if (_this.colWeekNumbersVisible) {
            return '<td class="fc-week-number" ' + _this.weekNumberStyleAttr() + '></td>';
          }

          return '';
        };

        return _this;
      }

      AbstractDayGridView.prototype._processOptions = function (options) {
        if (options.weekNumbers) {
          if (options.weekNumbersWithinDays) {
            this.cellWeekNumbersVisible = true;
            this.colWeekNumbersVisible = false;
          } else {
            this.cellWeekNumbersVisible = false;
            this.colWeekNumbersVisible = true;
          }
        } else {
          this.colWeekNumbersVisible = false;
          this.cellWeekNumbersVisible = false;
        }
      };

      AbstractDayGridView.prototype.render = function (props, context) {
        _super.prototype.render.call(this, props, context);

        this.processOptions(context.options);
        this.renderSkeleton(context);
      };

      AbstractDayGridView.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.renderSkeleton.unrender();
      };

      AbstractDayGridView.prototype._renderSkeleton = function (context) {
        this.el.classList.add('fc-dayGrid-view');
        this.el.innerHTML = this.renderSkeletonHtml();
        this.scroller = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["ScrollComponent"]('hidden', // overflow x
        'auto' // overflow y
        );
        var dayGridContainerEl = this.scroller.el;
        this.el.querySelector('.fc-body > tr > td').appendChild(dayGridContainerEl);
        dayGridContainerEl.classList.add('fc-day-grid-container');
        var dayGridEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', {
          className: 'fc-day-grid'
        });
        dayGridContainerEl.appendChild(dayGridEl);
        this.dayGrid = new DayGrid(dayGridEl, {
          renderNumberIntroHtml: this.renderDayGridNumberIntroHtml,
          renderBgIntroHtml: this.renderDayGridBgIntroHtml,
          renderIntroHtml: this.renderDayGridIntroHtml,
          colWeekNumbersVisible: this.colWeekNumbersVisible,
          cellWeekNumbersVisible: this.cellWeekNumbersVisible
        });
      };

      AbstractDayGridView.prototype._unrenderSkeleton = function () {
        this.el.classList.remove('fc-dayGrid-view');
        this.dayGrid.destroy();
        this.scroller.destroy();
      }; // Builds the HTML skeleton for the view.
      // The day-grid component will render inside of a container defined by this HTML.


      AbstractDayGridView.prototype.renderSkeletonHtml = function () {
        var _a = this.context,
            theme = _a.theme,
            options = _a.options;
        return '' + '<table class="' + theme.getClass('tableGrid') + '">' + (options.columnHeader ? '<thead class="fc-head">' + '<tr>' + '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class="fc-body">' + '<tr>' + '<td class="' + theme.getClass('widgetContent') + '"></td>' + '</tr>' + '</tbody>' + '</table>';
      }; // Generates an HTML attribute string for setting the width of the week number column, if it is known


      AbstractDayGridView.prototype.weekNumberStyleAttr = function () {
        if (this.weekNumberWidth != null) {
          return 'style="width:' + this.weekNumberWidth + 'px"';
        }

        return '';
      }; // Determines whether each row should have a constant height


      AbstractDayGridView.prototype.hasRigidRows = function () {
        var eventLimit = this.context.options.eventLimit;
        return eventLimit && typeof eventLimit !== 'number';
      };
      /* Dimensions
      ------------------------------------------------------------------------------------------------------------------*/


      AbstractDayGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
        _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first


        this.dayGrid.updateSize(isResize);
      }; // Refreshes the horizontal dimensions of the view


      AbstractDayGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
        var dayGrid = this.dayGrid;
        var eventLimit = this.context.options.eventLimit;
        var headRowEl = this.header ? this.header.el : null; // HACK

        var scrollerHeight;
        var scrollbarWidths; // hack to give the view some height prior to dayGrid's columns being rendered
        // TODO: separate setting height from scroller VS dayGrid.

        if (!dayGrid.rowEls) {
          if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(viewHeight);
            this.scroller.setHeight(scrollerHeight);
          }

          return;
        }

        if (this.colWeekNumbersVisible) {
          // Make sure all week number cells running down the side have the same width.
          this.weekNumberWidth = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["matchCellWidths"])(Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.el, '.fc-week-number'));
        } // reset all heights to be natural


        this.scroller.clear();

        if (headRowEl) {
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["uncompensateScroll"])(headRowEl);
        }

        dayGrid.removeSegPopover(); // kill the "more" popover if displayed
        // is the event limit a constant level number?

        if (eventLimit && typeof eventLimit === 'number') {
          dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
        } // distribute the height to the rows
        // (viewHeight is a "recommended" value if isAuto)


        scrollerHeight = this.computeScrollerHeight(viewHeight);
        this.setGridHeight(scrollerHeight, isAuto); // is the event limit dynamically calculated?

        if (eventLimit && typeof eventLimit !== 'number') {
          dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
        }

        if (!isAuto) {
          // should we force dimensions of the scroll container?
          this.scroller.setHeight(scrollerHeight);
          scrollbarWidths = this.scroller.getScrollbarWidths();

          if (scrollbarWidths.left || scrollbarWidths.right) {
            // using scrollbars?
            if (headRowEl) {
              Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["compensateScroll"])(headRowEl, scrollbarWidths);
            } // doing the scrollbar compensation might have created text overflow which created more height. redo


            scrollerHeight = this.computeScrollerHeight(viewHeight);
            this.scroller.setHeight(scrollerHeight);
          } // guarantees the same scrollbar widths


          this.scroller.lockOverflow(scrollbarWidths);
        }
      }; // given a desired total height of the view, returns what the height of the scroller should be


      AbstractDayGridView.prototype.computeScrollerHeight = function (viewHeight) {
        return viewHeight - Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["subtractInnerElHeight"])(this.el, this.scroller.el); // everything that's NOT the scroller
      }; // Sets the height of just the DayGrid component in this view


      AbstractDayGridView.prototype.setGridHeight = function (height, isAuto) {
        if (this.context.options.monthMode) {
          // if auto, make the height of each row the height that it would be if there were 6 weeks
          if (isAuto) {
            height *= this.dayGrid.rowCnt / 6;
          }

          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["distributeHeight"])(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
        } else {
          if (isAuto) {
            Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["undistributeHeight"])(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
          } else {
            Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["distributeHeight"])(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
          }
        }
      };
      /* Scroll
      ------------------------------------------------------------------------------------------------------------------*/


      AbstractDayGridView.prototype.computeDateScroll = function (duration) {
        return {
          top: 0
        };
      };

      AbstractDayGridView.prototype.queryDateScroll = function () {
        return {
          top: this.scroller.getScrollTop()
        };
      };

      AbstractDayGridView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
          this.scroller.setScrollTop(scroll.top);
        }
      };

      return AbstractDayGridView;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["View"]);

    AbstractDayGridView.prototype.dateProfileGeneratorClass = DayGridDateProfileGenerator;

    var SimpleDayGrid =
    /** @class */
    function (_super) {
      __extends(SimpleDayGrid, _super);

      function SimpleDayGrid(dayGrid) {
        var _this = _super.call(this, dayGrid.el) || this;

        _this.slicer = new DayGridSlicer();
        _this.dayGrid = dayGrid;
        return _this;
      }

      SimpleDayGrid.prototype.firstContext = function (context) {
        context.calendar.registerInteractiveComponent(this, {
          el: this.dayGrid.el
        });
      };

      SimpleDayGrid.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.context.calendar.unregisterInteractiveComponent(this);
      };

      SimpleDayGrid.prototype.render = function (props, context) {
        var dayGrid = this.dayGrid;
        var dateProfile = props.dateProfile,
            dayTable = props.dayTable;
        dayGrid.receiveContext(context); // hack because context is used in sliceProps

        dayGrid.receiveProps(_assign2({}, this.slicer.sliceProps(props, dateProfile, props.nextDayThreshold, context.calendar, dayGrid, dayTable), {
          dateProfile: dateProfile,
          cells: dayTable.cells,
          isRigid: props.isRigid
        }), context);
      };

      SimpleDayGrid.prototype.buildPositionCaches = function () {
        this.dayGrid.buildPositionCaches();
      };

      SimpleDayGrid.prototype.queryHit = function (positionLeft, positionTop) {
        var rawHit = this.dayGrid.positionToHit(positionLeft, positionTop);

        if (rawHit) {
          return {
            component: this.dayGrid,
            dateSpan: rawHit.dateSpan,
            dayEl: rawHit.dayEl,
            rect: {
              left: rawHit.relativeRect.left,
              right: rawHit.relativeRect.right,
              top: rawHit.relativeRect.top,
              bottom: rawHit.relativeRect.bottom
            },
            layer: 0
          };
        }
      };

      return SimpleDayGrid;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DateComponent"]);

    var DayGridSlicer =
    /** @class */
    function (_super) {
      __extends(DayGridSlicer, _super);

      function DayGridSlicer() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      DayGridSlicer.prototype.sliceRange = function (dateRange, dayTable) {
        return dayTable.sliceRange(dateRange);
      };

      return DayGridSlicer;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["Slicer"]);

    var DayGridView =
    /** @class */
    function (_super) {
      __extends(DayGridView, _super);

      function DayGridView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.buildDayTable = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoize"])(buildDayTable);
        return _this;
      }

      DayGridView.prototype.render = function (props, context) {
        _super.prototype.render.call(this, props, context); // will call _renderSkeleton/_unrenderSkeleton


        var dateProfile = this.props.dateProfile;
        var dayTable = this.dayTable = this.buildDayTable(dateProfile, props.dateProfileGenerator);

        if (this.header) {
          this.header.receiveProps({
            dateProfile: dateProfile,
            dates: dayTable.headerDates,
            datesRepDistinctDays: dayTable.rowCnt === 1,
            renderIntroHtml: this.renderHeadIntroHtml
          }, context);
        }

        this.simpleDayGrid.receiveProps({
          dateProfile: dateProfile,
          dayTable: dayTable,
          businessHours: props.businessHours,
          dateSelection: props.dateSelection,
          eventStore: props.eventStore,
          eventUiBases: props.eventUiBases,
          eventSelection: props.eventSelection,
          eventDrag: props.eventDrag,
          eventResize: props.eventResize,
          isRigid: this.hasRigidRows(),
          nextDayThreshold: this.context.nextDayThreshold
        }, context);
      };

      DayGridView.prototype._renderSkeleton = function (context) {
        _super.prototype._renderSkeleton.call(this, context);

        if (context.options.columnHeader) {
          this.header = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DayHeader"](this.el.querySelector('.fc-head-container'));
        }

        this.simpleDayGrid = new SimpleDayGrid(this.dayGrid);
      };

      DayGridView.prototype._unrenderSkeleton = function () {
        _super.prototype._unrenderSkeleton.call(this);

        if (this.header) {
          this.header.destroy();
        }

        this.simpleDayGrid.destroy();
      };

      return DayGridView;
    }(AbstractDayGridView);

    function buildDayTable(dateProfile, dateProfileGenerator) {
      var daySeries = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DaySeries"](dateProfile.renderRange, dateProfileGenerator);
      return new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DayTable"](daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
    }

    var main = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createPlugin"])({
      defaultView: 'dayGridMonth',
      views: {
        dayGrid: DayGridView,
        dayGridDay: {
          type: 'dayGrid',
          duration: {
            days: 1
          }
        },
        dayGridWeek: {
          type: 'dayGrid',
          duration: {
            weeks: 1
          }
        },
        dayGridMonth: {
          type: 'dayGrid',
          duration: {
            months: 1
          },
          monthMode: true,
          fixedWeekCount: true
        }
      }
    });
    /* harmony default export */

    __webpack_exports__["default"] = main;
    /***/
  },

  /***/
  "./node_modules/@fullcalendar/timegrid/main.esm.js":
  /*!*********************************************************!*\
    !*** ./node_modules/@fullcalendar/timegrid/main.esm.js ***!
    \*********************************************************/

  /*! exports provided: default, AbstractTimeGridView, TimeGrid, TimeGridSlicer, TimeGridView, buildDayRanges, buildDayTable */

  /***/
  function node_modulesFullcalendarTimegridMainEsmJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AbstractTimeGridView", function () {
      return AbstractTimeGridView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeGrid", function () {
      return TimeGrid;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeGridSlicer", function () {
      return TimeGridSlicer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeGridView", function () {
      return TimeGridView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buildDayRanges", function () {
      return buildDayRanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buildDayTable", function () {
      return buildDayTable;
    });
    /* harmony import */


    var _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @fullcalendar/core */
    "./node_modules/@fullcalendar/core/main.esm.js");
    /* harmony import */


    var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @fullcalendar/daygrid */
    "./node_modules/@fullcalendar/daygrid/main.esm.js");
    /*!
    FullCalendar Time Grid Plugin v4.4.2
    Docs & License: https://fullcalendar.io/
    (c) 2019 Adam Shaw
    */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */


    var _extendStatics3 = function extendStatics(d, b) {
      _extendStatics3 = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return _extendStatics3(d, b);
    };

    function __extends(d, b) {
      _extendStatics3(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign3 = function __assign() {
      _assign3 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return _assign3.apply(this, arguments);
    };
    /*
    Only handles foreground segs.
    Does not own rendering. Use for low-level util methods by TimeGrid.
    */


    var TimeGridEventRenderer =
    /** @class */
    function (_super) {
      __extends(TimeGridEventRenderer, _super);

      function TimeGridEventRenderer(timeGrid) {
        var _this = _super.call(this) || this;

        _this.timeGrid = timeGrid;
        return _this;
      }

      TimeGridEventRenderer.prototype.renderSegs = function (context, segs, mirrorInfo) {
        _super.prototype.renderSegs.call(this, context, segs, mirrorInfo); // TODO: dont do every time. memoize


        this.fullTimeFormat = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])({
          hour: 'numeric',
          minute: '2-digit',
          separator: this.context.options.defaultRangeSeparator
        });
      }; // Given an array of foreground segments, render a DOM element for each, computes position,
      // and attaches to the column inner-container elements.


      TimeGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
        var segsByCol = this.timeGrid.groupSegsByCol(segs); // order the segs within each column
        // TODO: have groupSegsByCol do this?

        for (var col = 0; col < segsByCol.length; col++) {
          segsByCol[col] = this.sortEventSegs(segsByCol[col]);
        }

        this.segsByCol = segsByCol;
        this.timeGrid.attachSegsByCol(segsByCol, this.timeGrid.fgContainerEls);
      };

      TimeGridEventRenderer.prototype.detachSegs = function (segs) {
        segs.forEach(function (seg) {
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"])(seg.el);
        });
        this.segsByCol = null;
      };

      TimeGridEventRenderer.prototype.computeSegSizes = function (allSegs) {
        var _a = this,
            timeGrid = _a.timeGrid,
            segsByCol = _a.segsByCol;

        var colCnt = timeGrid.colCnt;
        timeGrid.computeSegVerticals(allSegs); // horizontals relies on this

        if (segsByCol) {
          for (var col = 0; col < colCnt; col++) {
            this.computeSegHorizontals(segsByCol[col]); // compute horizontal coordinates, z-index's, and reorder the array
          }
        }
      };

      TimeGridEventRenderer.prototype.assignSegSizes = function (allSegs) {
        var _a = this,
            timeGrid = _a.timeGrid,
            segsByCol = _a.segsByCol;

        var colCnt = timeGrid.colCnt;
        timeGrid.assignSegVerticals(allSegs); // horizontals relies on this

        if (segsByCol) {
          for (var col = 0; col < colCnt; col++) {
            this.assignSegCss(segsByCol[col]);
          }
        }
      }; // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined


      TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return {
          hour: 'numeric',
          minute: '2-digit',
          meridiem: false
        };
      }; // Computes a default `displayEventEnd` value if one is not expliclty defined


      TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
      }; // Renders the HTML for a single event segment's default rendering


      TimeGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {
        var eventRange = seg.eventRange;
        var eventDef = eventRange.def;
        var eventUi = eventRange.ui;
        var allDay = eventDef.allDay;
        var isDraggable = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeEventDraggable"])(this.context, eventDef, eventUi);
        var isResizableFromStart = seg.isStart && Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeEventStartResizable"])(this.context, eventDef, eventUi);
        var isResizableFromEnd = seg.isEnd && Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["computeEventEndResizable"])(this.context, eventDef, eventUi);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);
        var skinCss = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["cssToStr"])(this.getSkinCss(eventUi));
        var timeText;
        var fullTimeText; // more verbose time text. for the print stylesheet

        var startTimeText; // just the start time text

        classes.unshift('fc-time-grid-event'); // if the event appears to span more than one day...

        if (Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["isMultiDayRange"])(eventRange.range)) {
          // Don't display time text on segments that run entirely through a day.
          // That would appear as midnight-midnight and would look dumb.
          // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
          if (seg.isStart || seg.isEnd) {
            var unzonedStart = seg.start;
            var unzonedEnd = seg.end;
            timeText = this._getTimeText(unzonedStart, unzonedEnd, allDay); // TODO: give the timezones

            fullTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, this.fullTimeFormat);
            startTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, null, false); // displayEnd=false
          }
        } else {
          // Display the normal time text for the *event's* times
          timeText = this.getTimeText(eventRange);
          fullTimeText = this.getTimeText(eventRange, this.fullTimeFormat);
          startTimeText = this.getTimeText(eventRange, null, false); // displayEnd=false
        }

        return '<a class="' + classes.join(' ') + '"' + (eventDef.url ? ' href="' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(eventDef.url) + '"' : '') + (skinCss ? ' style="' + skinCss + '"' : '') + '>' + '<div class="fc-content">' + (timeText ? '<div class="fc-time"' + ' data-start="' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(startTimeText) + '"' + ' data-full="' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(fullTimeText) + '"' + '>' + '<span>' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(timeText) + '</span>' + '</div>' : '') + (eventDef.title ? '<div class="fc-title">' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(eventDef.title) + '</div>' : '') + '</div>' + (
        /* TODO: write CSS for this
        (isResizableFromStart ?
          '<div class="fc-resizer fc-start-resizer"></div>' :
          ''
          ) +
        */
        isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer"></div>' : '') + '</a>';
      }; // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
      // Assumed the segs are already ordered.
      // NOTE: Also reorders the given array by date!


      TimeGridEventRenderer.prototype.computeSegHorizontals = function (segs) {
        var levels;
        var level0;
        var i;
        levels = buildSlotSegLevels(segs);
        computeForwardSlotSegs(levels);

        if (level0 = levels[0]) {
          for (i = 0; i < level0.length; i++) {
            computeSlotSegPressures(level0[i]);
          }

          for (i = 0; i < level0.length; i++) {
            this.computeSegForwardBack(level0[i], 0, 0);
          }
        }
      }; // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
      // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
      // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
      //
      // The segment might be part of a "series", which means consecutive segments with the same pressure
      // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
      // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
      // coordinate of the first segment in the series.


      TimeGridEventRenderer.prototype.computeSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
        var forwardSegs = seg.forwardSegs;
        var i;

        if (seg.forwardCoord === undefined) {
          // not already computed
          if (!forwardSegs.length) {
            // if there are no forward segments, this segment should butt up against the edge
            seg.forwardCoord = 1;
          } else {
            // sort highest pressure first
            this.sortForwardSegs(forwardSegs); // this segment's forwardCoord will be calculated from the backwardCoord of the
            // highest-pressure forward segment.

            this.computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
            seg.forwardCoord = forwardSegs[0].backwardCoord;
          } // calculate the backwardCoord from the forwardCoord. consider the series


          seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / ( // available width for series
          seriesBackwardPressure + 1); // # of segments in the series
          // use this segment's coordinates to computed the coordinates of the less-pressurized
          // forward segments

          for (i = 0; i < forwardSegs.length; i++) {
            this.computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
          }
        }
      };

      TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
        var objs = forwardSegs.map(buildTimeGridSegCompareObj);
        var specs = [// put higher-pressure first
        {
          field: 'forwardPressure',
          order: -1
        }, // put segments that are closer to initial edge first (and favor ones with no coords yet)
        {
          field: 'backwardCoord',
          order: 1
        }].concat(this.context.eventOrderSpecs);
        objs.sort(function (obj0, obj1) {
          return Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["compareByFieldSpecs"])(obj0, obj1, specs);
        });
        return objs.map(function (c) {
          return c._seg;
        });
      }; // Given foreground event segments that have already had their position coordinates computed,
      // assigns position-related CSS values to their elements.


      TimeGridEventRenderer.prototype.assignSegCss = function (segs) {
        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {
          var seg = segs_1[_i];
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(seg.el, this.generateSegCss(seg));

          if (seg.level > 0) {
            seg.el.classList.add('fc-time-grid-event-inset');
          } // if the event is short that the title will be cut off,
          // attach a className that condenses the title into the time area.


          if (seg.eventRange.def.title && seg.bottom - seg.top < 30) {
            seg.el.classList.add('fc-short'); // TODO: "condensed" is a better name
          }
        }
      }; // Generates an object with CSS properties/values that should be applied to an event segment element.
      // Contains important positioning-related properties that should be applied to any event element, customized or not.


      TimeGridEventRenderer.prototype.generateSegCss = function (seg) {
        var shouldOverlap = this.context.options.slotEventOverlap;
        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point

        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point

        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first

        var isRtl = this.context.isRtl;
        var left; // amount of space from left edge, a fraction of the total width

        var right; // amount of space from right edge, a fraction of the total width

        if (shouldOverlap) {
          // double the width, but don't go beyond the maximum forward coordinate (1.0)
          forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
        }

        if (isRtl) {
          left = 1 - forwardCoord;
          right = backwardCoord;
        } else {
          left = backwardCoord;
          right = 1 - forwardCoord;
        }

        props.zIndex = seg.level + 1; // convert from 0-base to 1-based

        props.left = left * 100 + '%';
        props.right = right * 100 + '%';

        if (shouldOverlap && seg.forwardPressure) {
          // add padding to the edge so that forward stacked events don't cover the resizer's icon
          props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
        }

        return props;
      };

      return TimeGridEventRenderer;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["FgEventRenderer"]); // Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
    // left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.


    function buildSlotSegLevels(segs) {
      var levels = [];
      var i;
      var seg;
      var j;

      for (i = 0; i < segs.length; i++) {
        seg = segs[i]; // go through all the levels and stop on the first level where there are no collisions

        for (j = 0; j < levels.length; j++) {
          if (!computeSlotSegCollisions(seg, levels[j]).length) {
            break;
          }
        }

        seg.level = j;
        (levels[j] || (levels[j] = [])).push(seg);
      }

      return levels;
    } // For every segment, figure out the other segments that are in subsequent
    // levels that also occupy the same vertical space. Accumulate in seg.forwardSegs


    function computeForwardSlotSegs(levels) {
      var i;
      var level;
      var j;
      var seg;
      var k;

      for (i = 0; i < levels.length; i++) {
        level = levels[i];

        for (j = 0; j < level.length; j++) {
          seg = level[j];
          seg.forwardSegs = [];

          for (k = i + 1; k < levels.length; k++) {
            computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
          }
        }
      }
    } // Figure out which path forward (via seg.forwardSegs) results in the longest path until
    // the furthest edge is reached. The number of segments in this path will be seg.forwardPressure


    function computeSlotSegPressures(seg) {
      var forwardSegs = seg.forwardSegs;
      var forwardPressure = 0;
      var i;
      var forwardSeg;

      if (seg.forwardPressure === undefined) {
        // not already computed
        for (i = 0; i < forwardSegs.length; i++) {
          forwardSeg = forwardSegs[i]; // figure out the child's maximum forward path

          computeSlotSegPressures(forwardSeg); // either use the existing maximum, or use the child's forward pressure
          // plus one (for the forwardSeg itself)

          forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
        }

        seg.forwardPressure = forwardPressure;
      }
    } // Find all the segments in `otherSegs` that vertically collide with `seg`.
    // Append into an optionally-supplied `results` array and return.


    function computeSlotSegCollisions(seg, otherSegs, results) {
      if (results === void 0) {
        results = [];
      }

      for (var i = 0; i < otherSegs.length; i++) {
        if (isSlotSegCollision(seg, otherSegs[i])) {
          results.push(otherSegs[i]);
        }
      }

      return results;
    } // Do these segments occupy the same vertical space?


    function isSlotSegCollision(seg1, seg2) {
      return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
    }

    function buildTimeGridSegCompareObj(seg) {
      var obj = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["buildSegCompareObj"])(seg);
      obj.forwardPressure = seg.forwardPressure;
      obj.backwardCoord = seg.backwardCoord;
      return obj;
    }

    var TimeGridMirrorRenderer =
    /** @class */
    function (_super) {
      __extends(TimeGridMirrorRenderer, _super);

      function TimeGridMirrorRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TimeGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {
        this.segsByCol = this.timeGrid.groupSegsByCol(segs);
        this.timeGrid.attachSegsByCol(this.segsByCol, this.timeGrid.mirrorContainerEls);
        this.sourceSeg = mirrorInfo.sourceSeg;
      };

      TimeGridMirrorRenderer.prototype.generateSegCss = function (seg) {
        var props = _super.prototype.generateSegCss.call(this, seg);

        var sourceSeg = this.sourceSeg;

        if (sourceSeg && sourceSeg.col === seg.col) {
          var sourceSegProps = _super.prototype.generateSegCss.call(this, sourceSeg);

          props.left = sourceSegProps.left;
          props.right = sourceSegProps.right;
          props.marginLeft = sourceSegProps.marginLeft;
          props.marginRight = sourceSegProps.marginRight;
        }

        return props;
      };

      return TimeGridMirrorRenderer;
    }(TimeGridEventRenderer);

    var TimeGridFillRenderer =
    /** @class */
    function (_super) {
      __extends(TimeGridFillRenderer, _super);

      function TimeGridFillRenderer(timeGrid) {
        var _this = _super.call(this) || this;

        _this.timeGrid = timeGrid;
        return _this;
      }

      TimeGridFillRenderer.prototype.attachSegs = function (type, segs) {
        var timeGrid = this.timeGrid;
        var containerEls; // TODO: more efficient lookup

        if (type === 'bgEvent') {
          containerEls = timeGrid.bgContainerEls;
        } else if (type === 'businessHours') {
          containerEls = timeGrid.businessContainerEls;
        } else if (type === 'highlight') {
          containerEls = timeGrid.highlightContainerEls;
        }

        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
        return segs.map(function (seg) {
          return seg.el;
        });
      };

      TimeGridFillRenderer.prototype.computeSegSizes = function (segs) {
        this.timeGrid.computeSegVerticals(segs);
      };

      TimeGridFillRenderer.prototype.assignSegSizes = function (segs) {
        this.timeGrid.assignSegVerticals(segs);
      };

      return TimeGridFillRenderer;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["FillRenderer"]);
    /* A component that renders one or more columns of vertical time slots
    ----------------------------------------------------------------------------------------------------------------------*/
    // potential nice values for the slot-duration and interval-duration
    // from largest to smallest


    var AGENDA_STOCK_SUB_DURATIONS = [{
      hours: 1
    }, {
      minutes: 30
    }, {
      minutes: 15
    }, {
      seconds: 30
    }, {
      seconds: 15
    }];

    var TimeGrid =
    /** @class */
    function (_super) {
      __extends(TimeGrid, _super);

      function TimeGrid(el, renderProps) {
        var _this = _super.call(this, el) || this;

        _this.isSlatSizesDirty = false;
        _this.isColSizesDirty = false;
        _this.processOptions = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoize"])(_this._processOptions);
        _this.renderSkeleton = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderSkeleton);
        _this.renderSlats = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderSlats, null, [_this.renderSkeleton]);
        _this.renderColumns = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderColumns, _this._unrenderColumns, [_this.renderSkeleton]);
        _this.renderProps = renderProps;
        var renderColumns = _this.renderColumns;
        var eventRenderer = _this.eventRenderer = new TimeGridEventRenderer(_this);
        var fillRenderer = _this.fillRenderer = new TimeGridFillRenderer(_this);
        _this.mirrorRenderer = new TimeGridMirrorRenderer(_this);
        _this.renderBusinessHours = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderColumns]);
        _this.renderDateSelection = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderDateSelection, _this._unrenderDateSelection, [renderColumns]);
        _this.renderFgEvents = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderColumns]);
        _this.renderBgEvents = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderColumns]);
        _this.renderEventSelection = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);
        _this.renderEventDrag = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderEventDrag, _this._unrenderEventDrag, [renderColumns]);
        _this.renderEventResize = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderEventResize, _this._unrenderEventResize, [renderColumns]);
        return _this;
      }
      /* Options
      ------------------------------------------------------------------------------------------------------------------*/
      // Parses various options into properties of this object
      // MUST have context already set


      TimeGrid.prototype._processOptions = function (options) {
        var slotDuration = options.slotDuration,
            snapDuration = options.snapDuration;
        var snapsPerSlot;
        var input;
        slotDuration = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createDuration"])(slotDuration);
        snapDuration = snapDuration ? Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createDuration"])(snapDuration) : slotDuration;
        snapsPerSlot = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["wholeDivideDurations"])(slotDuration, snapDuration);

        if (snapsPerSlot === null) {
          snapDuration = slotDuration;
          snapsPerSlot = 1; // TODO: say warning?
        }

        this.slotDuration = slotDuration;
        this.snapDuration = snapDuration;
        this.snapsPerSlot = snapsPerSlot; // might be an array value (for TimelineView).
        // if so, getting the most granular entry (the last one probably).

        input = options.slotLabelFormat;

        if (Array.isArray(input)) {
          input = input[input.length - 1];
        }

        this.labelFormat = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])(input || {
          hour: 'numeric',
          minute: '2-digit',
          omitZeroMinute: true,
          meridiem: 'short'
        });
        input = options.slotLabelInterval;
        this.labelInterval = input ? Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createDuration"])(input) : this.computeLabelInterval(slotDuration);
      }; // Computes an automatic value for slotLabelInterval


      TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
        var i;
        var labelInterval;
        var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label

        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
          labelInterval = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createDuration"])(AGENDA_STOCK_SUB_DURATIONS[i]);
          slotsPerLabel = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["wholeDivideDurations"])(labelInterval, slotDuration);

          if (slotsPerLabel !== null && slotsPerLabel > 1) {
            return labelInterval;
          }
        }

        return slotDuration; // fall back
      };
      /* Rendering
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype.render = function (props, context) {
        this.processOptions(context.options);
        var cells = props.cells;
        this.colCnt = cells.length;
        this.renderSkeleton(context.theme);
        this.renderSlats(props.dateProfile);
        this.renderColumns(props.cells, props.dateProfile);
        this.renderBusinessHours(context, props.businessHourSegs);
        this.renderDateSelection(props.dateSelectionSegs);
        this.renderFgEvents(context, props.fgEventSegs);
        this.renderBgEvents(context, props.bgEventSegs);
        this.renderEventSelection(props.eventSelection);
        this.renderEventDrag(props.eventDrag);
        this.renderEventResize(props.eventResize);
      };

      TimeGrid.prototype.destroy = function () {
        _super.prototype.destroy.call(this); // should unrender everything else too


        this.renderSlats.unrender();
        this.renderColumns.unrender();
        this.renderSkeleton.unrender();
      };

      TimeGrid.prototype.updateSize = function (isResize) {
        var _a = this,
            fillRenderer = _a.fillRenderer,
            eventRenderer = _a.eventRenderer,
            mirrorRenderer = _a.mirrorRenderer;

        if (isResize || this.isSlatSizesDirty) {
          this.buildSlatPositions();
          this.isSlatSizesDirty = false;
        }

        if (isResize || this.isColSizesDirty) {
          this.buildColPositions();
          this.isColSizesDirty = false;
        }

        fillRenderer.computeSizes(isResize);
        eventRenderer.computeSizes(isResize);
        mirrorRenderer.computeSizes(isResize);
        fillRenderer.assignSizes(isResize);
        eventRenderer.assignSizes(isResize);
        mirrorRenderer.assignSizes(isResize);
      };

      TimeGrid.prototype._renderSkeleton = function (theme) {
        var el = this.el;
        el.innerHTML = '<div class="fc-bg"></div>' + '<div class="fc-slats"></div>' + '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" style="display:none" />';
        this.rootBgContainerEl = el.querySelector('.fc-bg');
        this.slatContainerEl = el.querySelector('.fc-slats');
        this.bottomRuleEl = el.querySelector('.fc-divider');
      };

      TimeGrid.prototype._renderSlats = function (dateProfile) {
        var theme = this.context.theme;
        this.slatContainerEl.innerHTML = '<table class="' + theme.getClass('tableGrid') + '">' + this.renderSlatRowHtml(dateProfile) + '</table>';
        this.slatEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.slatContainerEl, 'tr');
        this.slatPositions = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["PositionCache"](this.el, this.slatEls, false, true // vertical
        );
        this.isSlatSizesDirty = true;
      }; // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.


      TimeGrid.prototype.renderSlatRowHtml = function (dateProfile) {
        var _a = this.context,
            dateEnv = _a.dateEnv,
            theme = _a.theme,
            isRtl = _a.isRtl;
        var html = '';
        var dayStart = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["startOfDay"])(dateProfile.renderRange.start);
        var slotTime = dateProfile.minTime;
        var slotIterator = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createDuration"])(0);
        var slotDate; // will be on the view's first day, but we only care about its time

        var isLabeled;
        var axisHtml; // Calculate the time for each slot

        while (Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["asRoughMs"])(slotTime) < Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["asRoughMs"])(dateProfile.maxTime)) {
          slotDate = dateEnv.add(dayStart, slotTime);
          isLabeled = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["wholeDivideDurations"])(slotIterator, this.labelInterval) !== null;
          axisHtml = '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '">' + (isLabeled ? '<span>' + // for matchCellWidths
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(dateEnv.format(slotDate, this.labelFormat)) + '</span>' : '') + '</td>';
          html += '<tr data-time="' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["formatIsoTimeString"])(slotDate) + '"' + (isLabeled ? '' : ' class="fc-minor"') + '>' + (!isRtl ? axisHtml : '') + '<td class="' + theme.getClass('widgetContent') + '"></td>' + (isRtl ? axisHtml : '') + '</tr>';
          slotTime = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addDurations"])(slotTime, this.slotDuration);
          slotIterator = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addDurations"])(slotIterator, this.slotDuration);
        }

        return html;
      };

      TimeGrid.prototype._renderColumns = function (cells, dateProfile) {
        var _a = this.context,
            calendar = _a.calendar,
            view = _a.view,
            isRtl = _a.isRtl,
            theme = _a.theme,
            dateEnv = _a.dateEnv;
        var bgRow = new _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__["DayBgRow"](this.context);
        this.rootBgContainerEl.innerHTML = '<table class="' + theme.getClass('tableGrid') + '">' + bgRow.renderHtml({
          cells: cells,
          dateProfile: dateProfile,
          renderIntroHtml: this.renderProps.renderBgIntroHtml
        }) + '</table>';
        this.colEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.el, '.fc-day, .fc-disabled-day');

        for (var col = 0; col < this.colCnt; col++) {
          calendar.publiclyTrigger('dayRender', [{
            date: dateEnv.toDate(cells[col].date),
            el: this.colEls[col],
            view: view
          }]);
        }

        if (isRtl) {
          this.colEls.reverse();
        }

        this.colPositions = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["PositionCache"](this.el, this.colEls, true, // horizontal
        false);
        this.renderContentSkeleton();
        this.isColSizesDirty = true;
      };

      TimeGrid.prototype._unrenderColumns = function () {
        this.unrenderContentSkeleton();
      };
      /* Content Skeleton
      ------------------------------------------------------------------------------------------------------------------*/
      // Renders the DOM that the view's content will live in


      TimeGrid.prototype.renderContentSkeleton = function () {
        var isRtl = this.context.isRtl;
        var parts = [];
        var skeletonEl;
        parts.push(this.renderProps.renderIntroHtml());

        for (var i = 0; i < this.colCnt; i++) {
          parts.push('<td>' + '<div class="fc-content-col">' + '<div class="fc-event-container fc-mirror-container"></div>' + '<div class="fc-event-container"></div>' + '<div class="fc-highlight-container"></div>' + '<div class="fc-bgevent-container"></div>' + '<div class="fc-business-container"></div>' + '</div>' + '</td>');
        }

        if (isRtl) {
          parts.reverse();
        }

        skeletonEl = this.contentSkeletonEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlToElement"])('<div class="fc-content-skeleton">' + '<table>' + '<tr>' + parts.join('') + '</tr>' + '</table>' + '</div>');
        this.colContainerEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(skeletonEl, '.fc-content-col');
        this.mirrorContainerEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(skeletonEl, '.fc-mirror-container');
        this.fgContainerEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(skeletonEl, '.fc-event-container:not(.fc-mirror-container)');
        this.bgContainerEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(skeletonEl, '.fc-bgevent-container');
        this.highlightContainerEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(skeletonEl, '.fc-highlight-container');
        this.businessContainerEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(skeletonEl, '.fc-business-container');

        if (isRtl) {
          this.colContainerEls.reverse();
          this.mirrorContainerEls.reverse();
          this.fgContainerEls.reverse();
          this.bgContainerEls.reverse();
          this.highlightContainerEls.reverse();
          this.businessContainerEls.reverse();
        }

        this.el.appendChild(skeletonEl);
      };

      TimeGrid.prototype.unrenderContentSkeleton = function () {
        Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"])(this.contentSkeletonEl);
      }; // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col


      TimeGrid.prototype.groupSegsByCol = function (segs) {
        var segsByCol = [];
        var i;

        for (i = 0; i < this.colCnt; i++) {
          segsByCol.push([]);
        }

        for (i = 0; i < segs.length; i++) {
          segsByCol[segs[i].col].push(segs[i]);
        }

        return segsByCol;
      }; // Given segments grouped by column, insert the segments' elements into a parallel array of container
      // elements, each living within a column.


      TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
        var col;
        var segs;
        var i;

        for (col = 0; col < this.colCnt; col++) {
          // iterate each column grouping
          segs = segsByCol[col];

          for (i = 0; i < segs.length; i++) {
            containerEls[col].appendChild(segs[i].el);
          }
        }
      };
      /* Now Indicator
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype.getNowIndicatorUnit = function () {
        return 'minute'; // will refresh on the minute
      };

      TimeGrid.prototype.renderNowIndicator = function (segs, date) {
        // HACK: if date columns not ready for some reason (scheduler)
        if (!this.colContainerEls) {
          return;
        }

        var top = this.computeDateTop(date);
        var nodes = [];
        var i; // render lines within the columns

        for (i = 0; i < segs.length; i++) {
          var lineEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', {
            className: 'fc-now-indicator fc-now-indicator-line'
          });
          lineEl.style.top = top + 'px';
          this.colContainerEls[segs[i].col].appendChild(lineEl);
          nodes.push(lineEl);
        } // render an arrow over the axis


        if (segs.length > 0) {
          // is the current time in view?
          var arrowEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', {
            className: 'fc-now-indicator fc-now-indicator-arrow'
          });
          arrowEl.style.top = top + 'px';
          this.contentSkeletonEl.appendChild(arrowEl);
          nodes.push(arrowEl);
        }

        this.nowIndicatorEls = nodes;
      };

      TimeGrid.prototype.unrenderNowIndicator = function () {
        if (this.nowIndicatorEls) {
          this.nowIndicatorEls.forEach(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["removeElement"]);
          this.nowIndicatorEls = null;
        }
      };
      /* Coordinates
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype.getTotalSlatHeight = function () {
        return this.slatContainerEl.getBoundingClientRect().height;
      }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.
      // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.


      TimeGrid.prototype.computeDateTop = function (when, startOfDayDate) {
        if (!startOfDayDate) {
          startOfDayDate = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["startOfDay"])(when);
        }

        return this.computeTimeTop(Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createDuration"])(when.valueOf() - startOfDayDate.valueOf()));
      }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).


      TimeGrid.prototype.computeTimeTop = function (duration) {
        var len = this.slatEls.length;
        var dateProfile = this.props.dateProfile;
        var slatCoverage = (duration.milliseconds - Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["asRoughMs"])(dateProfile.minTime)) / Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["asRoughMs"])(this.slotDuration); // floating-point value of # of slots covered

        var slatIndex;
        var slatRemainder; // compute a floating-point number for how many slats should be progressed through.
        // from 0 to number of slats (inclusive)
        // constrained because minTime/maxTime might be customized.

        slatCoverage = Math.max(0, slatCoverage);
        slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat
        // from 0 to number slats (*exclusive*, so len-1)

        slatIndex = Math.floor(slatCoverage);
        slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
        // could be 1.0 if slatCoverage is covering *all* the slots

        slatRemainder = slatCoverage - slatIndex;
        return this.slatPositions.tops[slatIndex] + this.slatPositions.getHeight(slatIndex) * slatRemainder;
      }; // For each segment in an array, computes and assigns its top and bottom properties


      TimeGrid.prototype.computeSegVerticals = function (segs) {
        var options = this.context.options;
        var eventMinHeight = options.timeGridEventMinHeight;
        var i;
        var seg;
        var dayDate;

        for (i = 0; i < segs.length; i++) {
          seg = segs[i];
          dayDate = this.props.cells[seg.col].date;
          seg.top = this.computeDateTop(seg.start, dayDate);
          seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.end, dayDate));
        }
      }; // Given segments that already have their top/bottom properties computed, applies those values to
      // the segments' elements.


      TimeGrid.prototype.assignSegVerticals = function (segs) {
        var i;
        var seg;

        for (i = 0; i < segs.length; i++) {
          seg = segs[i];
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["applyStyle"])(seg.el, this.generateSegVerticalCss(seg));
        }
      }; // Generates an object with CSS properties for the top/bottom coordinates of a segment element


      TimeGrid.prototype.generateSegVerticalCss = function (seg) {
        return {
          top: seg.top,
          bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container

        };
      };
      /* Sizing
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype.buildPositionCaches = function () {
        this.buildColPositions();
        this.buildSlatPositions();
      };

      TimeGrid.prototype.buildColPositions = function () {
        this.colPositions.build();
      };

      TimeGrid.prototype.buildSlatPositions = function () {
        this.slatPositions.build();
      };
      /* Hit System
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype.positionToHit = function (positionLeft, positionTop) {
        var dateEnv = this.context.dateEnv;

        var _a = this,
            snapsPerSlot = _a.snapsPerSlot,
            slatPositions = _a.slatPositions,
            colPositions = _a.colPositions;

        var colIndex = colPositions.leftToIndex(positionLeft);
        var slatIndex = slatPositions.topToIndex(positionTop);

        if (colIndex != null && slatIndex != null) {
          var slatTop = slatPositions.tops[slatIndex];
          var slatHeight = slatPositions.getHeight(slatIndex);
          var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1

          var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat

          var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
          var dayDate = this.props.cells[colIndex].date;
          var time = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["addDurations"])(this.props.dateProfile.minTime, Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["multiplyDuration"])(this.snapDuration, snapIndex));
          var start = dateEnv.add(dayDate, time);
          var end = dateEnv.add(start, this.snapDuration);
          return {
            col: colIndex,
            dateSpan: {
              range: {
                start: start,
                end: end
              },
              allDay: false
            },
            dayEl: this.colEls[colIndex],
            relativeRect: {
              left: colPositions.lefts[colIndex],
              right: colPositions.rights[colIndex],
              top: slatTop,
              bottom: slatTop + slatHeight
            }
          };
        }
      };
      /* Event Drag Visualization
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype._renderEventDrag = function (state) {
        if (state) {
          this.eventRenderer.hideByHash(state.affectedInstances);

          if (state.isEvent) {
            this.mirrorRenderer.renderSegs(this.context, state.segs, {
              isDragging: true,
              sourceSeg: state.sourceSeg
            });
          } else {
            this.fillRenderer.renderSegs('highlight', this.context, state.segs);
          }
        }
      };

      TimeGrid.prototype._unrenderEventDrag = function (state) {
        if (state) {
          this.eventRenderer.showByHash(state.affectedInstances);

          if (state.isEvent) {
            this.mirrorRenderer.unrender(this.context, state.segs, {
              isDragging: true,
              sourceSeg: state.sourceSeg
            });
          } else {
            this.fillRenderer.unrender('highlight', this.context);
          }
        }
      };
      /* Event Resize Visualization
      ------------------------------------------------------------------------------------------------------------------*/


      TimeGrid.prototype._renderEventResize = function (state) {
        if (state) {
          this.eventRenderer.hideByHash(state.affectedInstances);
          this.mirrorRenderer.renderSegs(this.context, state.segs, {
            isResizing: true,
            sourceSeg: state.sourceSeg
          });
        }
      };

      TimeGrid.prototype._unrenderEventResize = function (state) {
        if (state) {
          this.eventRenderer.showByHash(state.affectedInstances);
          this.mirrorRenderer.unrender(this.context, state.segs, {
            isResizing: true,
            sourceSeg: state.sourceSeg
          });
        }
      };
      /* Selection
      ------------------------------------------------------------------------------------------------------------------*/
      // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.


      TimeGrid.prototype._renderDateSelection = function (segs) {
        if (segs) {
          if (this.context.options.selectMirror) {
            this.mirrorRenderer.renderSegs(this.context, segs, {
              isSelecting: true
            });
          } else {
            this.fillRenderer.renderSegs('highlight', this.context, segs);
          }
        }
      };

      TimeGrid.prototype._unrenderDateSelection = function (segs) {
        if (segs) {
          if (this.context.options.selectMirror) {
            this.mirrorRenderer.unrender(this.context, segs, {
              isSelecting: true
            });
          } else {
            this.fillRenderer.unrender('highlight', this.context);
          }
        }
      };

      return TimeGrid;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DateComponent"]);

    var AllDaySplitter =
    /** @class */
    function (_super) {
      __extends(AllDaySplitter, _super);

      function AllDaySplitter() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      AllDaySplitter.prototype.getKeyInfo = function () {
        return {
          allDay: {},
          timed: {}
        };
      };

      AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {
        if (dateSpan.allDay) {
          return ['allDay'];
        } else {
          return ['timed'];
        }
      };

      AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {
        if (!eventDef.allDay) {
          return ['timed'];
        } else if (Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["hasBgRendering"])(eventDef)) {
          return ['timed', 'allDay'];
        } else {
          return ['allDay'];
        }
      };

      return AllDaySplitter;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["Splitter"]);

    var TIMEGRID_ALL_DAY_EVENT_LIMIT = 5;
    var WEEK_HEADER_FORMAT = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createFormatter"])({
      week: 'short'
    });
    /* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.
    ----------------------------------------------------------------------------------------------------------------------*/
    // Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
    // Responsible for managing width/height.

    var AbstractTimeGridView =
    /** @class */
    function (_super) {
      __extends(AbstractTimeGridView, _super);

      function AbstractTimeGridView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.splitter = new AllDaySplitter();
        _this.renderSkeleton = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoizeRendering"])(_this._renderSkeleton, _this._unrenderSkeleton);
        /* Header Render Methods
        ------------------------------------------------------------------------------------------------------------------*/
        // Generates the HTML that will go before the day-of week header cells

        _this.renderHeadIntroHtml = function () {
          var _a = _this.context,
              theme = _a.theme,
              dateEnv = _a.dateEnv,
              options = _a.options;
          var range = _this.props.dateProfile.renderRange;
          var dayCnt = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["diffDays"])(range.start, range.end);
          var weekText;

          if (options.weekNumbers) {
            weekText = dateEnv.format(range.start, WEEK_HEADER_FORMAT);
            return '' + '<th class="fc-axis fc-week-number ' + theme.getClass('widgetHeader') + '" ' + _this.axisStyleAttr() + '>' + Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["buildGotoAnchorHtml"])( // aside from link, important for matchCellWidths
            options, dateEnv, {
              date: range.start,
              type: 'week',
              forceOff: dayCnt > 1
            }, Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["htmlEscape"])(weekText) // inner HTML
            ) + '</th>';
          } else {
            return '<th class="fc-axis ' + theme.getClass('widgetHeader') + '" ' + _this.axisStyleAttr() + '></th>';
          }
        };
        /* Time Grid Render Methods
        ------------------------------------------------------------------------------------------------------------------*/
        // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.


        _this.renderTimeGridBgIntroHtml = function () {
          var theme = _this.context.theme;
          return '<td class="fc-axis ' + theme.getClass('widgetContent') + '" ' + _this.axisStyleAttr() + '></td>';
        }; // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.


        _this.renderTimeGridIntroHtml = function () {
          return '<td class="fc-axis" ' + _this.axisStyleAttr() + '></td>';
        };
        /* Day Grid Render Methods
        ------------------------------------------------------------------------------------------------------------------*/
        // Generates the HTML that goes before the all-day cells


        _this.renderDayGridBgIntroHtml = function () {
          var _a = _this.context,
              theme = _a.theme,
              options = _a.options;
          return '' + '<td class="fc-axis ' + theme.getClass('widgetContent') + '" ' + _this.axisStyleAttr() + '>' + '<span>' + // needed for matchCellWidths
          Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["getAllDayHtml"])(options) + '</span>' + '</td>';
        }; // Generates the HTML that goes before all other types of cells.
        // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.


        _this.renderDayGridIntroHtml = function () {
          return '<td class="fc-axis" ' + _this.axisStyleAttr() + '></td>';
        };

        return _this;
      }

      AbstractTimeGridView.prototype.render = function (props, context) {
        _super.prototype.render.call(this, props, context);

        this.renderSkeleton(context);
      };

      AbstractTimeGridView.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.renderSkeleton.unrender();
      };

      AbstractTimeGridView.prototype._renderSkeleton = function (context) {
        this.el.classList.add('fc-timeGrid-view');
        this.el.innerHTML = this.renderSkeletonHtml();
        this.scroller = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["ScrollComponent"]('hidden', // overflow x
        'auto' // overflow y
        );
        var timeGridWrapEl = this.scroller.el;
        this.el.querySelector('.fc-body > tr > td').appendChild(timeGridWrapEl);
        timeGridWrapEl.classList.add('fc-time-grid-container');
        var timeGridEl = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createElement"])('div', {
          className: 'fc-time-grid'
        });
        timeGridWrapEl.appendChild(timeGridEl);
        this.timeGrid = new TimeGrid(timeGridEl, {
          renderBgIntroHtml: this.renderTimeGridBgIntroHtml,
          renderIntroHtml: this.renderTimeGridIntroHtml
        });

        if (context.options.allDaySlot) {
          // should we display the "all-day" area?
          this.dayGrid = new _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__["DayGrid"]( // the all-day subcomponent of this view
          this.el.querySelector('.fc-day-grid'), {
            renderNumberIntroHtml: this.renderDayGridIntroHtml,
            renderBgIntroHtml: this.renderDayGridBgIntroHtml,
            renderIntroHtml: this.renderDayGridIntroHtml,
            colWeekNumbersVisible: false,
            cellWeekNumbersVisible: false
          }); // have the day-grid extend it's coordinate area over the <hr> dividing the two grids

          var dividerEl = this.el.querySelector('.fc-divider');
          this.dayGrid.bottomCoordPadding = dividerEl.getBoundingClientRect().height;
        }
      };

      AbstractTimeGridView.prototype._unrenderSkeleton = function () {
        this.el.classList.remove('fc-timeGrid-view');
        this.timeGrid.destroy();

        if (this.dayGrid) {
          this.dayGrid.destroy();
        }

        this.scroller.destroy();
      };
      /* Rendering
      ------------------------------------------------------------------------------------------------------------------*/
      // Builds the HTML skeleton for the view.
      // The day-grid and time-grid components will render inside containers defined by this HTML.


      AbstractTimeGridView.prototype.renderSkeletonHtml = function () {
        var _a = this.context,
            theme = _a.theme,
            options = _a.options;
        return '' + '<table class="' + theme.getClass('tableGrid') + '">' + (options.columnHeader ? '<thead class="fc-head">' + '<tr>' + '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class="fc-body">' + '<tr>' + '<td class="' + theme.getClass('widgetContent') + '">' + (options.allDaySlot ? '<div class="fc-day-grid"></div>' + '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" />' : '') + '</td>' + '</tr>' + '</tbody>' + '</table>';
      };
      /* Now Indicator
      ------------------------------------------------------------------------------------------------------------------*/


      AbstractTimeGridView.prototype.getNowIndicatorUnit = function () {
        return this.timeGrid.getNowIndicatorUnit();
      }; // subclasses should implement
      // renderNowIndicator(date: DateMarker) {
      // }


      AbstractTimeGridView.prototype.unrenderNowIndicator = function () {
        this.timeGrid.unrenderNowIndicator();
      };
      /* Dimensions
      ------------------------------------------------------------------------------------------------------------------*/


      AbstractTimeGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {
        _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first


        this.timeGrid.updateSize(isResize);

        if (this.dayGrid) {
          this.dayGrid.updateSize(isResize);
        }
      }; // Adjusts the vertical dimensions of the view to the specified values


      AbstractTimeGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {
        var _this = this;

        var eventLimit;
        var scrollerHeight;
        var scrollbarWidths; // make all axis cells line up

        this.axisWidth = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["matchCellWidths"])(Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.el, '.fc-axis')); // hack to give the view some height prior to timeGrid's columns being rendered
        // TODO: separate setting height from scroller VS timeGrid.

        if (!this.timeGrid.colEls) {
          if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(viewHeight);
            this.scroller.setHeight(scrollerHeight);
          }

          return;
        } // set of fake row elements that must compensate when scroller has scrollbars


        var noScrollRowEls = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["findElements"])(this.el, '.fc-row').filter(function (node) {
          return !_this.scroller.el.contains(node);
        }); // reset all dimensions back to the original state

        this.timeGrid.bottomRuleEl.style.display = 'none'; // will be shown later if this <hr> is necessary

        this.scroller.clear(); // sets height to 'auto' and clears overflow

        noScrollRowEls.forEach(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["uncompensateScroll"]); // limit number of events in the all-day area

        if (this.dayGrid) {
          this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

          eventLimit = this.context.options.eventLimit;

          if (eventLimit && typeof eventLimit !== 'number') {
            eventLimit = TIMEGRID_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
          }

          if (eventLimit) {
            this.dayGrid.limitRows(eventLimit);
          }
        }

        if (!isAuto) {
          // should we force dimensions of the scroll container?
          scrollerHeight = this.computeScrollerHeight(viewHeight);
          this.scroller.setHeight(scrollerHeight);
          scrollbarWidths = this.scroller.getScrollbarWidths();

          if (scrollbarWidths.left || scrollbarWidths.right) {
            // using scrollbars?
            // make the all-day and header rows lines up
            noScrollRowEls.forEach(function (rowEl) {
              Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["compensateScroll"])(rowEl, scrollbarWidths);
            }); // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
            // and reapply the desired height to the scroller.

            scrollerHeight = this.computeScrollerHeight(viewHeight);
            this.scroller.setHeight(scrollerHeight);
          } // guarantees the same scrollbar widths


          this.scroller.lockOverflow(scrollbarWidths); // if there's any space below the slats, show the horizontal rule.
          // this won't cause any new overflow, because lockOverflow already called.

          if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
            this.timeGrid.bottomRuleEl.style.display = '';
          }
        }
      }; // given a desired total height of the view, returns what the height of the scroller should be


      AbstractTimeGridView.prototype.computeScrollerHeight = function (viewHeight) {
        return viewHeight - Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["subtractInnerElHeight"])(this.el, this.scroller.el); // everything that's NOT the scroller
      };
      /* Scroll
      ------------------------------------------------------------------------------------------------------------------*/
      // Computes the initial pre-configured scroll state prior to allowing the user to change it


      AbstractTimeGridView.prototype.computeDateScroll = function (duration) {
        var top = this.timeGrid.computeTimeTop(duration); // zoom can give weird floating-point values. rather scroll a little bit further

        top = Math.ceil(top);

        if (top) {
          top++; // to overcome top border that slots beyond the first have. looks better
        }

        return {
          top: top
        };
      };

      AbstractTimeGridView.prototype.queryDateScroll = function () {
        return {
          top: this.scroller.getScrollTop()
        };
      };

      AbstractTimeGridView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
          this.scroller.setScrollTop(scroll.top);
        }
      }; // Generates an HTML attribute string for setting the width of the axis, if it is known


      AbstractTimeGridView.prototype.axisStyleAttr = function () {
        if (this.axisWidth != null) {
          return 'style="width:' + this.axisWidth + 'px"';
        }

        return '';
      };

      return AbstractTimeGridView;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["View"]);

    AbstractTimeGridView.prototype.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering

    var SimpleTimeGrid =
    /** @class */
    function (_super) {
      __extends(SimpleTimeGrid, _super);

      function SimpleTimeGrid(timeGrid) {
        var _this = _super.call(this, timeGrid.el) || this;

        _this.buildDayRanges = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoize"])(buildDayRanges);
        _this.slicer = new TimeGridSlicer();
        _this.timeGrid = timeGrid;
        return _this;
      }

      SimpleTimeGrid.prototype.firstContext = function (context) {
        context.calendar.registerInteractiveComponent(this, {
          el: this.timeGrid.el
        });
      };

      SimpleTimeGrid.prototype.destroy = function () {
        _super.prototype.destroy.call(this);

        this.context.calendar.unregisterInteractiveComponent(this);
      };

      SimpleTimeGrid.prototype.render = function (props, context) {
        var dateEnv = this.context.dateEnv;
        var dateProfile = props.dateProfile,
            dayTable = props.dayTable;
        var dayRanges = this.dayRanges = this.buildDayRanges(dayTable, dateProfile, dateEnv);
        var timeGrid = this.timeGrid;
        timeGrid.receiveContext(context); // hack because context is used in sliceProps

        timeGrid.receiveProps(_assign3({}, this.slicer.sliceProps(props, dateProfile, null, context.calendar, timeGrid, dayRanges), {
          dateProfile: dateProfile,
          cells: dayTable.cells[0]
        }), context);
      };

      SimpleTimeGrid.prototype.renderNowIndicator = function (date) {
        this.timeGrid.renderNowIndicator(this.slicer.sliceNowDate(date, this.timeGrid, this.dayRanges), date);
      };

      SimpleTimeGrid.prototype.buildPositionCaches = function () {
        this.timeGrid.buildPositionCaches();
      };

      SimpleTimeGrid.prototype.queryHit = function (positionLeft, positionTop) {
        var rawHit = this.timeGrid.positionToHit(positionLeft, positionTop);

        if (rawHit) {
          return {
            component: this.timeGrid,
            dateSpan: rawHit.dateSpan,
            dayEl: rawHit.dayEl,
            rect: {
              left: rawHit.relativeRect.left,
              right: rawHit.relativeRect.right,
              top: rawHit.relativeRect.top,
              bottom: rawHit.relativeRect.bottom
            },
            layer: 0
          };
        }
      };

      return SimpleTimeGrid;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DateComponent"]);

    function buildDayRanges(dayTable, dateProfile, dateEnv) {
      var ranges = [];

      for (var _i = 0, _a = dayTable.headerDates; _i < _a.length; _i++) {
        var date = _a[_i];
        ranges.push({
          start: dateEnv.add(date, dateProfile.minTime),
          end: dateEnv.add(date, dateProfile.maxTime)
        });
      }

      return ranges;
    }

    var TimeGridSlicer =
    /** @class */
    function (_super) {
      __extends(TimeGridSlicer, _super);

      function TimeGridSlicer() {
        return _super !== null && _super.apply(this, arguments) || this;
      }

      TimeGridSlicer.prototype.sliceRange = function (range, dayRanges) {
        var segs = [];

        for (var col = 0; col < dayRanges.length; col++) {
          var segRange = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["intersectRanges"])(range, dayRanges[col]);

          if (segRange) {
            segs.push({
              start: segRange.start,
              end: segRange.end,
              isStart: segRange.start.valueOf() === range.start.valueOf(),
              isEnd: segRange.end.valueOf() === range.end.valueOf(),
              col: col
            });
          }
        }

        return segs;
      };

      return TimeGridSlicer;
    }(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["Slicer"]);

    var TimeGridView =
    /** @class */
    function (_super) {
      __extends(TimeGridView, _super);

      function TimeGridView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;

        _this.buildDayTable = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["memoize"])(buildDayTable);
        return _this;
      }

      TimeGridView.prototype.render = function (props, context) {
        _super.prototype.render.call(this, props, context); // for flags for updateSize. also _renderSkeleton/_unrenderSkeleton


        var _a = this.props,
            dateProfile = _a.dateProfile,
            dateProfileGenerator = _a.dateProfileGenerator;
        var nextDayThreshold = context.nextDayThreshold;
        var dayTable = this.buildDayTable(dateProfile, dateProfileGenerator);
        var splitProps = this.splitter.splitProps(props);

        if (this.header) {
          this.header.receiveProps({
            dateProfile: dateProfile,
            dates: dayTable.headerDates,
            datesRepDistinctDays: true,
            renderIntroHtml: this.renderHeadIntroHtml
          }, context);
        }

        this.simpleTimeGrid.receiveProps(_assign3({}, splitProps['timed'], {
          dateProfile: dateProfile,
          dayTable: dayTable
        }), context);

        if (this.simpleDayGrid) {
          this.simpleDayGrid.receiveProps(_assign3({}, splitProps['allDay'], {
            dateProfile: dateProfile,
            dayTable: dayTable,
            nextDayThreshold: nextDayThreshold,
            isRigid: false
          }), context);
        }

        this.startNowIndicator(dateProfile, dateProfileGenerator);
      };

      TimeGridView.prototype._renderSkeleton = function (context) {
        _super.prototype._renderSkeleton.call(this, context);

        if (context.options.columnHeader) {
          this.header = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DayHeader"](this.el.querySelector('.fc-head-container'));
        }

        this.simpleTimeGrid = new SimpleTimeGrid(this.timeGrid);

        if (this.dayGrid) {
          this.simpleDayGrid = new _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_1__["SimpleDayGrid"](this.dayGrid);
        }
      };

      TimeGridView.prototype._unrenderSkeleton = function () {
        _super.prototype._unrenderSkeleton.call(this);

        if (this.header) {
          this.header.destroy();
        }

        this.simpleTimeGrid.destroy();

        if (this.simpleDayGrid) {
          this.simpleDayGrid.destroy();
        }
      };

      TimeGridView.prototype.renderNowIndicator = function (date) {
        this.simpleTimeGrid.renderNowIndicator(date);
      };

      return TimeGridView;
    }(AbstractTimeGridView);

    function buildDayTable(dateProfile, dateProfileGenerator) {
      var daySeries = new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DaySeries"](dateProfile.renderRange, dateProfileGenerator);
      return new _fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["DayTable"](daySeries, false);
    }

    var main = Object(_fullcalendar_core__WEBPACK_IMPORTED_MODULE_0__["createPlugin"])({
      defaultView: 'timeGridWeek',
      views: {
        timeGrid: {
          "class": TimeGridView,
          allDaySlot: true,
          slotDuration: '00:30:00',
          slotEventOverlap: true // a bad name. confused with overlap/constraint system

        },
        timeGridDay: {
          type: 'timeGrid',
          duration: {
            days: 1
          }
        },
        timeGridWeek: {
          type: 'timeGrid',
          duration: {
            weeks: 1
          }
        }
      }
    });
    /* harmony default export */

    __webpack_exports__["default"] = main;
    /***/
  },

  /***/
  "./node_modules/fast-deep-equal/index.js":
  /*!***********************************************!*\
    !*** ./node_modules/fast-deep-equal/index.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesFastDeepEqualIndexJs(module, exports, __webpack_require__) {
    "use strict"; // do not edit .js files directly - edit src/index.jst

    module.exports = function equal(a, b) {
      if (a === b) return true;

      if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;

        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;

          for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;

          return true;
        }

        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;

        for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

        for (i = length; i-- !== 0;) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }

        return true;
      } // true if both NaN, false otherwise


      return a !== a && b !== b;
    };
    /***/

  },

  /***/
  "./node_modules/highcharts/highcharts.js":
  /*!***********************************************!*\
    !*** ./node_modules/highcharts/highcharts.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesHighchartsHighchartsJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    /*
    Highcharts JS v8.2.2 (2020-10-22)
    (c) 2009-2018 Torstein Honsi
    License: www.highcharts.com/license
    */


    (function (X, N) {
      true && module.exports ? (N["default"] = N, module.exports = X.document ? N(X) : N) : true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
        return N(X);
      }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
    })("undefined" !== typeof window ? window : this, function (X) {
      function N(f, h, m, z) {
        f.hasOwnProperty(h) || (f[h] = z.apply(null, m));
      }

      var m = {};
      N(m, "Core/Globals.js", [], function () {
        var f = "undefined" !== typeof X ? X : "undefined" !== typeof window ? window : {},
            h = f.document,
            m = f.navigator && f.navigator.userAgent || "",
            z = h && h.createElementNS && !!h.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
            F = /(edge|msie|trident)/i.test(m) && !f.opera,
            L = -1 !== m.indexOf("Firefox"),
            K = -1 !== m.indexOf("Chrome"),
            C = L && 4 > parseInt(m.split("Firefox/")[1], 10);
        return {
          product: "Highcharts",
          version: "8.2.2",
          deg2rad: 2 * Math.PI / 360,
          doc: h,
          hasBidiBug: C,
          hasTouch: !!f.TouchEvent,
          isMS: F,
          isWebKit: -1 !== m.indexOf("AppleWebKit"),
          isFirefox: L,
          isChrome: K,
          isSafari: !K && -1 !== m.indexOf("Safari"),
          isTouchDevice: /(Mobile|Android|Windows Phone)/.test(m),
          SVG_NS: "http://www.w3.org/2000/svg",
          chartCount: 0,
          seriesTypes: {},
          symbolSizes: {},
          svg: z,
          win: f,
          marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"],
          noop: function noop() {},
          charts: [],
          dateFormats: {}
        };
      });
      N(m, "Core/Utilities.js", [m["Core/Globals.js"]], function (f) {
        function h(b, k, t, a) {
          var u = k ? "Highcharts error" : "Highcharts warning";
          32 === b && (b = u + ": Deprecated member");
          var c = l(b),
              H = c ? u + " #" + b + ": www.highcharts.com/errors/" + b + "/" : b.toString();

          u = function u() {
            if (k) throw Error(H);
            e.console && -1 === h.messages.indexOf(H) && console.log(H);
          };

          if ("undefined" !== typeof a) {
            var d = "";
            c && (H += "?");
            S(a, function (b, k) {
              d += "\n - " + k + ": " + b;
              c && (H += encodeURI(k) + "=" + encodeURI(b));
            });
            H += d;
          }

          t ? ca(t, "displayError", {
            code: b,
            message: H,
            params: a
          }, u) : u();
          h.messages.push(H);
        }

        function m() {
          var b,
              k = arguments,
              t = {},
              a = function a(b, k) {
            "object" !== typeof b && (b = {});
            S(k, function (t, u) {
              !z(t, !0) || n(t) || D(t) ? b[u] = k[u] : b[u] = a(b[u] || {}, t);
            });
            return b;
          };

          !0 === k[0] && (t = k[1], k = Array.prototype.slice.call(k, 2));
          var u = k.length;

          for (b = 0; b < u; b++) t = a(t, k[b]);

          return t;
        }

        function z(b, k) {
          return !!b && "object" === typeof b && (!k || !x(b));
        }

        function F(b, k, t) {
          var a;
          v(k) ? w(t) ? b.setAttribute(k, t) : b && b.getAttribute && ((a = b.getAttribute(k)) || "class" !== k || (a = b.getAttribute(k + "Name"))) : S(k, function (k, t) {
            b.setAttribute(t, k);
          });
          return a;
        }

        function L() {
          for (var b = arguments, k = b.length, t = 0; t < k; t++) {
            var a = b[t];
            if ("undefined" !== typeof a && null !== a) return a;
          }
        }

        function K(b, k) {
          if (!b) return k;
          var t = b.split(".").reverse();
          if (1 === t.length) return k[b];

          for (b = t.pop(); "undefined" !== typeof b && "undefined" !== typeof k && null !== k;) k = k[b], b = t.pop();

          return k;
        }

        f.timers = [];
        var C = f.charts,
            y = f.doc,
            e = f.win;
        (h || (h = {})).messages = [];
        f.error = h;
        f.merge = m;

        var I = f.pInt = function (b, k) {
          return parseInt(b, k || 10);
        },
            v = f.isString = function (b) {
          return "string" === typeof b;
        },
            x = f.isArray = function (b) {
          b = Object.prototype.toString.call(b);
          return "[object Array]" === b || "[object Array Iterator]" === b;
        };

        f.isObject = z;

        var D = f.isDOMElement = function (b) {
          return z(b) && "number" === typeof b.nodeType;
        },
            n = f.isClass = function (b) {
          var k = b && b.constructor;
          return !(!z(b, !0) || D(b) || !k || !k.name || "Object" === k.name);
        },
            l = f.isNumber = function (b) {
          return "number" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;
        },
            J = f.erase = function (b, k) {
          for (var t = b.length; t--;) if (b[t] === k) {
            b.splice(t, 1);
            break;
          }
        },
            w = f.defined = function (b) {
          return "undefined" !== typeof b && null !== b;
        };

        f.attr = F;

        var r = f.splat = function (b) {
          return x(b) ? b : [b];
        },
            d = f.syncTimeout = function (b, k, t) {
          if (0 < k) return setTimeout(b, k, t);
          b.call(0, t);
          return -1;
        },
            g = f.clearTimeout = function (b) {
          w(b) && clearTimeout(b);
        },
            c = f.extend = function (b, k) {
          var t;
          b || (b = {});

          for (t in k) b[t] = k[t];

          return b;
        };

        f.pick = L;

        var a = f.css = function (b, k) {
          f.isMS && !f.svg && k && "undefined" !== typeof k.opacity && (k.filter = "alpha(opacity=" + 100 * k.opacity + ")");
          c(b.style, k);
        },
            q = f.createElement = function (b, k, t, u, H) {
          b = y.createElement(b);
          k && c(b, k);
          H && a(b, {
            padding: "0",
            border: "none",
            margin: "0"
          });
          t && a(b, t);
          u && u.appendChild(b);
          return b;
        },
            p = f.extendClass = function (b, k) {
          var t = function t() {};

          t.prototype = new b();
          c(t.prototype, k);
          return t;
        },
            B = f.pad = function (b, k, t) {
          return Array((k || 2) + 1 - String(b).replace("-", "").length).join(t || "0") + b;
        },
            A = f.relativeLength = function (b, k, t) {
          return /%$/.test(b) ? k * parseFloat(b) / 100 + (t || 0) : parseFloat(b);
        },
            G = f.wrap = function (b, k, t) {
          var a = b[k];

          b[k] = function () {
            var b = Array.prototype.slice.call(arguments),
                k = arguments,
                u = this;

            u.proceed = function () {
              a.apply(u, arguments.length ? arguments : k);
            };

            b.unshift(a);
            b = t.apply(this, b);
            u.proceed = null;
            return b;
          };
        },
            M = f.format = function (b, k, t) {
          var a = "{",
              u = !1,
              H = [],
              c = /f$/,
              d = /\.([0-9])/,
              g = f.defaultOptions.lang,
              p = t && t.time || f.time;

          for (t = t && t.numberFormatter || R; b;) {
            var q = b.indexOf(a);
            if (-1 === q) break;
            var U = b.slice(0, q);

            if (u) {
              U = U.split(":");
              a = K(U.shift() || "", k);
              if (U.length && "number" === typeof a) if (U = U.join(":"), c.test(U)) {
                var r = parseInt((U.match(d) || ["", "-1"])[1], 10);
                null !== a && (a = t(a, r, g.decimalPoint, -1 < U.indexOf(",") ? g.thousandsSep : ""));
              } else a = p.dateFormat(U, a);
              H.push(a);
            } else H.push(U);

            b = b.slice(q + 1);
            a = (u = !u) ? "}" : "{";
          }

          H.push(b);
          return H.join("");
        },
            T = f.getMagnitude = function (b) {
          return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));
        },
            Q = f.normalizeTickInterval = function (b, k, a, u, H) {
          var c = b;
          a = L(a, 1);
          var d = b / a;
          k || (k = H ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === u && (1 === a ? k = k.filter(function (b) {
            return 0 === b % 1;
          }) : .1 >= a && (k = [1 / a])));

          for (u = 0; u < k.length && !(c = k[u], H && c * a >= b || !H && d <= (k[u] + (k[u + 1] || k[u])) / 2); u++);

          return c = t(c * a, -Math.round(Math.log(.001) / Math.LN10));
        },
            O = f.stableSort = function (b, k) {
          var t = b.length,
              a,
              u;

          for (u = 0; u < t; u++) b[u].safeI = u;

          b.sort(function (b, t) {
            a = k(b, t);
            return 0 === a ? b.safeI - t.safeI : a;
          });

          for (u = 0; u < t; u++) delete b[u].safeI;
        },
            E = f.arrayMin = function (b) {
          for (var k = b.length, t = b[0]; k--;) b[k] < t && (t = b[k]);

          return t;
        },
            u = f.arrayMax = function (b) {
          for (var k = b.length, t = b[0]; k--;) b[k] > t && (t = b[k]);

          return t;
        },
            b = f.destroyObjectProperties = function (b, k) {
          S(b, function (t, a) {
            t && t !== k && t.destroy && t.destroy();
            delete b[a];
          });
        },
            k = f.discardElement = function (b) {
          var k = f.garbageBin;
          k || (k = q("div"));
          b && k.appendChild(b);
          k.innerHTML = "";
        },
            t = f.correctFloat = function (b, k) {
          return parseFloat(b.toPrecision(k || 14));
        },
            H = f.timeUnits = {
          millisecond: 1,
          second: 1E3,
          minute: 6E4,
          hour: 36E5,
          day: 864E5,
          week: 6048E5,
          month: 24192E5,
          year: 314496E5
        },
            R = f.numberFormat = function (b, k, t, a) {
          b = +b || 0;
          k = +k;
          var u = f.defaultOptions.lang,
              H = (b.toString().split(".")[1] || "").split("e")[0].length,
              c = b.toString().split("e");
          if (-1 === k) k = Math.min(H, 20);else if (!l(k)) k = 2;else if (k && c[1] && 0 > c[1]) {
            var d = k + +c[1];
            0 <= d ? (c[0] = (+c[0]).toExponential(d).split("e")[0], k = d) : (c[0] = c[0].split(".")[0] || 0, b = 20 > k ? (c[0] * Math.pow(10, c[1])).toFixed(k) : 0, c[1] = 0);
          }
          var g = (Math.abs(c[1] ? c[0] : b) + Math.pow(10, -Math.max(k, H) - 1)).toFixed(k);
          H = String(I(g));
          d = 3 < H.length ? H.length % 3 : 0;
          t = L(t, u.decimalPoint);
          a = L(a, u.thousandsSep);
          b = (0 > b ? "-" : "") + (d ? H.substr(0, d) + a : "");
          b += H.substr(d).replace(/(\d{3})(?=\d)/g, "$1" + a);
          k && (b += t + g.slice(-k));
          c[1] && 0 !== +b && (b += "e" + c[1]);
          return b;
        };

        Math.easeInOutSine = function (b) {
          return -.5 * (Math.cos(Math.PI * b) - 1);
        };

        var U = f.getStyle = function (b, k, t) {
          if ("width" === k) return k = Math.min(b.offsetWidth, b.scrollWidth), t = b.getBoundingClientRect && b.getBoundingClientRect().width, t < k && t >= k - 1 && (k = Math.floor(t)), Math.max(0, k - f.getStyle(b, "padding-left") - f.getStyle(b, "padding-right"));
          if ("height" === k) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - f.getStyle(b, "padding-top") - f.getStyle(b, "padding-bottom"));
          e.getComputedStyle || h(27, !0);
          if (b = e.getComputedStyle(b, void 0)) b = b.getPropertyValue(k), L(t, "opacity" !== k) && (b = I(b));
          return b;
        },
            Z = f.inArray = function (b, k, t) {
          h(32, !1, void 0, {
            "Highcharts.inArray": "use Array.indexOf"
          });
          return k.indexOf(b, t);
        },
            aa = f.find = Array.prototype.find ? function (b, k) {
          return b.find(k);
        } : function (b, k) {
          var t,
              a = b.length;

          for (t = 0; t < a; t++) if (k(b[t], t)) return b[t];
        };

        f.keys = function (b) {
          h(32, !1, void 0, {
            "Highcharts.keys": "use Object.keys"
          });
          return Object.keys(b);
        };

        var ba = f.offset = function (b) {
          var k = y.documentElement;
          b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {
            top: 0,
            left: 0
          };
          return {
            top: b.top + (e.pageYOffset || k.scrollTop) - (k.clientTop || 0),
            left: b.left + (e.pageXOffset || k.scrollLeft) - (k.clientLeft || 0)
          };
        },
            S = f.objectEach = function (b, k, t) {
          for (var a in b) Object.hasOwnProperty.call(b, a) && k.call(t || b[a], b[a], a, b);
        };

        S({
          map: "map",
          each: "forEach",
          grep: "filter",
          reduce: "reduce",
          some: "some"
        }, function (b, k) {
          f[k] = function (t) {
            var a;
            h(32, !1, void 0, (a = {}, a["Highcharts." + k] = "use Array." + b, a));
            return Array.prototype[b].apply(t, [].slice.call(arguments, 1));
          };
        });

        var Y = f.addEvent = function (b, k, t, a) {
          void 0 === a && (a = {});
          var u = b.addEventListener || f.addEventListenerPolyfill;
          var c = "function" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};
          f.Point && b instanceof f.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);
          u && u.call(b, k, t, !1);
          c[k] || (c[k] = []);
          c[k].push({
            fn: t,
            order: "number" === typeof a.order ? a.order : Infinity
          });
          c[k].sort(function (b, k) {
            return b.order - k.order;
          });
          return function () {
            W(b, k, t);
          };
        },
            W = f.removeEvent = function (b, k, t) {
          function a(k, t) {
            var a = b.removeEventListener || f.removeEventListenerPolyfill;
            a && a.call(b, k, t, !1);
          }

          function u(t) {
            var u;

            if (b.nodeName) {
              if (k) {
                var c = {};
                c[k] = !0;
              } else c = t;

              S(c, function (b, k) {
                if (t[k]) for (u = t[k].length; u--;) a(k, t[k][u].fn);
              });
            }
          }

          var c;
          ["protoEvents", "hcEvents"].forEach(function (H, d) {
            var g = (d = d ? b : b.prototype) && d[H];
            g && (k ? (c = g[k] || [], t ? (g[k] = c.filter(function (b) {
              return t !== b.fn;
            }), a(k, t)) : (u(g), g[k] = [])) : (u(g), d[H] = {}));
          });
        },
            ca = f.fireEvent = function (b, k, t, a) {
          var u;
          t = t || {};

          if (y.createEvent && (b.dispatchEvent || b.fireEvent)) {
            var H = y.createEvent("Events");
            H.initEvent(k, !0, !0);
            c(H, t);
            b.dispatchEvent ? b.dispatchEvent(H) : b.fireEvent(k, H);
          } else t.target || c(t, {
            preventDefault: function preventDefault() {
              t.defaultPrevented = !0;
            },
            target: b,
            type: k
          }), function (k, a) {
            void 0 === k && (k = []);
            void 0 === a && (a = []);
            var c = 0,
                H = 0,
                d = k.length + a.length;

            for (u = 0; u < d; u++) !1 === (k[c] ? a[H] ? k[c].order <= a[H].order ? k[c++] : a[H++] : k[c++] : a[H++]).fn.call(b, t) && t.preventDefault();
          }(b.protoEvents && b.protoEvents[k], b.hcEvents && b.hcEvents[k]);

          a && !t.defaultPrevented && a.call(b, t);
        },
            V,
            da = f.uniqueKey = function () {
          var b = Math.random().toString(36).substring(2, 9) + "-",
              k = 0;
          return function () {
            return "highcharts-" + (V ? "" : b) + k++;
          };
        }(),
            ea = f.useSerialIds = function (b) {
          return V = L(b, V);
        },
            fa = f.isFunction = function (b) {
          return "function" === typeof b;
        },
            ha = f.getOptions = function () {
          return f.defaultOptions;
        },
            ia = f.setOptions = function (b) {
          f.defaultOptions = m(!0, f.defaultOptions, b);
          (b.time || b.global) && f.time.update(m(f.defaultOptions.global, f.defaultOptions.time, b.global, b.time));
          return f.defaultOptions;
        };

        e.jQuery && (e.jQuery.fn.highcharts = function () {
          var b = [].slice.call(arguments);
          if (this[0]) return b[0] ? (new f[v(b[0]) ? b.shift() : "Chart"](this[0], b[0], b[1]), this) : C[F(this[0], "data-highcharts-chart")];
        });
        return {
          addEvent: Y,
          arrayMax: u,
          arrayMin: E,
          attr: F,
          clamp: function clamp(b, k, t) {
            return b > k ? b < t ? b : t : k;
          },
          clearTimeout: g,
          correctFloat: t,
          createElement: q,
          css: a,
          defined: w,
          destroyObjectProperties: b,
          discardElement: k,
          erase: J,
          error: h,
          extend: c,
          extendClass: p,
          find: aa,
          fireEvent: ca,
          format: M,
          getMagnitude: T,
          getNestedProperty: K,
          getOptions: ha,
          getStyle: U,
          inArray: Z,
          isArray: x,
          isClass: n,
          isDOMElement: D,
          isFunction: fa,
          isNumber: l,
          isObject: z,
          isString: v,
          merge: m,
          normalizeTickInterval: Q,
          numberFormat: R,
          objectEach: S,
          offset: ba,
          pad: B,
          pick: L,
          pInt: I,
          relativeLength: A,
          removeEvent: W,
          setOptions: ia,
          splat: r,
          stableSort: O,
          syncTimeout: d,
          timeUnits: H,
          uniqueKey: da,
          useSerialIds: ea,
          wrap: G
        };
      });
      N(m, "Core/Color/Color.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.isNumber,
            z = h.merge,
            F = h.pInt;
        "";

        h = function () {
          function h(K) {
            this.parsers = [{
              regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
              parse: function parse(h) {
                return [F(h[1]), F(h[2]), F(h[3]), parseFloat(h[4], 10)];
              }
            }, {
              regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
              parse: function parse(h) {
                return [F(h[1]), F(h[2]), F(h[3]), 1];
              }
            }];
            this.rgba = [];
            if (f.Color !== h) return new f.Color(K);
            if (!(this instanceof h)) return new h(K);
            this.init(K);
          }

          h.parse = function (f) {
            return new h(f);
          };

          h.prototype.init = function (f) {
            var C, y;
            if ((this.input = f = h.names[f && f.toLowerCase ? f.toLowerCase() : ""] || f) && f.stops) this.stops = f.stops.map(function (v) {
              return new h(v[1]);
            });else {
              if (f && f.charAt && "#" === f.charAt()) {
                var e = f.length;
                f = parseInt(f.substr(1), 16);
                7 === e ? C = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === e && (C = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1]);
              }

              if (!C) for (y = this.parsers.length; y-- && !C;) {
                var I = this.parsers[y];
                (e = I.regex.exec(f)) && (C = I.parse(e));
              }
            }
            this.rgba = C || [];
          };

          h.prototype.get = function (f) {
            var h = this.input,
                y = this.rgba;

            if ("undefined" !== typeof this.stops) {
              var e = z(h);
              e.stops = [].concat(e.stops);
              this.stops.forEach(function (I, v) {
                e.stops[v] = [e.stops[v][0], I.get(f)];
              });
            } else e = y && m(y[0]) ? "rgb" === f || !f && 1 === y[3] ? "rgb(" + y[0] + "," + y[1] + "," + y[2] + ")" : "a" === f ? y[3] : "rgba(" + y.join(",") + ")" : h;

            return e;
          };

          h.prototype.brighten = function (f) {
            var h,
                y = this.rgba;
            if (this.stops) this.stops.forEach(function (e) {
              e.brighten(f);
            });else if (m(f) && 0 !== f) for (h = 0; 3 > h; h++) y[h] += F(255 * f), 0 > y[h] && (y[h] = 0), 255 < y[h] && (y[h] = 255);
            return this;
          };

          h.prototype.setOpacity = function (f) {
            this.rgba[3] = f;
            return this;
          };

          h.prototype.tweenTo = function (f, h) {
            var y = this.rgba,
                e = f.rgba;
            e.length && y && y.length ? (f = 1 !== e[3] || 1 !== y[3], h = (f ? "rgba(" : "rgb(") + Math.round(e[0] + (y[0] - e[0]) * (1 - h)) + "," + Math.round(e[1] + (y[1] - e[1]) * (1 - h)) + "," + Math.round(e[2] + (y[2] - e[2]) * (1 - h)) + (f ? "," + (e[3] + (y[3] - e[3]) * (1 - h)) : "") + ")") : h = f.input || "none";
            return h;
          };

          h.names = {
            white: "#ffffff",
            black: "#000000"
          };
          return h;
        }();

        f.Color = h;
        f.color = h.parse;
        return h;
      });
      N(m, "Core/Animation/Fx.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = f.win,
            z = h.isNumber,
            F = h.objectEach;

        h = function () {
          function h(f, h, y) {
            this.pos = NaN;
            this.options = h;
            this.elem = f;
            this.prop = y;
          }

          h.prototype.dSetter = function () {
            var f = this.paths,
                h = f && f[0];
            f = f && f[1];
            var y = [],
                e = this.now || 0;
            if (1 !== e && h && f) {
              if (h.length === f.length && 1 > e) for (var I = 0; I < f.length; I++) {
                for (var v = h[I], x = f[I], D = [], n = 0; n < x.length; n++) {
                  var l = v[n],
                      J = x[n];
                  D[n] = "number" === typeof l && "number" === typeof J && ("A" !== x[0] || 4 !== n && 5 !== n) ? l + e * (J - l) : J;
                }

                y.push(D);
              } else y = f;
            } else y = this.toD || [];
            this.elem.attr("d", y, void 0, !0);
          };

          h.prototype.update = function () {
            var f = this.elem,
                h = this.prop,
                y = this.now,
                e = this.options.step;
            if (this[h + "Setter"]) this[h + "Setter"]();else f.attr ? f.element && f.attr(h, y, null, !0) : f.style[h] = y + this.unit;
            e && e.call(f, y, this);
          };

          h.prototype.run = function (h, C, y) {
            var e = this,
                I = e.options,
                v = function v(n) {
              return v.stopped ? !1 : e.step(n);
            },
                x = m.requestAnimationFrame || function (n) {
              setTimeout(n, 13);
            },
                D = function D() {
              for (var n = 0; n < f.timers.length; n++) f.timers[n]() || f.timers.splice(n--, 1);

              f.timers.length && x(D);
            };

            h !== C || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = h, this.end = C, this.unit = y, this.now = this.start, this.pos = 0, v.elem = this.elem, v.prop = this.prop, v() && 1 === f.timers.push(v) && x(D)) : (delete I.curAnim[this.prop], I.complete && 0 === Object.keys(I.curAnim).length && I.complete.call(this.elem));
          };

          h.prototype.step = function (f) {
            var h = +new Date(),
                y = this.options,
                e = this.elem,
                I = y.complete,
                v = y.duration,
                x = y.curAnim;
            if (e.attr && !e.element) f = !1;else if (f || h >= v + this.startTime) {
              this.now = this.end;
              this.pos = 1;
              this.update();
              var D = x[this.prop] = !0;
              F(x, function (n) {
                !0 !== n && (D = !1);
              });
              D && I && I.call(e);
              f = !1;
            } else this.pos = y.easing((h - this.startTime) / v), this.now = this.start + (this.end - this.start) * this.pos, this.update(), f = !0;
            return f;
          };

          h.prototype.initPath = function (f, h, y) {
            function e(r, d) {
              for (; r.length < w;) {
                var g = r[0],
                    c = d[w - r.length];
                c && "M" === g[0] && (r[0] = "C" === c[0] ? ["C", g[1], g[2], g[1], g[2], g[1], g[2]] : ["L", g[1], g[2]]);
                r.unshift(g);
                D && r.push(r[r.length - 1]);
              }
            }

            function I(r, d) {
              for (; r.length < w;) if (d = r[r.length / n - 1].slice(), "C" === d[0] && (d[1] = d[5], d[2] = d[6]), D) {
                var g = r[r.length / n].slice();
                r.splice(r.length / 2, 0, d, g);
              } else r.push(d);
            }

            var v = f.startX,
                x = f.endX;
            h = h && h.slice();
            y = y.slice();
            var D = f.isArea,
                n = D ? 2 : 1;
            if (!h) return [y, y];

            if (v && x) {
              for (f = 0; f < v.length; f++) if (v[f] === x[0]) {
                var l = f;
                break;
              } else if (v[0] === x[x.length - v.length + f]) {
                l = f;
                var J = !0;
                break;
              } else if (v[v.length - 1] === x[x.length - v.length + f]) {
                l = v.length - f;
                break;
              }

              "undefined" === typeof l && (h = []);
            }

            if (h.length && z(l)) {
              var w = y.length + l * n;
              J ? (e(h, y), I(y, h)) : (e(y, h), I(h, y));
            }

            return [h, y];
          };

          h.prototype.fillSetter = function () {
            h.prototype.strokeSetter.apply(this, arguments);
          };

          h.prototype.strokeSetter = function () {
            this.elem.attr(this.prop, f.color(this.start).tweenTo(f.color(this.end), this.pos), null, !0);
          };

          return h;
        }();

        return f.Fx = h;
      });
      N(m, "Core/Animation/AnimationUtilities.js", [m["Core/Animation/Fx.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m) {
        var z = m.defined,
            P = m.getStyle,
            L = m.isArray,
            K = m.isNumber,
            C = m.isObject,
            y = m.merge,
            e = m.objectEach,
            I = m.pick;

        m = h.setAnimation = function (l, n) {
          n.renderer.globalAnimation = I(l, n.options.chart.animation, !0);
        };

        var v = h.animObject = function (l) {
          return C(l) ? h.merge({
            duration: 500,
            defer: 0
          }, l) : {
            duration: l ? 500 : 0,
            defer: 0
          };
        },
            x = h.getDeferredAnimation = function (l, n, w) {
          var r = v(n),
              d = 0,
              g = 0;
          (w ? [w] : l.series).forEach(function (c) {
            c = v(c.options.animation);
            d = n && z(n.defer) ? r.defer : Math.max(d, c.duration + c.defer);
            g = Math.min(r.duration, c.duration);
          });
          l.renderer.forExport && (d = 0);
          return {
            defer: Math.max(0, d - g),
            duration: Math.min(d, g)
          };
        },
            D = h.animate = function (l, v, w) {
          var r,
              d = "",
              g,
              c;

          if (!C(w)) {
            var a = arguments;
            w = {
              duration: a[2],
              easing: a[3],
              complete: a[4]
            };
          }

          K(w.duration) || (w.duration = 400);
          w.easing = "function" === typeof w.easing ? w.easing : Math[w.easing] || Math.easeInOutSine;
          w.curAnim = y(v);
          e(v, function (a, p) {
            n(l, p);
            c = new f(l, w, p);
            g = null;
            "d" === p && L(v.d) ? (c.paths = c.initPath(l, l.pathArray, v.d), c.toD = v.d, r = 0, g = 1) : l.attr ? r = l.attr(p) : (r = parseFloat(P(l, p)) || 0, "opacity" !== p && (d = "px"));
            g || (g = a);
            g && g.match && g.match("px") && (g = g.replace(/px/g, ""));
            c.run(r, g, d);
          });
        },
            n = h.stop = function (l, n) {
          for (var w = h.timers.length; w--;) h.timers[w].elem !== l || n && n !== h.timers[w].prop || (h.timers[w].stopped = !0);
        };

        return {
          animate: D,
          animObject: v,
          getDeferredAnimation: x,
          setAnimation: m,
          stop: n
        };
      });
      N(m, "Core/Renderer/SVG/SVGElement.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Color/Color.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m, z) {
        var F = f.animate,
            P = f.animObject,
            K = f.stop,
            C = m.deg2rad,
            y = m.doc,
            e = m.hasTouch,
            I = m.isFirefox,
            v = m.noop,
            x = m.svg,
            D = m.SVG_NS,
            n = m.win,
            l = z.attr,
            J = z.createElement,
            w = z.css,
            r = z.defined,
            d = z.erase,
            g = z.extend,
            c = z.fireEvent,
            a = z.isArray,
            q = z.isFunction,
            p = z.isNumber,
            B = z.isString,
            A = z.merge,
            G = z.objectEach,
            M = z.pick,
            T = z.pInt,
            Q = z.syncTimeout,
            O = z.uniqueKey;
        "";

        f = function () {
          function E() {
            this.height = this.element = void 0;
            this.opacity = 1;
            this.renderer = void 0;
            this.SVG_NS = D;
            this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
            this.width = void 0;
          }

          E.prototype._defaultGetter = function (a) {
            a = M(this[a + "Value"], this[a], this.element ? this.element.getAttribute(a) : null, 0);
            /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));
            return a;
          };

          E.prototype._defaultSetter = function (a, b, k) {
            k.setAttribute(b, a);
          };

          E.prototype.add = function (a) {
            var b = this.renderer,
                k = this.element;
            a && (this.parentGroup = a);
            this.parentInverted = a && a.inverted;
            "undefined" !== typeof this.textStr && "text" === this.element.nodeName && b.buildText(this);
            this.added = !0;
            if (!a || a.handleZ || this.zIndex) var t = this.zIndexSetter();
            t || (a ? a.element : b.box).appendChild(k);
            if (this.onAdd) this.onAdd();
            return this;
          };

          E.prototype.addClass = function (a, b) {
            var k = b ? "" : this.attr("class") || "";
            a = (a || "").split(/ /g).reduce(function (b, a) {
              -1 === k.indexOf(a) && b.push(a);
              return b;
            }, k ? [k] : []).join(" ");
            a !== k && this.attr("class", a);
            return this;
          };

          E.prototype.afterSetters = function () {
            this.doTransform && (this.updateTransform(), this.doTransform = !1);
          };

          E.prototype.align = function (a, b, k) {
            var t,
                c = {};
            var u = this.renderer;
            var g = u.alignedObjects;
            var p, q;

            if (a) {
              if (this.alignOptions = a, this.alignByTranslate = b, !k || B(k)) this.alignTo = t = k || "renderer", d(g, this), g.push(this), k = void 0;
            } else a = this.alignOptions, b = this.alignByTranslate, t = this.alignTo;

            k = M(k, u[t], u);
            t = a.align;
            u = a.verticalAlign;
            g = (k.x || 0) + (a.x || 0);
            var r = (k.y || 0) + (a.y || 0);
            "right" === t ? p = 1 : "center" === t && (p = 2);
            p && (g += (k.width - (a.width || 0)) / p);
            c[b ? "translateX" : "x"] = Math.round(g);
            "bottom" === u ? q = 1 : "middle" === u && (q = 2);
            q && (r += (k.height - (a.height || 0)) / q);
            c[b ? "translateY" : "y"] = Math.round(r);
            this[this.placed ? "animate" : "attr"](c);
            this.placed = !0;
            this.alignAttr = c;
            return this;
          };

          E.prototype.alignSetter = function (a) {
            var b = {
              left: "start",
              center: "middle",
              right: "end"
            };
            b[a] && (this.alignValue = a, this.element.setAttribute("text-anchor", b[a]));
          };

          E.prototype.animate = function (a, b, k) {
            var t = this,
                c = P(M(b, this.renderer.globalAnimation, !0));
            b = c.defer;
            M(y.hidden, y.msHidden, y.webkitHidden, !1) && (c.duration = 0);
            0 !== c.duration ? (k && (c.complete = k), Q(function () {
              t.element && F(t, a, c);
            }, b)) : (this.attr(a, void 0, k), G(a, function (b, k) {
              c.step && c.step.call(this, b, {
                prop: k,
                pos: 1
              });
            }, this));
            return this;
          };

          E.prototype.applyTextOutline = function (a) {
            var b = this.element,
                k;
            -1 !== a.indexOf("contrast") && (a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));
            a = a.split(" ");
            var t = a[a.length - 1];

            if ((k = a[0]) && "none" !== k && m.svg) {
              this.fakeTS = !0;
              a = [].slice.call(b.getElementsByTagName("tspan"));
              this.ySetter = this.xSetter;
              k = k.replace(/(^[\d\.]+)(.*?)$/g, function (b, k, t) {
                return 2 * k + t;
              });
              this.removeTextOutline(a);
              var c = b.textContent ? /^[\u0591-\u065F\u066A-\u07FF\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(b.textContent) : !1;
              var u = b.firstChild;
              a.forEach(function (a, H) {
                0 === H && (a.setAttribute("x", b.getAttribute("x")), H = b.getAttribute("y"), a.setAttribute("y", H || 0), null === H && b.setAttribute("y", 0));
                H = a.cloneNode(!0);
                l(c && !I ? a : H, {
                  "class": "highcharts-text-outline",
                  fill: t,
                  stroke: t,
                  "stroke-width": k,
                  "stroke-linejoin": "round"
                });
                b.insertBefore(H, u);
              });
              c && I && a[0] && (a = a[0].cloneNode(!0), a.textContent = " ", b.insertBefore(a, u));
            }
          };

          E.prototype.attr = function (a, b, k, t) {
            var c = this.element,
                u,
                d = this,
                g,
                p,
                q = this.symbolCustomAttribs;

            if ("string" === typeof a && "undefined" !== typeof b) {
              var r = a;
              a = {};
              a[r] = b;
            }

            "string" === typeof a ? d = (this[a + "Getter"] || this._defaultGetter).call(this, a, c) : (G(a, function (b, k) {
              g = !1;
              t || K(this, k);
              this.symbolName && -1 !== q.indexOf(k) && (u || (this.symbolAttr(a), u = !0), g = !0);
              !this.rotation || "x" !== k && "y" !== k || (this.doTransform = !0);
              g || (p = this[k + "Setter"] || this._defaultSetter, p.call(this, b, k, c), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(k) && this.updateShadows(k, b, p));
            }, this), this.afterSetters());
            k && k.call(this);
            return d;
          };

          E.prototype.clip = function (a) {
            return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
          };

          E.prototype.crisp = function (a, b) {
            b = b || a.strokeWidth || 0;
            var k = Math.round(b) % 2 / 2;
            a.x = Math.floor(a.x || this.x || 0) + k;
            a.y = Math.floor(a.y || this.y || 0) + k;
            a.width = Math.floor((a.width || this.width || 0) - 2 * k);
            a.height = Math.floor((a.height || this.height || 0) - 2 * k);
            r(a.strokeWidth) && (a.strokeWidth = b);
            return a;
          };

          E.prototype.complexColor = function (u, b, k) {
            var t = this.renderer,
                H,
                d,
                g,
                p,
                q,
                B,
                l,
                n,
                w,
                E,
                V = [],
                v;
            c(this.renderer, "complexColor", {
              args: arguments
            }, function () {
              u.radialGradient ? d = "radialGradient" : u.linearGradient && (d = "linearGradient");

              if (d) {
                g = u[d];
                q = t.gradients;
                B = u.stops;
                w = k.radialReference;
                a(g) && (u[d] = g = {
                  x1: g[0],
                  y1: g[1],
                  x2: g[2],
                  y2: g[3],
                  gradientUnits: "userSpaceOnUse"
                });
                "radialGradient" === d && w && !r(g.gradientUnits) && (p = g, g = A(g, t.getRadialAttr(w, p), {
                  gradientUnits: "userSpaceOnUse"
                }));
                G(g, function (b, k) {
                  "id" !== k && V.push(k, b);
                });
                G(B, function (b) {
                  V.push(b);
                });
                V = V.join(",");
                if (q[V]) E = q[V].attr("id");else {
                  g.id = E = O();
                  var c = q[V] = t.createElement(d).attr(g).add(t.defs);
                  c.radAttr = p;
                  c.stops = [];
                  B.forEach(function (b) {
                    0 === b[1].indexOf("rgba") ? (H = h.parse(b[1]), l = H.get("rgb"), n = H.get("a")) : (l = b[1], n = 1);
                    b = t.createElement("stop").attr({
                      offset: b[0],
                      "stop-color": l,
                      "stop-opacity": n
                    }).add(c);
                    c.stops.push(b);
                  });
                }
                v = "url(" + t.url + "#" + E + ")";
                k.setAttribute(b, v);
                k.gradient = V;

                u.toString = function () {
                  return v;
                };
              }
            });
          };

          E.prototype.css = function (a) {
            var b = this.styles,
                k = {},
                t = this.element,
                c = "",
                d = !b,
                u = ["textOutline", "textOverflow", "width"];
            a && a.color && (a.fill = a.color);
            b && G(a, function (a, t) {
              b && b[t] !== a && (k[t] = a, d = !0);
            });

            if (d) {
              b && (a = g(b, k));
              if (a) if (null === a.width || "auto" === a.width) delete this.textWidth;else if ("text" === t.nodeName.toLowerCase() && a.width) var p = this.textWidth = T(a.width);
              this.styles = a;
              p && !x && this.renderer.forExport && delete a.width;

              if (t.namespaceURI === this.SVG_NS) {
                var q = function q(b, k) {
                  return "-" + k.toLowerCase();
                };

                G(a, function (b, k) {
                  -1 === u.indexOf(k) && (c += k.replace(/([A-Z])/g, q) + ":" + b + ";");
                });
                c && l(t, "style", c);
              } else w(t, a);

              this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));
            }

            return this;
          };

          E.prototype.dashstyleSetter = function (a) {
            var b = this["stroke-width"];
            "inherit" === b && (b = 1);

            if (a = a && a.toLowerCase()) {
              var k = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");

              for (a = k.length; a--;) k[a] = "" + T(k[a]) * M(b, NaN);

              a = k.join(",").replace(/NaN/g, "none");
              this.element.setAttribute("stroke-dasharray", a);
            }
          };

          E.prototype.destroy = function () {
            var a = this,
                b = a.element || {},
                k = a.renderer,
                t = k.isSVG && "SPAN" === b.nodeName && a.parentGroup || void 0,
                c = b.ownerSVGElement;
            b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;
            K(a);

            if (a.clipPath && c) {
              var g = a.clipPath;
              [].forEach.call(c.querySelectorAll("[clip-path],[CLIP-PATH]"), function (b) {
                -1 < b.getAttribute("clip-path").indexOf(g.element.id) && b.removeAttribute("clip-path");
              });
              a.clipPath = g.destroy();
            }

            if (a.stops) {
              for (c = 0; c < a.stops.length; c++) a.stops[c].destroy();

              a.stops.length = 0;
              a.stops = void 0;
            }

            a.safeRemoveChild(b);

            for (k.styledMode || a.destroyShadows(); t && t.div && 0 === t.div.childNodes.length;) b = t.parentGroup, a.safeRemoveChild(t.div), delete t.div, t = b;

            a.alignTo && d(k.alignedObjects, a);
            G(a, function (b, k) {
              a[k] && a[k].parentGroup === a && a[k].destroy && a[k].destroy();
              delete a[k];
            });
          };

          E.prototype.destroyShadows = function () {
            (this.shadows || []).forEach(function (a) {
              this.safeRemoveChild(a);
            }, this);
            this.shadows = void 0;
          };

          E.prototype.destroyTextPath = function (a, b) {
            var k = a.getElementsByTagName("text")[0];

            if (k) {
              if (k.removeAttribute("dx"), k.removeAttribute("dy"), b.element.setAttribute("id", ""), this.textPathWrapper && k.getElementsByTagName("textPath").length) {
                for (a = this.textPathWrapper.element.childNodes; a.length;) k.appendChild(a[0]);

                k.removeChild(this.textPathWrapper.element);
              }
            } else if (a.getAttribute("dx") || a.getAttribute("dy")) a.removeAttribute("dx"), a.removeAttribute("dy");

            this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
          };

          E.prototype.dSetter = function (c, b, k) {
            a(c) && ("string" === typeof c[0] && (c = this.renderer.pathToSegments(c)), this.pathArray = c, c = c.reduce(function (b, k, a) {
              return k && k.join ? (a ? b + " " : "") + k.join(" ") : (k || "").toString();
            }, ""));
            /(NaN| {2}|^$)/.test(c) && (c = "M 0 0");
            this[b] !== c && (k.setAttribute(b, c), this[b] = c);
          };

          E.prototype.fadeOut = function (a) {
            var b = this;
            b.animate({
              opacity: 0
            }, {
              duration: M(a, 150),
              complete: function complete() {
                b.attr({
                  y: -9999
                }).hide();
              }
            });
          };

          E.prototype.fillSetter = function (a, b, k) {
            "string" === typeof a ? k.setAttribute(b, a) : a && this.complexColor(a, b, k);
          };

          E.prototype.getBBox = function (a, b) {
            var k,
                t = this.renderer,
                c = this.element,
                d = this.styles,
                p = this.textStr,
                u = t.cache,
                B = t.cacheKeys,
                A = c.namespaceURI === this.SVG_NS;
            b = M(b, this.rotation, 0);
            var l = t.styledMode ? c && E.prototype.getStyle.call(c, "font-size") : d && d.fontSize;

            if (r(p)) {
              var n = p.toString();
              -1 === n.indexOf("<") && (n = n.replace(/[0-9]/g, "0"));
              n += ["", b, l, this.textWidth, d && d.textOverflow, d && d.fontWeight].join();
            }

            n && !a && (k = u[n]);

            if (!k) {
              if (A || t.forExport) {
                try {
                  var w = this.fakeTS && function (b) {
                    [].forEach.call(c.querySelectorAll(".highcharts-text-outline"), function (k) {
                      k.style.display = b;
                    });
                  };

                  q(w) && w("none");
                  k = c.getBBox ? g({}, c.getBBox()) : {
                    width: c.offsetWidth,
                    height: c.offsetHeight
                  };
                  q(w) && w("");
                } catch (ca) {
                  "";
                }

                if (!k || 0 > k.width) k = {
                  width: 0,
                  height: 0
                };
              } else k = this.htmlGetBBox();

              t.isSVG && (a = k.width, t = k.height, A && (k.height = t = {
                "11px,17": 14,
                "13px,20": 16
              }[d && d.fontSize + "," + Math.round(t)] || t), b && (d = b * C, k.width = Math.abs(t * Math.sin(d)) + Math.abs(a * Math.cos(d)), k.height = Math.abs(t * Math.cos(d)) + Math.abs(a * Math.sin(d))));

              if (n && 0 < k.height) {
                for (; 250 < B.length;) delete u[B.shift()];

                u[n] || B.push(n);
                u[n] = k;
              }
            }

            return k;
          };

          E.prototype.getStyle = function (a) {
            return n.getComputedStyle(this.element || this, "").getPropertyValue(a);
          };

          E.prototype.hasClass = function (a) {
            return -1 !== ("" + this.attr("class")).split(" ").indexOf(a);
          };

          E.prototype.hide = function (a) {
            a ? this.attr({
              y: -9999
            }) : this.attr({
              visibility: "hidden"
            });
            return this;
          };

          E.prototype.htmlGetBBox = function () {
            return {
              height: 0,
              width: 0,
              x: 0,
              y: 0
            };
          };

          E.prototype.init = function (a, b) {
            this.element = "span" === b ? J(b) : y.createElementNS(this.SVG_NS, b);
            this.renderer = a;
            c(this, "afterInit");
          };

          E.prototype.invert = function (a) {
            this.inverted = a;
            this.updateTransform();
            return this;
          };

          E.prototype.on = function (a, b) {
            var k,
                t,
                c = this.element,
                d;
            e && "click" === a ? (c.ontouchstart = function (b) {
              k = b.touches[0].clientX;
              t = b.touches[0].clientY;
            }, c.ontouchend = function (a) {
              k && 4 <= Math.sqrt(Math.pow(k - a.changedTouches[0].clientX, 2) + Math.pow(t - a.changedTouches[0].clientY, 2)) || b.call(c, a);
              d = !0;
              !1 !== a.cancelable && a.preventDefault();
            }, c.onclick = function (k) {
              d || b.call(c, k);
            }) : c["on" + a] = b;
            return this;
          };

          E.prototype.opacitySetter = function (a, b, k) {
            this.opacity = a = Number(Number(a).toFixed(3));
            k.setAttribute(b, a);
          };

          E.prototype.removeClass = function (a) {
            return this.attr("class", ("" + this.attr("class")).replace(B(a) ? new RegExp("(^| )" + a + "( |$)") : a, " ").replace(/ +/g, " ").trim());
          };

          E.prototype.removeTextOutline = function (a) {
            for (var b = a.length, k; b--;) k = a[b], "highcharts-text-outline" === k.getAttribute("class") && d(a, this.element.removeChild(k));
          };

          E.prototype.safeRemoveChild = function (a) {
            var b = a.parentNode;
            b && b.removeChild(a);
          };

          E.prototype.setRadialReference = function (a) {
            var b = this.element.gradient && this.renderer.gradients[this.element.gradient];
            this.element.radialReference = a;
            b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));
            return this;
          };

          E.prototype.setTextPath = function (a, b) {
            var k = this.element,
                t = {
              textAnchor: "text-anchor"
            },
                c = !1,
                d = this.textPathWrapper,
                g = !d;
            b = A(!0, {
              enabled: !0,
              attributes: {
                dy: -5,
                startOffset: "50%",
                textAnchor: "middle"
              }
            }, b);
            var q = b.attributes;

            if (a && b && b.enabled) {
              d && null === d.element.parentNode ? (g = !0, d = d.destroy()) : d && this.removeTextOutline.call(d.parentGroup, [].slice.call(k.getElementsByTagName("tspan")));
              this.options && this.options.padding && (q.dx = -this.options.padding);
              d || (this.textPathWrapper = d = this.renderer.createElement("textPath"), c = !0);
              var u = d.element;
              (b = a.element.getAttribute("id")) || a.element.setAttribute("id", b = O());
              if (g) for (a = k.getElementsByTagName("tspan"); a.length;) a[0].setAttribute("y", 0), p(q.dx) && a[0].setAttribute("x", -q.dx), u.appendChild(a[0]);
              c && d && d.add({
                element: this.text ? this.text.element : k
              });
              u.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + b);
              r(q.dy) && (u.parentNode.setAttribute("dy", q.dy), delete q.dy);
              r(q.dx) && (u.parentNode.setAttribute("dx", q.dx), delete q.dx);
              G(q, function (b, k) {
                u.setAttribute(t[k] || k, b);
              });
              k.removeAttribute("transform");
              this.removeTextOutline.call(d, [].slice.call(k.getElementsByTagName("tspan")));
              this.text && !this.renderer.styledMode && this.attr({
                fill: "none",
                "stroke-width": 0
              });
              this.applyTextOutline = this.updateTransform = v;
            } else d && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(k, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));

            return this;
          };

          E.prototype.shadow = function (a, b, k) {
            var t = [],
                c = this.element,
                d = !1,
                p = this.oldShadowOptions;
            var q = {
              color: "#000000",
              offsetX: 1,
              offsetY: 1,
              opacity: .15,
              width: 3
            };
            var u;
            !0 === a ? u = q : "object" === typeof a && (u = g(q, a));
            u && (u && p && G(u, function (b, k) {
              b !== p[k] && (d = !0);
            }), d && this.destroyShadows(), this.oldShadowOptions = u);
            if (!u) this.destroyShadows();else if (!this.shadows) {
              var r = u.opacity / u.width;
              var B = this.parentInverted ? "translate(-1,-1)" : "translate(" + u.offsetX + ", " + u.offsetY + ")";

              for (q = 1; q <= u.width; q++) {
                var A = c.cloneNode(!1);
                var n = 2 * u.width + 1 - 2 * q;
                l(A, {
                  stroke: a.color || "#000000",
                  "stroke-opacity": r * q,
                  "stroke-width": n,
                  transform: B,
                  fill: "none"
                });
                A.setAttribute("class", (A.getAttribute("class") || "") + " highcharts-shadow");
                k && (l(A, "height", Math.max(l(A, "height") - n, 0)), A.cutHeight = n);
                b ? b.element.appendChild(A) : c.parentNode && c.parentNode.insertBefore(A, c);
                t.push(A);
              }

              this.shadows = t;
            }
            return this;
          };

          E.prototype.show = function (a) {
            return this.attr({
              visibility: a ? "inherit" : "visible"
            });
          };

          E.prototype.strokeSetter = function (a, b, k) {
            this[b] = a;
            this.stroke && this["stroke-width"] ? (E.prototype.fillSetter.call(this, this.stroke, "stroke", k), k.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === b && 0 === a && this.hasStroke ? (k.removeAttribute("stroke"), this.hasStroke = !1) : this.renderer.styledMode && this["stroke-width"] && (k.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0);
          };

          E.prototype.strokeWidth = function () {
            if (!this.renderer.styledMode) return this["stroke-width"] || 0;
            var a = this.getStyle("stroke-width"),
                b = 0;
            if (a.indexOf("px") === a.length - 2) b = T(a);else if ("" !== a) {
              var k = y.createElementNS(D, "rect");
              l(k, {
                width: a,
                "stroke-width": 0
              });
              this.element.parentNode.appendChild(k);
              b = k.getBBox().width;
              k.parentNode.removeChild(k);
            }
            return b;
          };

          E.prototype.symbolAttr = function (a) {
            var b = this;
            "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function (k) {
              b[k] = M(a[k], b[k]);
            });
            b.attr({
              d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
            });
          };

          E.prototype.textSetter = function (a) {
            a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));
          };

          E.prototype.titleSetter = function (a) {
            var b = this.element.getElementsByTagName("title")[0];
            b || (b = y.createElementNS(this.SVG_NS, "title"), this.element.appendChild(b));
            b.firstChild && b.removeChild(b.firstChild);
            b.appendChild(y.createTextNode(String(M(a, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">")));
          };

          E.prototype.toFront = function () {
            var a = this.element;
            a.parentNode.appendChild(a);
            return this;
          };

          E.prototype.translate = function (a, b) {
            return this.attr({
              translateX: a,
              translateY: b
            });
          };

          E.prototype.updateShadows = function (a, b, k) {
            var t = this.shadows;
            if (t) for (var c = t.length; c--;) k.call(t[c], "height" === a ? Math.max(b - (t[c].cutHeight || 0), 0) : "d" === a ? this.d : b, a, t[c]);
          };

          E.prototype.updateTransform = function () {
            var a = this.translateX || 0,
                b = this.translateY || 0,
                k = this.scaleX,
                t = this.scaleY,
                c = this.inverted,
                d = this.rotation,
                g = this.matrix,
                p = this.element;
            c && (a += this.width, b += this.height);
            a = ["translate(" + a + "," + b + ")"];
            r(g) && a.push("matrix(" + g.join(",") + ")");
            c ? a.push("rotate(90) scale(-1,1)") : d && a.push("rotate(" + d + " " + M(this.rotationOriginX, p.getAttribute("x"), 0) + " " + M(this.rotationOriginY, p.getAttribute("y") || 0) + ")");
            (r(k) || r(t)) && a.push("scale(" + M(k, 1) + " " + M(t, 1) + ")");
            a.length && p.setAttribute("transform", a.join(" "));
          };

          E.prototype.visibilitySetter = function (a, b, k) {
            "inherit" === a ? k.removeAttribute(b) : this[b] !== a && k.setAttribute(b, a);
            this[b] = a;
          };

          E.prototype.xGetter = function (a) {
            "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));
            return this._defaultGetter(a);
          };

          E.prototype.zIndexSetter = function (a, b) {
            var k = this.renderer,
                t = this.parentGroup,
                c = (t || k).element || k.box,
                d = this.element,
                g = !1;
            k = c === k.box;
            var p = this.added;
            var q;
            r(a) ? (d.setAttribute("data-z-index", a), a = +a, this[b] === a && (p = !1)) : r(this[b]) && d.removeAttribute("data-z-index");
            this[b] = a;

            if (p) {
              (a = this.zIndex) && t && (t.handleZ = !0);
              b = c.childNodes;

              for (q = b.length - 1; 0 <= q && !g; q--) {
                t = b[q];
                p = t.getAttribute("data-z-index");
                var u = !r(p);
                if (t !== d) if (0 > a && u && !k && !q) c.insertBefore(d, b[q]), g = !0;else if (T(p) <= a || u && (!r(a) || 0 <= a)) c.insertBefore(d, b[q + 1] || null), g = !0;
              }

              g || (c.insertBefore(d, b[k ? 3 : 0] || null), g = !0);
            }

            return g;
          };

          return E;
        }();

        f.prototype["stroke-widthSetter"] = f.prototype.strokeSetter;
        f.prototype.yGetter = f.prototype.xGetter;

        f.prototype.matrixSetter = f.prototype.rotationOriginXSetter = f.prototype.rotationOriginYSetter = f.prototype.rotationSetter = f.prototype.scaleXSetter = f.prototype.scaleYSetter = f.prototype.translateXSetter = f.prototype.translateYSetter = f.prototype.verticalAlignSetter = function (a, c) {
          this[c] = a;
          this.doTransform = !0;
        };

        m.SVGElement = f;
        return m.SVGElement;
      });
      N(m, "Core/Renderer/SVG/SVGLabel.js", [m["Core/Renderer/SVG/SVGElement.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = this && this.__extends || function () {
          var _f = function f(e, I) {
            _f = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (v, e) {
              v.__proto__ = e;
            } || function (v, e) {
              for (var f in e) e.hasOwnProperty(f) && (v[f] = e[f]);
            };

            return _f(e, I);
          };

          return function (e, I) {
            function v() {
              this.constructor = e;
            }

            _f(e, I);

            e.prototype = null === I ? Object.create(I) : (v.prototype = I.prototype, new v());
          };
        }(),
            z = h.defined,
            F = h.extend,
            L = h.isNumber,
            K = h.merge,
            C = h.removeEvent;

        return function (h) {
          function e(f, v, x, D, n, l, J, w, r, d) {
            var g = h.call(this) || this;
            g.init(f, "g");
            g.textStr = v;
            g.x = x;
            g.y = D;
            g.anchorX = l;
            g.anchorY = J;
            g.baseline = r;
            g.className = d;
            "button" !== d && g.addClass("highcharts-label");
            d && g.addClass("highcharts-" + d);
            g.text = f.text("", 0, 0, w).attr({
              zIndex: 1
            });

            if ("string" === typeof n) {
              var c = /^url\((.*?)\)$/.test(n);
              if (g.renderer.symbols[n] || c) g.symbolKey = n;
            }

            g.bBox = e.emptyBBox;
            g.padding = 3;
            g.paddingLeft = 0;
            g.baselineOffset = 0;
            g.needsBox = f.styledMode || c;
            g.deferredAttr = {};
            g.alignFactor = 0;
            return g;
          }

          m(e, h);

          e.prototype.alignSetter = function (e) {
            e = {
              left: 0,
              center: .5,
              right: 1
            }[e];
            e !== this.alignFactor && (this.alignFactor = e, this.bBox && L(this.xSetting) && this.attr({
              x: this.xSetting
            }));
          };

          e.prototype.anchorXSetter = function (e, v) {
            this.anchorX = e;
            this.boxAttr(v, Math.round(e) - this.getCrispAdjust() - this.xSetting);
          };

          e.prototype.anchorYSetter = function (e, v) {
            this.anchorY = e;
            this.boxAttr(v, e - this.ySetting);
          };

          e.prototype.boxAttr = function (e, v) {
            this.box ? this.box.attr(e, v) : this.deferredAttr[e] = v;
          };

          e.prototype.css = function (h) {
            if (h) {
              var v = {};
              h = K(h);
              e.textProps.forEach(function (e) {
                "undefined" !== typeof h[e] && (v[e] = h[e], delete h[e]);
              });
              this.text.css(v);
              var I = "fontSize" in v || "fontWeight" in v;
              if ("width" in v || I) this.updateBoxSize(), I && this.updateTextPadding();
            }

            return f.prototype.css.call(this, h);
          };

          e.prototype.destroy = function () {
            C(this.element, "mouseenter");
            C(this.element, "mouseleave");
            this.text && this.text.destroy();
            this.box && (this.box = this.box.destroy());
            f.prototype.destroy.call(this);
          };

          e.prototype.fillSetter = function (e, v) {
            e && (this.needsBox = !0);
            this.fill = e;
            this.boxAttr(v, e);
          };

          e.prototype.getBBox = function () {
            var e = this.bBox,
                v = this.padding;
            return {
              width: e.width + 2 * v,
              height: e.height + 2 * v,
              x: e.x - v,
              y: e.y - v
            };
          };

          e.prototype.getCrispAdjust = function () {
            return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
          };

          e.prototype.heightSetter = function (e) {
            this.heightSetting = e;
          };

          e.prototype.on = function (e, v) {
            var h = this,
                D = h.text,
                n = D && "SPAN" === D.element.tagName ? D : void 0;

            if (n) {
              var l = function l(_l) {
                ("mouseenter" === e || "mouseleave" === e) && _l.relatedTarget instanceof Element && (h.element.contains(_l.relatedTarget) || n.element.contains(_l.relatedTarget)) || v.call(h.element, _l);
              };

              n.on(e, l);
            }

            f.prototype.on.call(h, e, l || v);
            return h;
          };

          e.prototype.onAdd = function () {
            var e = this.textStr;
            this.text.add(this);
            this.attr({
              text: z(e) ? e : "",
              x: this.x,
              y: this.y
            });
            this.box && z(this.anchorX) && this.attr({
              anchorX: this.anchorX,
              anchorY: this.anchorY
            });
          };

          e.prototype.paddingSetter = function (e) {
            z(e) && e !== this.padding && (this.padding = e, this.updateTextPadding());
          };

          e.prototype.paddingLeftSetter = function (e) {
            z(e) && e !== this.paddingLeft && (this.paddingLeft = e, this.updateTextPadding());
          };

          e.prototype.rSetter = function (e, v) {
            this.boxAttr(v, e);
          };

          e.prototype.shadow = function (e) {
            e && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(e));
            return this;
          };

          e.prototype.strokeSetter = function (e, v) {
            this.stroke = e;
            this.boxAttr(v, e);
          };

          e.prototype["stroke-widthSetter"] = function (e, v) {
            e && (this.needsBox = !0);
            this["stroke-width"] = e;
            this.boxAttr(v, e);
          };

          e.prototype["text-alignSetter"] = function (e) {
            this.textAlign = e;
          };

          e.prototype.textSetter = function (e) {
            "undefined" !== typeof e && this.text.attr({
              text: e
            });
            this.updateBoxSize();
            this.updateTextPadding();
          };

          e.prototype.updateBoxSize = function () {
            var f = this.text.element.style,
                v = {},
                h = this.padding,
                D = this.paddingLeft,
                n = L(this.widthSetting) && L(this.heightSetting) && !this.textAlign || !z(this.text.textStr) ? e.emptyBBox : this.text.getBBox();
            this.width = (this.widthSetting || n.width || 0) + 2 * h + D;
            this.height = (this.heightSetting || n.height || 0) + 2 * h;
            this.baselineOffset = h + Math.min(this.renderer.fontMetrics(f && f.fontSize, this.text).b, n.height || Infinity);
            this.needsBox && (this.box || (f = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), f.addClass(("button" === this.className ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), f.add(this), f = this.getCrispAdjust(), v.x = f, v.y = (this.baseline ? -this.baselineOffset : 0) + f), v.width = Math.round(this.width), v.height = Math.round(this.height), this.box.attr(F(v, this.deferredAttr)), this.deferredAttr = {});
            this.bBox = n;
          };

          e.prototype.updateTextPadding = function () {
            var e = this.text,
                f = this.baseline ? 0 : this.baselineOffset,
                h = this.paddingLeft + this.padding;
            z(this.widthSetting) && this.bBox && ("center" === this.textAlign || "right" === this.textAlign) && (h += {
              center: .5,
              right: 1
            }[this.textAlign] * (this.widthSetting - this.bBox.width));
            if (h !== e.x || f !== e.y) e.attr("x", h), e.hasBoxWidthChanged && (this.bBox = e.getBBox(!0), this.updateBoxSize()), "undefined" !== typeof f && e.attr("y", f);
            e.x = h;
            e.y = f;
          };

          e.prototype.widthSetter = function (e) {
            this.widthSetting = L(e) ? e : void 0;
          };

          e.prototype.xSetter = function (e) {
            this.x = e;
            this.alignFactor && (e -= this.alignFactor * ((this.widthSetting || this.bBox.width) + 2 * this.padding), this["forceAnimate:x"] = !0);
            this.xSetting = Math.round(e);
            this.attr("translateX", this.xSetting);
          };

          e.prototype.ySetter = function (e) {
            this.ySetting = this.y = Math.round(e);
            this.attr("translateY", this.ySetting);
          };

          e.emptyBBox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
          };
          e.textProps = "color cursor direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
          return e;
        }(f);
      });
      N(m, "Core/Renderer/SVG/SVGRenderer.js", [m["Core/Color/Color.js"], m["Core/Globals.js"], m["Core/Renderer/SVG/SVGElement.js"], m["Core/Renderer/SVG/SVGLabel.js"], m["Core/Utilities.js"]], function (f, h, m, z, F) {
        var P = F.addEvent,
            K = F.attr,
            C = F.createElement,
            y = F.css,
            e = F.defined,
            I = F.destroyObjectProperties,
            v = F.extend,
            x = F.isArray,
            D = F.isNumber,
            n = F.isObject,
            l = F.isString,
            J = F.merge,
            w = F.objectEach,
            r = F.pick,
            d = F.pInt,
            g = F.splat,
            c = F.uniqueKey,
            a = h.charts,
            q = h.deg2rad,
            p = h.doc,
            B = h.isFirefox,
            A = h.isMS,
            G = h.isWebKit;
        F = h.noop;

        var M = h.svg,
            T = h.SVG_NS,
            Q = h.symbolSizes,
            O = h.win,
            E = function () {
          function u(b, k, a, c, d, g, p) {
            this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
            this.init(b, k, a, c, d, g, p);
          }

          u.prototype.init = function (b, k, a, c, d, g, q) {
            var t = this.createElement("svg").attr({
              version: "1.1",
              "class": "highcharts-root"
            });
            q || t.css(this.getStyle(c));
            c = t.element;
            b.appendChild(c);
            K(b, "dir", "ltr");
            -1 === b.innerHTML.indexOf("xmlns") && K(c, "xmlns", this.SVG_NS);
            this.isSVG = !0;
            this.box = c;
            this.boxWrapper = t;
            this.alignedObjects = [];
            this.url = (B || G) && p.getElementsByTagName("base").length ? O.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";
            this.createElement("desc").add().element.appendChild(p.createTextNode("Created with Highcharts 8.2.2"));
            this.defs = this.createElement("defs").add();
            this.allowHTML = g;
            this.forExport = d;
            this.styledMode = q;
            this.gradients = {};
            this.cache = {};
            this.cacheKeys = [];
            this.imgCount = 0;
            this.setSize(k, a, !1);
            var H;
            B && b.getBoundingClientRect && (k = function k() {
              y(b, {
                left: 0,
                top: 0
              });
              H = b.getBoundingClientRect();
              y(b, {
                left: Math.ceil(H.left) - H.left + "px",
                top: Math.ceil(H.top) - H.top + "px"
              });
            }, k(), this.unSubPixelFix = P(O, "resize", k));
          };

          u.prototype.definition = function (b) {
            function k(b, t) {
              var c;
              g(b).forEach(function (b) {
                var d = a.createElement(b.tagName),
                    g = {};
                w(b, function (b, k) {
                  "tagName" !== k && "children" !== k && "textContent" !== k && (g[k] = b);
                });
                d.attr(g);
                d.add(t || a.defs);
                b.textContent && d.element.appendChild(p.createTextNode(b.textContent));
                k(b.children || [], d);
                c = d;
              });
              return c;
            }

            var a = this;
            return k(b);
          };

          u.prototype.getStyle = function (b) {
            return this.style = v({
              fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
              fontSize: "12px"
            }, b);
          };

          u.prototype.setStyle = function (b) {
            this.boxWrapper.css(this.getStyle(b));
          };

          u.prototype.isHidden = function () {
            return !this.boxWrapper.getBBox().width;
          };

          u.prototype.destroy = function () {
            var b = this.defs;
            this.box = null;
            this.boxWrapper = this.boxWrapper.destroy();
            I(this.gradients || {});
            this.gradients = null;
            b && (this.defs = b.destroy());
            this.unSubPixelFix && this.unSubPixelFix();
            return this.alignedObjects = null;
          };

          u.prototype.createElement = function (b) {
            var k = new this.Element();
            k.init(this, b);
            return k;
          };

          u.prototype.getRadialAttr = function (b, k) {
            return {
              cx: b[0] - b[2] / 2 + k.cx * b[2],
              cy: b[1] - b[2] / 2 + k.cy * b[2],
              r: k.r * b[2]
            };
          };

          u.prototype.truncate = function (b, k, a, c, d, g, q) {
            var t = this,
                H = b.rotation,
                R,
                u = c ? 1 : 0,
                A = (a || c).length,
                r = A,
                B = [],
                n = function n(b) {
              k.firstChild && k.removeChild(k.firstChild);
              b && k.appendChild(p.createTextNode(b));
            },
                l = function l(g, p) {
              p = p || g;
              if ("undefined" === typeof B[p]) if (k.getSubStringLength) try {
                B[p] = d + k.getSubStringLength(0, c ? p + 1 : p);
              } catch (ja) {
                "";
              } else t.getSpanWidth && (n(q(a || c, g)), B[p] = d + t.getSpanWidth(b, k));
              return B[p];
            },
                e;

            b.rotation = 0;
            var w = l(k.textContent.length);

            if (e = d + w > g) {
              for (; u <= A;) r = Math.ceil((u + A) / 2), c && (R = q(c, r)), w = l(r, R && R.length - 1), u === A ? u = A + 1 : w > g ? A = r - 1 : u = r;

              0 === A ? n("") : a && A === a.length - 1 || n(R || q(a || c, r));
            }

            c && c.splice(0, r);
            b.actualWidth = w;
            b.rotation = H;
            return e;
          };

          u.prototype.buildText = function (b) {
            var k = b.element,
                a = this,
                c = a.forExport,
                g = r(b.textStr, "").toString(),
                q = -1 !== g.indexOf("<"),
                u = k.childNodes,
                A,
                B = K(k, "x"),
                n = b.styles,
                e = b.textWidth,
                G = n && n.lineHeight,
                f = n && n.textOutline,
                V = n && "ellipsis" === n.textOverflow,
                E = n && "nowrap" === n.whiteSpace,
                h = n && n.fontSize,
                v,
                D = u.length;
            n = e && !b.added && this.box;

            var O = function O(b) {
              var t;
              a.styledMode || (t = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : h || a.style.fontSize || 12);
              return G ? d(G) : a.fontMetrics(t, b.getAttribute("style") ? b : k).h;
            },
                J = function J(b, k) {
              w(a.escapes, function (a, t) {
                k && -1 !== k.indexOf(a) || (b = b.toString().replace(new RegExp(a, "g"), t));
              });
              return b;
            },
                x = function x(b, k) {
              var a = b.indexOf("<");
              b = b.substring(a, b.indexOf(">") - a);
              a = b.indexOf(k + "=");
              if (-1 !== a && (a = a + k.length + 1, k = b.charAt(a), '"' === k || "'" === k)) return b = b.substring(a + 1), b.substring(0, b.indexOf(k));
            },
                I = /<br.*?>/g;

            var m = [g, V, E, G, f, h, e].join();

            if (m !== b.textCache) {
              for (b.textCache = m; D--;) k.removeChild(u[D]);

              q || f || V || e || -1 !== g.indexOf(" ") && (!E || I.test(g)) ? (n && n.appendChild(k), q ? (g = a.styledMode ? g.replace(/<(b|strong)>/g, '<span class="highcharts-strong">').replace(/<(i|em)>/g, '<span class="highcharts-emphasized">') : g.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">'), g = g.replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(I)) : g = [g], g = g.filter(function (b) {
                return "" !== b;
              }), g.forEach(function (t, d) {
                var g = 0,
                    H = 0;
                t = t.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                var q = t.split("|||");
                q.forEach(function (t) {
                  if ("" !== t || 1 === q.length) {
                    var R = {},
                        u = p.createElementNS(a.SVG_NS, "tspan"),
                        n,
                        r;
                    (n = x(t, "class")) && K(u, "class", n);
                    if (n = x(t, "style")) n = n.replace(/(;| |^)color([ :])/, "$1fill$2"), K(u, "style", n);

                    if ((r = x(t, "href")) && !c && -1 === r.split(":")[0].toLowerCase().indexOf("javascript")) {
                      var l = p.createElementNS(a.SVG_NS, "a");
                      K(l, "href", r);
                      K(u, "class", "highcharts-anchor");
                      l.appendChild(u);
                      a.styledMode || y(u, {
                        cursor: "pointer"
                      });
                    }

                    t = J(t.replace(/<[a-zA-Z\/](.|\n)*?>/g, "") || " ");

                    if (" " !== t) {
                      u.appendChild(p.createTextNode(t));
                      g ? R.dx = 0 : d && null !== B && (R.x = B);
                      K(u, R);
                      k.appendChild(l || u);
                      !g && v && (!M && c && y(u, {
                        display: "block"
                      }), K(u, "dy", O(u)));

                      if (e) {
                        var w = t.replace(/([^\^])-/g, "$1- ").split(" ");
                        R = !E && (1 < q.length || d || 1 < w.length);
                        l = 0;
                        r = O(u);
                        if (V) A = a.truncate(b, u, t, void 0, 0, Math.max(0, e - parseInt(h || 12, 10)), function (b, k) {
                          return b.substring(0, k) + "\u2026";
                        });else if (R) for (; w.length;) w.length && !E && 0 < l && (u = p.createElementNS(T, "tspan"), K(u, {
                          dy: r,
                          x: B
                        }), n && K(u, "style", n), u.appendChild(p.createTextNode(w.join(" ").replace(/- /g, "-"))), k.appendChild(u)), a.truncate(b, u, null, w, 0 === l ? H : 0, e, function (b, k) {
                          return w.slice(0, k).join(" ").replace(/- /g, "-");
                        }), H = b.actualWidth, l++;
                      }

                      g++;
                    }
                  }
                });
                v = v || k.childNodes.length;
              }), V && A && b.attr("title", J(b.textStr || "", ["&lt;", "&gt;"])), n && n.removeChild(k), l(f) && b.applyTextOutline && b.applyTextOutline(f)) : k.appendChild(p.createTextNode(J(g)));
            }
          };

          u.prototype.getContrast = function (b) {
            b = f.parse(b).rgba;
            b[0] *= 1;
            b[1] *= 1.2;
            b[2] *= .5;
            return 459 < b[0] + b[1] + b[2] ? "#000000" : "#FFFFFF";
          };

          u.prototype.button = function (b, k, a, c, d, g, p, q, u, n) {
            var t = this.label(b, k, a, u, void 0, void 0, n, void 0, "button"),
                H = 0,
                R = this.styledMode;
            b = (d = d ? J(d) : d) && d.style || {};
            d && d.style && delete d.style;
            t.attr(J({
              padding: 8,
              r: 2
            }, d));

            if (!R) {
              d = J({
                fill: "#f7f7f7",
                stroke: "#cccccc",
                "stroke-width": 1,
                style: {
                  color: "#333333",
                  cursor: "pointer",
                  fontWeight: "normal"
                }
              }, {
                style: b
              }, d);
              var r = d.style;
              delete d.style;
              g = J(d, {
                fill: "#e6e6e6"
              }, g);
              var B = g.style;
              delete g.style;
              p = J(d, {
                fill: "#e6ebf5",
                style: {
                  color: "#000000",
                  fontWeight: "bold"
                }
              }, p);
              var l = p.style;
              delete p.style;
              q = J(d, {
                style: {
                  color: "#cccccc"
                }
              }, q);
              var e = q.style;
              delete q.style;
            }

            P(t.element, A ? "mouseover" : "mouseenter", function () {
              3 !== H && t.setState(1);
            });
            P(t.element, A ? "mouseout" : "mouseleave", function () {
              3 !== H && t.setState(H);
            });

            t.setState = function (b) {
              1 !== b && (t.state = H = b);
              t.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b || 0]);
              R || t.attr([d, g, p, q][b || 0]).css([r, B, l, e][b || 0]);
            };

            R || t.attr(d).css(v({
              cursor: "default"
            }, r));
            return t.on("click", function (b) {
              3 !== H && c.call(t, b);
            });
          };

          u.prototype.crispLine = function (b, k, a) {
            void 0 === a && (a = "round");
            var t = b[0],
                c = b[1];
            t[1] === c[1] && (t[1] = c[1] = Math[a](t[1]) - k % 2 / 2);
            t[2] === c[2] && (t[2] = c[2] = Math[a](t[2]) + k % 2 / 2);
            return b;
          };

          u.prototype.path = function (b) {
            var k = this.styledMode ? {} : {
              fill: "none"
            };
            x(b) ? k.d = b : n(b) && v(k, b);
            return this.createElement("path").attr(k);
          };

          u.prototype.circle = function (b, k, a) {
            b = n(b) ? b : "undefined" === typeof b ? {} : {
              x: b,
              y: k,
              r: a
            };
            k = this.createElement("circle");

            k.xSetter = k.ySetter = function (b, k, a) {
              a.setAttribute("c" + k, b);
            };

            return k.attr(b);
          };

          u.prototype.arc = function (b, k, a, c, d, g) {
            n(b) ? (c = b, k = c.y, a = c.r, b = c.x) : c = {
              innerR: c,
              start: d,
              end: g
            };
            b = this.symbol("arc", b, k, a, a, c);
            b.r = a;
            return b;
          };

          u.prototype.rect = function (b, k, a, c, d, g) {
            d = n(b) ? b.r : d;
            var t = this.createElement("rect");
            b = n(b) ? b : "undefined" === typeof b ? {} : {
              x: b,
              y: k,
              width: Math.max(a, 0),
              height: Math.max(c, 0)
            };
            this.styledMode || ("undefined" !== typeof g && (b.strokeWidth = g, b = t.crisp(b)), b.fill = "none");
            d && (b.r = d);

            t.rSetter = function (b, k, a) {
              t.r = b;
              K(a, {
                rx: b,
                ry: b
              });
            };

            t.rGetter = function () {
              return t.r;
            };

            return t.attr(b);
          };

          u.prototype.setSize = function (b, k, a) {
            var t = this.alignedObjects,
                c = t.length;
            this.width = b;
            this.height = k;

            for (this.boxWrapper.animate({
              width: b,
              height: k
            }, {
              step: function step() {
                this.attr({
                  viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                });
              },
              duration: r(a, !0) ? void 0 : 0
            }); c--;) t[c].align();
          };

          u.prototype.g = function (b) {
            var k = this.createElement("g");
            return b ? k.attr({
              "class": "highcharts-" + b
            }) : k;
          };

          u.prototype.image = function (b, k, a, c, d, g) {
            var t = {
              preserveAspectRatio: "none"
            },
                p = function p(b, k) {
              b.setAttributeNS ? b.setAttributeNS("http://www.w3.org/1999/xlink", "href", k) : b.setAttribute("hc-svg-href", k);
            },
                q = function q(k) {
              p(H.element, b);
              g.call(H, k);
            };

            1 < arguments.length && v(t, {
              x: k,
              y: a,
              width: c,
              height: d
            });
            var H = this.createElement("image").attr(t);
            g ? (p(H.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), t = new O.Image(), P(t, "load", q), t.src = b, t.complete && q({})) : p(H.element, b);
            return H;
          };

          u.prototype.symbol = function (b, k, t, c, d, g) {
            var q = this,
                H = /^url\((.*?)\)$/,
                u = H.test(b),
                R = !u && (this.symbols[b] ? b : "circle"),
                n = R && this.symbols[R],
                A;

            if (n) {
              "number" === typeof k && (A = n.call(this.symbols, Math.round(k || 0), Math.round(t || 0), c || 0, d || 0, g));
              var B = this.path(A);
              q.styledMode || B.attr("fill", "none");
              v(B, {
                symbolName: R,
                x: k,
                y: t,
                width: c,
                height: d
              });
              g && v(B, g);
            } else if (u) {
              var l = b.match(H)[1];
              B = this.image(l);
              B.imgwidth = r(Q[l] && Q[l].width, g && g.width);
              B.imgheight = r(Q[l] && Q[l].height, g && g.height);

              var w = function w() {
                B.attr({
                  width: B.width,
                  height: B.height
                });
              };

              ["width", "height"].forEach(function (b) {
                B[b + "Setter"] = function (b, k) {
                  var a = {},
                      t = this["img" + k],
                      c = "width" === k ? "translateX" : "translateY";
                  this[k] = b;
                  e(t) && (g && "within" === g.backgroundSize && this.width && this.height && (t = Math.round(t * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(k, t), this.alignByTranslate || (a[c] = ((this[k] || 0) - t) / 2, this.attr(a)));
                };
              });
              e(k) && B.attr({
                x: k,
                y: t
              });
              B.isImg = !0;
              e(B.imgwidth) && e(B.imgheight) ? w() : (B.attr({
                width: 0,
                height: 0
              }), C("img", {
                onload: function onload() {
                  var b = a[q.chartIndex];
                  0 === this.width && (y(this, {
                    position: "absolute",
                    top: "-999em"
                  }), p.body.appendChild(this));
                  Q[l] = {
                    width: this.width,
                    height: this.height
                  };
                  B.imgwidth = this.width;
                  B.imgheight = this.height;
                  B.element && w();
                  this.parentNode && this.parentNode.removeChild(this);
                  q.imgCount--;
                  if (!q.imgCount && b && !b.hasLoaded) b.onload();
                },
                src: l
              }), this.imgCount++);
            }

            return B;
          };

          u.prototype.clipRect = function (b, k, a, d) {
            var t = c() + "-",
                g = this.createElement("clipPath").attr({
              id: t
            }).add(this.defs);
            b = this.rect(b, k, a, d, 0).add(g);
            b.id = t;
            b.clipPath = g;
            b.count = 0;
            return b;
          };

          u.prototype.text = function (b, k, a, c) {
            var t = {};
            if (c && (this.allowHTML || !this.forExport)) return this.html(b, k, a);
            t.x = Math.round(k || 0);
            a && (t.y = Math.round(a));
            e(b) && (t.text = b);
            b = this.createElement("text").attr(t);
            c || (b.xSetter = function (b, k, a) {
              var t = a.getElementsByTagName("tspan"),
                  c = a.getAttribute(k),
                  d;

              for (d = 0; d < t.length; d++) {
                var g = t[d];
                g.getAttribute(k) === c && g.setAttribute(k, b);
              }

              a.setAttribute(k, b);
            });
            return b;
          };

          u.prototype.fontMetrics = function (b, k) {
            b = !this.styledMode && /px/.test(b) || !O.getComputedStyle ? b || k && k.style && k.style.fontSize || this.style && this.style.fontSize : k && m.prototype.getStyle.call(k, "font-size");
            b = /px/.test(b) ? d(b) : 12;
            k = 24 > b ? b + 3 : Math.round(1.2 * b);
            return {
              h: k,
              b: Math.round(.8 * k),
              f: b
            };
          };

          u.prototype.rotCorr = function (b, k, a) {
            var t = b;
            k && a && (t = Math.max(t * Math.cos(k * q), 4));
            return {
              x: -b / 3 * Math.sin(k * q),
              y: t
            };
          };

          u.prototype.pathToSegments = function (b) {
            for (var k = [], a = [], c = {
              A: 8,
              C: 7,
              H: 2,
              L: 3,
              M: 3,
              Q: 5,
              S: 5,
              T: 3,
              V: 2
            }, d = 0; d < b.length; d++) l(a[0]) && D(b[d]) && a.length === c[a[0].toUpperCase()] && b.splice(d, 0, a[0].replace("M", "L").replace("m", "l")), "string" === typeof b[d] && (a.length && k.push(a.slice(0)), a.length = 0), a.push(b[d]);

            k.push(a.slice(0));
            return k;
          };

          u.prototype.label = function (b, k, a, c, d, g, p, q, u) {
            return new z(this, b, k, a, c, d, g, p, q, u);
          };

          return u;
        }();

        E.prototype.Element = m;
        E.prototype.SVG_NS = T;
        E.prototype.draw = F;
        E.prototype.escapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "'": "&#39;",
          '"': "&quot;"
        };
        E.prototype.symbols = {
          circle: function circle(a, b, k, t) {
            return this.arc(a + k / 2, b + t / 2, k / 2, t / 2, {
              start: .5 * Math.PI,
              end: 2.5 * Math.PI,
              open: !1
            });
          },
          square: function square(a, b, k, t) {
            return [["M", a, b], ["L", a + k, b], ["L", a + k, b + t], ["L", a, b + t], ["Z"]];
          },
          triangle: function triangle(a, b, k, t) {
            return [["M", a + k / 2, b], ["L", a + k, b + t], ["L", a, b + t], ["Z"]];
          },
          "triangle-down": function triangleDown(a, b, k, t) {
            return [["M", a, b], ["L", a + k, b], ["L", a + k / 2, b + t], ["Z"]];
          },
          diamond: function diamond(a, b, k, t) {
            return [["M", a + k / 2, b], ["L", a + k, b + t / 2], ["L", a + k / 2, b + t], ["L", a, b + t / 2], ["Z"]];
          },
          arc: function arc(a, b, k, t, c) {
            var d = [];

            if (c) {
              var g = c.start || 0,
                  p = c.end || 0,
                  q = c.r || k;
              k = c.r || t || k;
              var H = .001 > Math.abs(p - g - 2 * Math.PI);
              p -= .001;
              t = c.innerR;
              H = r(c.open, H);
              var u = Math.cos(g),
                  B = Math.sin(g),
                  n = Math.cos(p),
                  A = Math.sin(p);
              g = r(c.longArc, .001 > p - g - Math.PI ? 0 : 1);
              d.push(["M", a + q * u, b + k * B], ["A", q, k, 0, g, r(c.clockwise, 1), a + q * n, b + k * A]);
              e(t) && d.push(H ? ["M", a + t * n, b + t * A] : ["L", a + t * n, b + t * A], ["A", t, t, 0, g, e(c.clockwise) ? 1 - c.clockwise : 0, a + t * u, b + t * B]);
              H || d.push(["Z"]);
            }

            return d;
          },
          callout: function callout(a, b, k, t, c) {
            var d = Math.min(c && c.r || 0, k, t),
                g = d + 6,
                p = c && c.anchorX || 0;
            c = c && c.anchorY || 0;
            var q = [["M", a + d, b], ["L", a + k - d, b], ["C", a + k, b, a + k, b, a + k, b + d], ["L", a + k, b + t - d], ["C", a + k, b + t, a + k, b + t, a + k - d, b + t], ["L", a + d, b + t], ["C", a, b + t, a, b + t, a, b + t - d], ["L", a, b + d], ["C", a, b, a, b, a + d, b]];
            p && p > k ? c > b + g && c < b + t - g ? q.splice(3, 1, ["L", a + k, c - 6], ["L", a + k + 6, c], ["L", a + k, c + 6], ["L", a + k, b + t - d]) : q.splice(3, 1, ["L", a + k, t / 2], ["L", p, c], ["L", a + k, t / 2], ["L", a + k, b + t - d]) : p && 0 > p ? c > b + g && c < b + t - g ? q.splice(7, 1, ["L", a, c + 6], ["L", a - 6, c], ["L", a, c - 6], ["L", a, b + d]) : q.splice(7, 1, ["L", a, t / 2], ["L", p, c], ["L", a, t / 2], ["L", a, b + d]) : c && c > t && p > a + g && p < a + k - g ? q.splice(5, 1, ["L", p + 6, b + t], ["L", p, b + t + 6], ["L", p - 6, b + t], ["L", a + d, b + t]) : c && 0 > c && p > a + g && p < a + k - g && q.splice(1, 1, ["L", p - 6, b], ["L", p, b - 6], ["L", p + 6, b], ["L", k - d, b]);
            return q;
          }
        };
        h.SVGRenderer = E;
        h.Renderer = h.SVGRenderer;
        return h.Renderer;
      });
      N(m, "Core/Renderer/HTML/HTMLElement.js", [m["Core/Globals.js"], m["Core/Renderer/SVG/SVGElement.js"], m["Core/Utilities.js"]], function (f, h, m) {
        var z = m.css,
            F = m.defined,
            P = m.extend,
            K = m.pick,
            C = m.pInt,
            y = f.isFirefox;
        P(h.prototype, {
          htmlCss: function htmlCss(e) {
            var f = "SPAN" === this.element.tagName && e && "width" in e,
                h = K(f && e.width, void 0);

            if (f) {
              delete e.width;
              this.textWidth = h;
              var x = !0;
            }

            e && "ellipsis" === e.textOverflow && (e.whiteSpace = "nowrap", e.overflow = "hidden");
            this.styles = P(this.styles, e);
            z(this.element, e);
            x && this.htmlUpdateTransform();
            return this;
          },
          htmlGetBBox: function htmlGetBBox() {
            var e = this.element;
            return {
              x: e.offsetLeft,
              y: e.offsetTop,
              width: e.offsetWidth,
              height: e.offsetHeight
            };
          },
          htmlUpdateTransform: function htmlUpdateTransform() {
            if (this.added) {
              var e = this.renderer,
                  f = this.element,
                  h = this.translateX || 0,
                  x = this.translateY || 0,
                  D = this.x || 0,
                  n = this.y || 0,
                  l = this.textAlign || "left",
                  J = {
                left: 0,
                center: .5,
                right: 1
              }[l],
                  w = this.styles,
                  r = w && w.whiteSpace;
              z(f, {
                marginLeft: h,
                marginTop: x
              });
              !e.styledMode && this.shadows && this.shadows.forEach(function (a) {
                z(a, {
                  marginLeft: h + 1,
                  marginTop: x + 1
                });
              });
              this.inverted && [].forEach.call(f.childNodes, function (a) {
                e.invertChild(a, f);
              });

              if ("SPAN" === f.tagName) {
                w = this.rotation;
                var d = this.textWidth && C(this.textWidth),
                    g = [w, l, f.innerHTML, this.textWidth, this.textAlign].join(),
                    c;
                (c = d !== this.oldTextWidth) && !(c = d > this.oldTextWidth) && ((c = this.textPxLength) || (z(f, {
                  width: "",
                  whiteSpace: r || "nowrap"
                }), c = f.offsetWidth), c = c > d);
                c && (/[ \-]/.test(f.textContent || f.innerText) || "ellipsis" === f.style.textOverflow) ? (z(f, {
                  width: d + "px",
                  display: "block",
                  whiteSpace: r || "normal"
                }), this.oldTextWidth = d, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;
                g !== this.cTT && (r = e.fontMetrics(f.style.fontSize, f).b, !F(w) || w === (this.oldRotation || 0) && l === this.oldAlign || this.setSpanRotation(w, J, r), this.getSpanCorrection(!F(w) && this.textPxLength || f.offsetWidth, r, J, w, l));
                z(f, {
                  left: D + (this.xCorr || 0) + "px",
                  top: n + (this.yCorr || 0) + "px"
                });
                this.cTT = g;
                this.oldRotation = w;
                this.oldAlign = l;
              }
            } else this.alignOnAdd = !0;
          },
          setSpanRotation: function setSpanRotation(e, f, h) {
            var v = {},
                D = this.renderer.getTransformKey();
            v[D] = v.transform = "rotate(" + e + "deg)";
            v[D + (y ? "Origin" : "-origin")] = v.transformOrigin = 100 * f + "% " + h + "px";
            z(this.element, v);
          },
          getSpanCorrection: function getSpanCorrection(e, f, h) {
            this.xCorr = -e * h;
            this.yCorr = -f;
          }
        });
        return h;
      });
      N(m, "Core/Renderer/HTML/HTMLRenderer.js", [m["Core/Globals.js"], m["Core/Renderer/SVG/SVGElement.js"], m["Core/Renderer/SVG/SVGRenderer.js"], m["Core/Utilities.js"]], function (f, h, m, z) {
        var F = f.isFirefox,
            P = f.isMS,
            K = f.isWebKit,
            C = f.win,
            y = z.attr,
            e = z.createElement,
            I = z.extend,
            v = z.pick;
        I(m.prototype, {
          getTransformKey: function getTransformKey() {
            return P && !/Edge/.test(C.navigator.userAgent) ? "-ms-transform" : K ? "-webkit-transform" : F ? "MozTransform" : C.opera ? "-o-transform" : "";
          },
          html: function html(f, D, n) {
            var l = this.createElement("span"),
                J = l.element,
                w = l.renderer,
                r = w.isSVG,
                d = function d(_d, c) {
              ["opacity", "visibility"].forEach(function (a) {
                _d[a + "Setter"] = function (g, p, B) {
                  var q = _d.div ? _d.div.style : c;
                  h.prototype[a + "Setter"].call(this, g, p, B);
                  q && (q[p] = g);
                };
              });
              _d.addedSetters = !0;
            };

            l.textSetter = function (d) {
              d !== J.innerHTML && (delete this.bBox, delete this.oldTextWidth);
              this.textStr = d;
              J.innerHTML = v(d, "");
              l.doTransform = !0;
            };

            r && d(l, l.element.style);

            l.xSetter = l.ySetter = l.alignSetter = l.rotationSetter = function (d, c) {
              "align" === c ? l.alignValue = l.textAlign = d : l[c] = d;
              l.doTransform = !0;
            };

            l.afterSetters = function () {
              this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);
            };

            l.attr({
              text: f,
              x: Math.round(D),
              y: Math.round(n)
            }).css({
              position: "absolute"
            });
            w.styledMode || l.css({
              fontFamily: this.style.fontFamily,
              fontSize: this.style.fontSize
            });
            J.style.whiteSpace = "nowrap";
            l.css = l.htmlCss;
            r && (l.add = function (g) {
              var c = w.box.parentNode,
                  a = [];

              if (this.parentGroup = g) {
                var q = g.div;

                if (!q) {
                  for (; g;) a.push(g), g = g.parentGroup;

                  a.reverse().forEach(function (g) {
                    function p(a, c) {
                      g[c] = a;
                      "translateX" === c ? r.left = a + "px" : r.top = a + "px";
                      g.doTransform = !0;
                    }

                    var n = y(g.element, "class");
                    q = g.div = g.div || e("div", n ? {
                      className: n
                    } : void 0, {
                      position: "absolute",
                      left: (g.translateX || 0) + "px",
                      top: (g.translateY || 0) + "px",
                      display: g.display,
                      opacity: g.opacity,
                      pointerEvents: g.styles && g.styles.pointerEvents
                    }, q || c);
                    var r = q.style;
                    I(g, {
                      classSetter: function (a) {
                        return function (c) {
                          this.element.setAttribute("class", c);
                          a.className = c;
                        };
                      }(q),
                      on: function on() {
                        a[0].div && l.on.apply({
                          element: a[0].div
                        }, arguments);
                        return g;
                      },
                      translateXSetter: p,
                      translateYSetter: p
                    });
                    g.addedSetters || d(g);
                  });
                }
              } else q = c;

              q.appendChild(J);
              l.added = !0;
              l.alignOnAdd && l.htmlUpdateTransform();
              return l;
            });
            return l;
          }
        });
        return m;
      });
      N(m, "Core/Axis/Tick.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.clamp,
            z = h.correctFloat,
            F = h.defined,
            L = h.destroyObjectProperties,
            K = h.extend,
            C = h.fireEvent,
            y = h.isNumber,
            e = h.merge,
            I = h.objectEach,
            v = h.pick,
            x = f.deg2rad;

        h = function () {
          function f(n, l, e, w, r) {
            this.isNewLabel = this.isNew = !0;
            this.axis = n;
            this.pos = l;
            this.type = e || "";
            this.parameters = r || {};
            this.tickmarkOffset = this.parameters.tickmarkOffset;
            this.options = this.parameters.options;
            C(this, "init");
            e || w || this.addLabel();
          }

          f.prototype.addLabel = function () {
            var n = this,
                l = n.axis,
                e = l.options,
                w = l.chart,
                r = l.categories,
                d = l.logarithmic,
                g = l.names,
                c = n.pos,
                a = v(n.options && n.options.labels, e.labels),
                q = l.tickPositions,
                p = c === q[0],
                B = c === q[q.length - 1];
            g = this.parameters.category || (r ? v(r[c], g[c], c) : c);
            var A = n.label;
            r = (!a.step || 1 === a.step) && 1 === l.tickInterval;
            q = q.info;
            var f, h;

            if (l.dateTime && q) {
              var D = w.time.resolveDTLFormat(e.dateTimeLabelFormats[!e.grid && q.higherRanks[c] || q.unitName]);
              var x = D.main;
            }

            n.isFirst = p;
            n.isLast = B;
            n.formatCtx = {
              axis: l,
              chart: w,
              isFirst: p,
              isLast: B,
              dateTimeLabelFormat: x,
              tickPositionInfo: q,
              value: d ? z(d.lin2log(g)) : g,
              pos: c
            };
            e = l.labelFormatter.call(n.formatCtx, this.formatCtx);
            if (h = D && D.list) n.shortenLabel = function () {
              for (f = 0; f < h.length; f++) if (A.attr({
                text: l.labelFormatter.call(K(n.formatCtx, {
                  dateTimeLabelFormat: h[f]
                }))
              }), A.getBBox().width < l.getSlotWidth(n) - 2 * v(a.padding, 5)) return;

              A.attr({
                text: ""
              });
            };
            r && l._addedPlotLB && n.moveLabel(e, a);
            F(A) || n.movedLabel ? A && A.textStr !== e && !r && (!A.textWidth || a.style && a.style.width || A.styles.width || A.css({
              width: null
            }), A.attr({
              text: e
            }), A.textPxLength = A.getBBox().width) : (n.label = A = n.createLabel({
              x: 0,
              y: 0
            }, e, a), n.rotation = 0);
          };

          f.prototype.createLabel = function (n, l, f) {
            var w = this.axis,
                r = w.chart;
            if (n = F(l) && f.enabled ? r.renderer.text(l, n.x, n.y, f.useHTML).add(w.labelGroup) : null) r.styledMode || n.css(e(f.style)), n.textPxLength = n.getBBox().width;
            return n;
          };

          f.prototype.destroy = function () {
            L(this, this.axis);
          };

          f.prototype.getPosition = function (n, l, e, w) {
            var r = this.axis,
                d = r.chart,
                g = w && d.oldChartHeight || d.chartHeight;
            n = {
              x: n ? z(r.translate(l + e, null, null, w) + r.transB) : r.left + r.offset + (r.opposite ? (w && d.oldChartWidth || d.chartWidth) - r.right - r.left : 0),
              y: n ? g - r.bottom + r.offset - (r.opposite ? r.height : 0) : z(g - r.translate(l + e, null, null, w) - r.transB)
            };
            n.y = m(n.y, -1E5, 1E5);
            C(this, "afterGetPosition", {
              pos: n
            });
            return n;
          };

          f.prototype.getLabelPosition = function (n, l, e, w, r, d, g, c) {
            var a = this.axis,
                q = a.transA,
                p = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,
                B = a.staggerLines,
                A = a.tickRotCorr || {
              x: 0,
              y: 0
            },
                f = r.y,
                h = w || a.reserveSpaceDefault ? 0 : -a.labelOffset * ("center" === a.labelAlign ? .5 : 1),
                v = {};
            F(f) || (f = 0 === a.side ? e.rotation ? -8 : -e.getBBox().height : 2 === a.side ? A.y + 8 : Math.cos(e.rotation * x) * (A.y - e.getBBox(!1, 0).height / 2));
            n = n + r.x + h + A.x - (d && w ? d * q * (p ? -1 : 1) : 0);
            l = l + f - (d && !w ? d * q * (p ? 1 : -1) : 0);
            B && (e = g / (c || 1) % B, a.opposite && (e = B - e - 1), l += a.labelOffset / B * e);
            v.x = n;
            v.y = Math.round(l);
            C(this, "afterGetLabelPosition", {
              pos: v,
              tickmarkOffset: d,
              index: g
            });
            return v;
          };

          f.prototype.getLabelSize = function () {
            return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
          };

          f.prototype.getMarkPath = function (n, e, f, w, r, d) {
            return d.crispLine([["M", n, e], ["L", n + (r ? 0 : -f), e + (r ? f : 0)]], w);
          };

          f.prototype.handleOverflow = function (n) {
            var e = this.axis,
                f = e.options.labels,
                w = n.x,
                r = e.chart.chartWidth,
                d = e.chart.spacing,
                g = v(e.labelLeft, Math.min(e.pos, d[3]));
            d = v(e.labelRight, Math.max(e.isRadial ? 0 : e.pos + e.len, r - d[1]));
            var c = this.label,
                a = this.rotation,
                q = {
              left: 0,
              center: .5,
              right: 1
            }[e.labelAlign || c.attr("align")],
                p = c.getBBox().width,
                B = e.getSlotWidth(this),
                A = B,
                G = 1,
                h,
                D = {};
            if (a || "justify" !== v(f.overflow, "justify")) 0 > a && w - q * p < g ? h = Math.round(w / Math.cos(a * x) - g) : 0 < a && w + q * p > d && (h = Math.round((r - w) / Math.cos(a * x)));else if (r = w + (1 - q) * p, w - q * p < g ? A = n.x + A * (1 - q) - g : r > d && (A = d - n.x + A * q, G = -1), A = Math.min(B, A), A < B && "center" === e.labelAlign && (n.x += G * (B - A - q * (B - Math.min(p, A)))), p > A || e.autoRotation && (c.styles || {}).width) h = A;
            h && (this.shortenLabel ? this.shortenLabel() : (D.width = Math.floor(h) + "px", (f.style || {}).textOverflow || (D.textOverflow = "ellipsis"), c.css(D)));
          };

          f.prototype.moveLabel = function (n, e) {
            var l = this,
                w = l.label,
                r = !1,
                d = l.axis,
                g = d.reversed;
            w && w.textStr === n ? (l.movedLabel = w, r = !0, delete l.label) : I(d.ticks, function (a) {
              r || a.isNew || a === l || !a.label || a.label.textStr !== n || (l.movedLabel = a.label, r = !0, a.labelPos = l.movedLabel.xy, delete a.label);
            });

            if (!r && (l.labelPos || w)) {
              var c = l.labelPos || w.xy;
              w = d.horiz ? g ? 0 : d.width + d.left : c.x;
              d = d.horiz ? c.y : g ? d.width + d.left : 0;
              l.movedLabel = l.createLabel({
                x: w,
                y: d
              }, n, e);
              l.movedLabel && l.movedLabel.attr({
                opacity: 0
              });
            }
          };

          f.prototype.render = function (e, l, f) {
            var n = this.axis,
                r = n.horiz,
                d = this.pos,
                g = v(this.tickmarkOffset, n.tickmarkOffset);
            d = this.getPosition(r, d, g, l);
            g = d.x;
            var c = d.y;
            n = r && g === n.pos + n.len || !r && c === n.pos ? -1 : 1;
            f = v(f, 1);
            this.isActive = !0;
            this.renderGridLine(l, f, n);
            this.renderMark(d, f, n);
            this.renderLabel(d, l, f, e);
            this.isNew = !1;
            C(this, "afterRender");
          };

          f.prototype.renderGridLine = function (n, e, f) {
            var l = this.axis,
                r = l.options,
                d = this.gridLine,
                g = {},
                c = this.pos,
                a = this.type,
                q = v(this.tickmarkOffset, l.tickmarkOffset),
                p = l.chart.renderer,
                B = a ? a + "Grid" : "grid",
                A = r[B + "LineWidth"],
                G = r[B + "LineColor"];
            r = r[B + "LineDashStyle"];
            d || (l.chart.styledMode || (g.stroke = G, g["stroke-width"] = A, r && (g.dashstyle = r)), a || (g.zIndex = 1), n && (e = 0), this.gridLine = d = p.path().attr(g).addClass("highcharts-" + (a ? a + "-" : "") + "grid-line").add(l.gridGroup));
            if (d && (f = l.getPlotLinePath({
              value: c + q,
              lineWidth: d.strokeWidth() * f,
              force: "pass",
              old: n
            }))) d[n || this.isNew ? "attr" : "animate"]({
              d: f,
              opacity: e
            });
          };

          f.prototype.renderMark = function (n, e, f) {
            var l = this.axis,
                r = l.options,
                d = l.chart.renderer,
                g = this.type,
                c = g ? g + "Tick" : "tick",
                a = l.tickSize(c),
                q = this.mark,
                p = !q,
                B = n.x;
            n = n.y;
            var A = v(r[c + "Width"], !g && l.isXAxis ? 1 : 0);
            r = r[c + "Color"];
            a && (l.opposite && (a[0] = -a[0]), p && (this.mark = q = d.path().addClass("highcharts-" + (g ? g + "-" : "") + "tick").add(l.axisGroup), l.chart.styledMode || q.attr({
              stroke: r,
              "stroke-width": A
            })), q[p ? "attr" : "animate"]({
              d: this.getMarkPath(B, n, a[0], q.strokeWidth() * f, l.horiz, d),
              opacity: e
            }));
          };

          f.prototype.renderLabel = function (e, l, f, w) {
            var n = this.axis,
                d = n.horiz,
                g = n.options,
                c = this.label,
                a = g.labels,
                q = a.step;
            n = v(this.tickmarkOffset, n.tickmarkOffset);
            var p = !0,
                B = e.x;
            e = e.y;
            c && y(B) && (c.xy = e = this.getLabelPosition(B, e, c, d, a, n, w, q), this.isFirst && !this.isLast && !v(g.showFirstLabel, 1) || this.isLast && !this.isFirst && !v(g.showLastLabel, 1) ? p = !1 : !d || a.step || a.rotation || l || 0 === f || this.handleOverflow(e), q && w % q && (p = !1), p && y(e.y) ? (e.opacity = f, c[this.isNewLabel ? "attr" : "animate"](e), this.isNewLabel = !1) : (c.attr("y", -9999), this.isNewLabel = !0));
          };

          f.prototype.replaceMovedLabel = function () {
            var e = this.label,
                l = this.axis,
                f = l.reversed;

            if (e && !this.isNew) {
              var w = l.horiz ? f ? l.left : l.width + l.left : e.xy.x;
              f = l.horiz ? e.xy.y : f ? l.width + l.top : l.top;
              e.animate({
                x: w,
                y: f,
                opacity: 0
              }, void 0, e.destroy);
              delete this.label;
            }

            l.isDirty = !0;
            this.label = this.movedLabel;
            delete this.movedLabel;
          };

          return f;
        }();

        f.Tick = h;
        return f.Tick;
      });
      N(m, "Core/Time.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.defined,
            z = h.error,
            F = h.extend,
            L = h.isObject,
            K = h.merge,
            C = h.objectEach,
            y = h.pad,
            e = h.pick,
            I = h.splat,
            v = h.timeUnits,
            x = f.win;

        h = function () {
          function h(e) {
            this.options = {};
            this.variableTimezone = this.useUTC = !1;
            this.Date = x.Date;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.update(e);
          }

          h.prototype.get = function (e, l) {
            if (this.variableTimezone || this.timezoneOffset) {
              var n = l.getTime(),
                  f = n - this.getTimezoneOffset(l);
              l.setTime(f);
              e = l["getUTC" + e]();
              l.setTime(n);
              return e;
            }

            return this.useUTC ? l["getUTC" + e]() : l["get" + e]();
          };

          h.prototype.set = function (e, l, f) {
            if (this.variableTimezone || this.timezoneOffset) {
              if ("Milliseconds" === e || "Seconds" === e || "Minutes" === e) return l["setUTC" + e](f);
              var n = this.getTimezoneOffset(l);
              n = l.getTime() - n;
              l.setTime(n);
              l["setUTC" + e](f);
              e = this.getTimezoneOffset(l);
              n = l.getTime() + e;
              return l.setTime(n);
            }

            return this.useUTC ? l["setUTC" + e](f) : l["set" + e](f);
          };

          h.prototype.update = function (n) {
            var l = e(n && n.useUTC, !0);
            this.options = n = K(!0, this.options || {}, n);
            this.Date = n.Date || x.Date || Date;
            this.timezoneOffset = (this.useUTC = l) && n.timezoneOffset;
            this.getTimezoneOffset = this.timezoneOffsetFunction();
            this.variableTimezone = !(l && !n.getTimezoneOffset && !n.timezone);
          };

          h.prototype.makeTime = function (n, l, h, w, r, d) {
            if (this.useUTC) {
              var g = this.Date.UTC.apply(0, arguments);
              var c = this.getTimezoneOffset(g);
              g += c;
              var a = this.getTimezoneOffset(g);
              c !== a ? g += a - c : c - 36E5 !== this.getTimezoneOffset(g - 36E5) || f.isSafari || (g -= 36E5);
            } else g = new this.Date(n, l, e(h, 1), e(w, 0), e(r, 0), e(d, 0)).getTime();

            return g;
          };

          h.prototype.timezoneOffsetFunction = function () {
            var e = this,
                l = this.options,
                f = l.moment || x.moment;
            if (!this.useUTC) return function (e) {
              return 6E4 * new Date(e.toString()).getTimezoneOffset();
            };

            if (l.timezone) {
              if (f) return function (e) {
                return 6E4 * -f.tz(e, l.timezone).utcOffset();
              };
              z(25);
            }

            return this.useUTC && l.getTimezoneOffset ? function (e) {
              return 6E4 * l.getTimezoneOffset(e.valueOf());
            } : function () {
              return 6E4 * (e.timezoneOffset || 0);
            };
          };

          h.prototype.dateFormat = function (n, l, h) {
            var w;
            if (!m(l) || isNaN(l)) return (null === (w = f.defaultOptions.lang) || void 0 === w ? void 0 : w.invalidDate) || "";
            n = e(n, "%Y-%m-%d %H:%M:%S");
            var r = this;
            w = new this.Date(l);
            var d = this.get("Hours", w),
                g = this.get("Day", w),
                c = this.get("Date", w),
                a = this.get("Month", w),
                q = this.get("FullYear", w),
                p = f.defaultOptions.lang,
                B = null === p || void 0 === p ? void 0 : p.weekdays,
                A = null === p || void 0 === p ? void 0 : p.shortWeekdays;
            w = F({
              a: A ? A[g] : B[g].substr(0, 3),
              A: B[g],
              d: y(c),
              e: y(c, 2, " "),
              w: g,
              b: p.shortMonths[a],
              B: p.months[a],
              m: y(a + 1),
              o: a + 1,
              y: q.toString().substr(2, 2),
              Y: q,
              H: y(d),
              k: d,
              I: y(d % 12 || 12),
              l: d % 12 || 12,
              M: y(this.get("Minutes", w)),
              p: 12 > d ? "AM" : "PM",
              P: 12 > d ? "am" : "pm",
              S: y(w.getSeconds()),
              L: y(Math.floor(l % 1E3), 3)
            }, f.dateFormats);
            C(w, function (a, c) {
              for (; -1 !== n.indexOf("%" + c);) n = n.replace("%" + c, "function" === typeof a ? a.call(r, l) : a);
            });
            return h ? n.substr(0, 1).toUpperCase() + n.substr(1) : n;
          };

          h.prototype.resolveDTLFormat = function (e) {
            return L(e, !0) ? e : (e = I(e), {
              main: e[0],
              from: e[1],
              to: e[2]
            });
          };

          h.prototype.getTimeTicks = function (n, l, f, h) {
            var r = this,
                d = [],
                g = {};
            var c = new r.Date(l);
            var a = n.unitRange,
                q = n.count || 1,
                p;
            h = e(h, 1);

            if (m(l)) {
              r.set("Milliseconds", c, a >= v.second ? 0 : q * Math.floor(r.get("Milliseconds", c) / q));
              a >= v.second && r.set("Seconds", c, a >= v.minute ? 0 : q * Math.floor(r.get("Seconds", c) / q));
              a >= v.minute && r.set("Minutes", c, a >= v.hour ? 0 : q * Math.floor(r.get("Minutes", c) / q));
              a >= v.hour && r.set("Hours", c, a >= v.day ? 0 : q * Math.floor(r.get("Hours", c) / q));
              a >= v.day && r.set("Date", c, a >= v.month ? 1 : Math.max(1, q * Math.floor(r.get("Date", c) / q)));

              if (a >= v.month) {
                r.set("Month", c, a >= v.year ? 0 : q * Math.floor(r.get("Month", c) / q));
                var B = r.get("FullYear", c);
              }

              a >= v.year && r.set("FullYear", c, B - B % q);
              a === v.week && (B = r.get("Day", c), r.set("Date", c, r.get("Date", c) - B + h + (B < h ? -7 : 0)));
              B = r.get("FullYear", c);
              h = r.get("Month", c);
              var A = r.get("Date", c),
                  w = r.get("Hours", c);
              l = c.getTime();
              r.variableTimezone && (p = f - l > 4 * v.month || r.getTimezoneOffset(l) !== r.getTimezoneOffset(f));
              l = c.getTime();

              for (c = 1; l < f;) d.push(l), l = a === v.year ? r.makeTime(B + c * q, 0) : a === v.month ? r.makeTime(B, h + c * q) : !p || a !== v.day && a !== v.week ? p && a === v.hour && 1 < q ? r.makeTime(B, h, A, w + c * q) : l + a * q : r.makeTime(B, h, A + c * q * (a === v.day ? 1 : 7)), c++;

              d.push(l);
              a <= v.hour && 1E4 > d.length && d.forEach(function (a) {
                0 === a % 18E5 && "000000000" === r.dateFormat("%H%M%S%L", a) && (g[a] = "day");
              });
            }

            d.info = F(n, {
              higherRanks: g,
              totalRange: a * q
            });
            return d;
          };

          return h;
        }();

        f.Time = h;
        return f.Time;
      });
      N(m, "Core/Options.js", [m["Core/Globals.js"], m["Core/Color/Color.js"], m["Core/Time.js"], m["Core/Utilities.js"]], function (f, h, m, z) {
        var F = f.isTouchDevice,
            P = f.svg;
        h = h.parse;
        z = z.merge;
        "";
        f.defaultOptions = {
          colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "),
          symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
          lang: {
            loading: "Loading...",
            months: "January February March April May June July August September October November December".split(" "),
            shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
            weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
            decimalPoint: ".",
            numericSymbols: "kMGTPE".split(""),
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: " "
          },
          global: {},
          time: {
            Date: void 0,
            getTimezoneOffset: void 0,
            timezone: void 0,
            timezoneOffset: 0,
            useUTC: !0
          },
          chart: {
            styledMode: !1,
            borderRadius: 0,
            colorCount: 10,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [10, 10, 15, 10],
            resetZoomButton: {
              theme: {
                zIndex: 6
              },
              position: {
                align: "right",
                x: -10,
                y: 10
              }
            },
            width: null,
            height: null,
            borderColor: "#335cad",
            backgroundColor: "#ffffff",
            plotBorderColor: "#cccccc"
          },
          title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            widthAdjust: -44
          },
          subtitle: {
            text: "",
            align: "center",
            widthAdjust: -44
          },
          caption: {
            margin: 15,
            text: "",
            align: "left",
            verticalAlign: "bottom"
          },
          plotOptions: {},
          labels: {
            style: {
              position: "absolute",
              color: "#333333"
            }
          },
          legend: {
            enabled: !0,
            align: "center",
            alignColumns: !0,
            layout: "horizontal",
            labelFormatter: function labelFormatter() {
              return this.name;
            },
            borderColor: "#999999",
            borderRadius: 0,
            navigation: {
              activeColor: "#003399",
              inactiveColor: "#cccccc"
            },
            itemStyle: {
              color: "#333333",
              cursor: "pointer",
              fontSize: "12px",
              fontWeight: "bold",
              textOverflow: "ellipsis"
            },
            itemHoverStyle: {
              color: "#000000"
            },
            itemHiddenStyle: {
              color: "#cccccc"
            },
            shadow: !1,
            itemCheckboxStyle: {
              position: "absolute",
              width: "13px",
              height: "13px"
            },
            squareSymbol: !0,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
              style: {
                fontWeight: "bold"
              }
            }
          },
          loading: {
            labelStyle: {
              fontWeight: "bold",
              position: "relative",
              top: "45%"
            },
            style: {
              position: "absolute",
              backgroundColor: "#ffffff",
              opacity: .5,
              textAlign: "center"
            }
          },
          tooltip: {
            enabled: !0,
            animation: P,
            borderRadius: 3,
            dateTimeLabelFormats: {
              millisecond: "%A, %b %e, %H:%M:%S.%L",
              second: "%A, %b %e, %H:%M:%S",
              minute: "%A, %b %e, %H:%M",
              hour: "%A, %b %e, %H:%M",
              day: "%A, %b %e, %Y",
              week: "Week from %A, %b %e, %Y",
              month: "%B %Y",
              year: "%Y"
            },
            footerFormat: "",
            padding: 8,
            snap: F ? 25 : 10,
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
            backgroundColor: h("#f7f7f7").setOpacity(.85).get(),
            borderWidth: 1,
            shadow: !0,
            style: {
              color: "#333333",
              cursor: "default",
              fontSize: "12px",
              whiteSpace: "nowrap"
            }
          },
          credits: {
            enabled: !0,
            href: "https://www.highcharts.com?credits",
            position: {
              align: "right",
              x: -10,
              verticalAlign: "bottom",
              y: -5
            },
            style: {
              cursor: "pointer",
              color: "#999999",
              fontSize: "9px"
            },
            text: "Highcharts.com"
          }
        };
        "";
        f.time = new m(z(f.defaultOptions.global, f.defaultOptions.time));

        f.dateFormat = function (h, m, y) {
          return f.time.dateFormat(h, m, y);
        };

        return {
          dateFormat: f.dateFormat,
          defaultOptions: f.defaultOptions,
          time: f.time
        };
      });
      N(m, "Core/Axis/Axis.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Color/Color.js"], m["Core/Globals.js"], m["Core/Axis/Tick.js"], m["Core/Utilities.js"], m["Core/Options.js"]], function (f, h, m, z, F, L) {
        var K = f.animObject,
            C = F.addEvent,
            y = F.arrayMax,
            e = F.arrayMin,
            I = F.clamp,
            v = F.correctFloat,
            x = F.defined,
            D = F.destroyObjectProperties,
            n = F.error,
            l = F.extend,
            J = F.fireEvent,
            w = F.format,
            r = F.getMagnitude,
            d = F.isArray,
            g = F.isFunction,
            c = F.isNumber,
            a = F.isString,
            q = F.merge,
            p = F.normalizeTickInterval,
            B = F.objectEach,
            A = F.pick,
            G = F.relativeLength,
            M = F.removeEvent,
            T = F.splat,
            Q = F.syncTimeout,
            O = L.defaultOptions,
            E = m.deg2rad;

        f = function () {
          function u(b, k) {
            this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.oldMin = this.oldMax = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;
            this.init(b, k);
          }

          u.prototype.init = function (b, k) {
            var a = k.isX,
                c = this;
            c.chart = b;
            c.horiz = b.inverted && !c.isZAxis ? !a : a;
            c.isXAxis = a;
            c.coll = c.coll || (a ? "xAxis" : "yAxis");
            J(this, "init", {
              userOptions: k
            });
            c.opposite = k.opposite;
            c.side = k.side || (c.horiz ? c.opposite ? 0 : 2 : c.opposite ? 1 : 3);
            c.setOptions(k);
            var d = this.options,
                p = d.type;
            c.labelFormatter = d.labels.formatter || c.defaultLabelFormatter;
            c.userOptions = k;
            c.minPixelPadding = 0;
            c.reversed = d.reversed;
            c.visible = !1 !== d.visible;
            c.zoomEnabled = !1 !== d.zoomEnabled;
            c.hasNames = "category" === p || !0 === d.categories;
            c.categories = d.categories || c.hasNames;
            c.names || (c.names = [], c.names.keys = {});
            c.plotLinesAndBandsGroups = {};
            c.positiveValuesOnly = !!c.logarithmic;
            c.isLinked = x(d.linkedTo);
            c.ticks = {};
            c.labelEdge = [];
            c.minorTicks = {};
            c.plotLinesAndBands = [];
            c.alternateBands = {};
            c.len = 0;
            c.minRange = c.userMinRange = d.minRange || d.maxZoom;
            c.range = d.range;
            c.offset = d.offset || 0;
            c.max = null;
            c.min = null;
            c.crosshair = A(d.crosshair, T(b.options.tooltip.crosshairs)[a ? 0 : 1], !1);
            k = c.options.events;
            -1 === b.axes.indexOf(c) && (a ? b.axes.splice(b.xAxis.length, 0, c) : b.axes.push(c), b[c.coll].push(c));
            c.series = c.series || [];
            b.inverted && !c.isZAxis && a && "undefined" === typeof c.reversed && (c.reversed = !0);
            c.labelRotation = c.options.labels.rotation;
            B(k, function (b, k) {
              g(b) && C(c, k, b);
            });
            J(this, "afterInit");
          };

          u.prototype.setOptions = function (b) {
            this.options = q(u.defaultOptions, "yAxis" === this.coll && u.defaultYAxisOptions, [u.defaultTopAxisOptions, u.defaultRightAxisOptions, u.defaultBottomAxisOptions, u.defaultLeftAxisOptions][this.side], q(O[this.coll], b));
            J(this, "afterSetOptions", {
              userOptions: b
            });
          };

          u.prototype.defaultLabelFormatter = function () {
            var b = this.axis,
                k = c(this.value) ? this.value : NaN,
                a = b.chart.time,
                d = b.categories,
                g = this.dateTimeLabelFormat,
                p = O.lang,
                q = p.numericSymbols;
            p = p.numericSymbolMagnitude || 1E3;
            var e = q && q.length,
                u = b.options.labels.format;
            b = b.logarithmic ? Math.abs(k) : b.tickInterval;
            var B = this.chart,
                l = B.numberFormatter;
            if (u) var A = w(u, this, B);else if (d) A = "" + this.value;else if (g) A = a.dateFormat(g, k);else if (e && 1E3 <= b) for (; e-- && "undefined" === typeof A;) a = Math.pow(p, e + 1), b >= a && 0 === 10 * k % a && null !== q[e] && 0 !== k && (A = l(k / a, -1) + q[e]);
            "undefined" === typeof A && (A = 1E4 <= Math.abs(k) ? l(k, -1) : l(k, -1, void 0, ""));
            return A;
          };

          u.prototype.getSeriesExtremes = function () {
            var b = this,
                k = b.chart,
                a;
            J(this, "getSeriesExtremes", null, function () {
              b.hasVisibleSeries = !1;
              b.dataMin = b.dataMax = b.threshold = null;
              b.softThreshold = !b.isXAxis;
              b.stacking && b.stacking.buildStacks();
              b.series.forEach(function (t) {
                if (t.visible || !k.options.chart.ignoreHiddenSeries) {
                  var d = t.options,
                      g = d.threshold;
                  b.hasVisibleSeries = !0;
                  b.positiveValuesOnly && 0 >= g && (g = null);

                  if (b.isXAxis) {
                    if (d = t.xData, d.length) {
                      d = b.logarithmic ? d.filter(b.validatePositiveValue) : d;
                      a = t.getXExtremes(d);
                      var p = a.min;
                      var q = a.max;
                      c(p) || p instanceof Date || (d = d.filter(c), a = t.getXExtremes(d), p = a.min, q = a.max);
                      d.length && (b.dataMin = Math.min(A(b.dataMin, p), p), b.dataMax = Math.max(A(b.dataMax, q), q));
                    }
                  } else if (t = t.applyExtremes(), c(t.dataMin) && (p = t.dataMin, b.dataMin = Math.min(A(b.dataMin, p), p)), c(t.dataMax) && (q = t.dataMax, b.dataMax = Math.max(A(b.dataMax, q), q)), x(g) && (b.threshold = g), !d.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;
                }
              });
            });
            J(this, "afterGetSeriesExtremes");
          };

          u.prototype.translate = function (b, a, t, d, g, p) {
            var k = this.linkedParent || this,
                q = 1,
                e = 0,
                H = d ? k.oldTransA : k.transA;
            d = d ? k.oldMin : k.min;
            var u = k.minPixelPadding;
            g = (k.isOrdinal || k.brokenAxis && k.brokenAxis.hasBreaks || k.logarithmic && g) && k.lin2val;
            H || (H = k.transA);
            t && (q *= -1, e = k.len);
            k.reversed && (q *= -1, e -= q * (k.sector || k.len));
            a ? (b = (b * q + e - u) / H + d, g && (b = k.lin2val(b))) : (g && (b = k.val2lin(b)), b = c(d) ? q * (b - d) * H + e + q * u + (c(p) ? H * p : 0) : void 0);
            return b;
          };

          u.prototype.toPixels = function (b, k) {
            return this.translate(b, !1, !this.horiz, null, !0) + (k ? 0 : this.pos);
          };

          u.prototype.toValue = function (b, k) {
            return this.translate(b - (k ? 0 : this.pos), !0, !this.horiz, null, !0);
          };

          u.prototype.getPlotLinePath = function (b) {
            function k(b, a, k) {
              if ("pass" !== l && b < a || b > k) l ? b = I(b, a, k) : E = !0;
              return b;
            }

            var a = this,
                d = a.chart,
                g = a.left,
                p = a.top,
                q = b.old,
                e = b.value,
                u = b.translatedValue,
                B = b.lineWidth,
                l = b.force,
                r,
                n,
                f,
                h,
                w = q && d.oldChartHeight || d.chartHeight,
                G = q && d.oldChartWidth || d.chartWidth,
                E,
                v = a.transB;
            b = {
              value: e,
              lineWidth: B,
              old: q,
              force: l,
              acrossPanes: b.acrossPanes,
              translatedValue: u
            };
            J(this, "getPlotLinePath", b, function (b) {
              u = A(u, a.translate(e, null, null, q));
              u = I(u, -1E5, 1E5);
              r = f = Math.round(u + v);
              n = h = Math.round(w - u - v);
              c(u) ? a.horiz ? (n = p, h = w - a.bottom, r = f = k(r, g, g + a.width)) : (r = g, f = G - a.right, n = h = k(n, p, p + a.height)) : (E = !0, l = !1);
              b.path = E && !l ? null : d.renderer.crispLine([["M", r, n], ["L", f, h]], B || 1);
            });
            return b.path;
          };

          u.prototype.getLinearTickPositions = function (b, a, c) {
            var k = v(Math.floor(a / b) * b);
            c = v(Math.ceil(c / b) * b);
            var t = [],
                d;
            v(k + b) === k && (d = 20);
            if (this.single) return [a];

            for (a = k; a <= c;) {
              t.push(a);
              a = v(a + b, d);
              if (a === g) break;
              var g = a;
            }

            return t;
          };

          u.prototype.getMinorTickInterval = function () {
            var b = this.options;
            return !0 === b.minorTicks ? A(b.minorTickInterval, "auto") : !1 === b.minorTicks ? null : b.minorTickInterval;
          };

          u.prototype.getMinorTickPositions = function () {
            var b = this.options,
                a = this.tickPositions,
                c = this.minorTickInterval,
                d = [],
                g = this.pointRangePadding || 0,
                p = this.min - g;
            g = this.max + g;
            var q = g - p;

            if (q && q / c < this.len / 3) {
              var e = this.logarithmic;
              if (e) this.paddedTicks.forEach(function (b, a, k) {
                a && d.push.apply(d, e.getLogTickPositions(c, k[a - 1], k[a], !0));
              });else if (this.dateTime && "auto" === this.getMinorTickInterval()) d = d.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(c), p, g, b.startOfWeek));else for (b = p + (a[0] - p) % c; b <= g && b !== d[0]; b += c) d.push(b);
            }

            0 !== d.length && this.trimTicks(d);
            return d;
          };

          u.prototype.adjustForMinRange = function () {
            var b = this.options,
                a = this.min,
                c = this.max,
                d = this.logarithmic,
                g,
                p,
                q,
                u,
                B;
            this.isXAxis && "undefined" === typeof this.minRange && !d && (x(b.min) || x(b.max) ? this.minRange = null : (this.series.forEach(function (b) {
              u = b.xData;

              for (p = B = b.xIncrement ? 1 : u.length - 1; 0 < p; p--) if (q = u[p] - u[p - 1], "undefined" === typeof g || q < g) g = q;
            }), this.minRange = Math.min(5 * g, this.dataMax - this.dataMin)));

            if (c - a < this.minRange) {
              var l = this.dataMax - this.dataMin >= this.minRange;
              var r = this.minRange;
              var n = (r - c + a) / 2;
              n = [a - n, A(b.min, a - n)];
              l && (n[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
              a = y(n);
              c = [a + r, A(b.max, a + r)];
              l && (c[2] = d ? d.log2lin(this.dataMax) : this.dataMax);
              c = e(c);
              c - a < r && (n[0] = c - r, n[1] = A(b.min, c - r), a = y(n));
            }

            this.min = a;
            this.max = c;
          };

          u.prototype.getClosest = function () {
            var b;
            this.categories ? b = 1 : this.series.forEach(function (a) {
              var k = a.closestPointRange,
                  c = a.visible || !a.chart.options.chart.ignoreHiddenSeries;
              !a.noSharedTooltip && x(k) && c && (b = x(b) ? Math.min(b, k) : k);
            });
            return b;
          };

          u.prototype.nameToX = function (b) {
            var a = d(this.categories),
                c = a ? this.categories : this.names,
                g = b.options.x;
            b.series.requireSorting = !1;
            x(g) || (g = !1 === this.options.uniqueNames ? b.series.autoIncrement() : a ? c.indexOf(b.name) : A(c.keys[b.name], -1));

            if (-1 === g) {
              if (!a) var p = c.length;
            } else p = g;

            "undefined" !== typeof p && (this.names[p] = b.name, this.names.keys[b.name] = p);
            return p;
          };

          u.prototype.updateNames = function () {
            var b = this,
                a = this.names;
            0 < a.length && (Object.keys(a.keys).forEach(function (b) {
              delete a.keys[b];
            }), a.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (a) {
              a.xIncrement = null;
              if (!a.points || a.isDirtyData) b.max = Math.max(b.max, a.xData.length - 1), a.processData(), a.generatePoints();
              a.data.forEach(function (k, c) {
                if (k && k.options && "undefined" !== typeof k.name) {
                  var d = b.nameToX(k);
                  "undefined" !== typeof d && d !== k.x && (k.x = d, a.xData[c] = d);
                }
              });
            }));
          };

          u.prototype.setAxisTranslation = function (b) {
            var k = this,
                c = k.max - k.min,
                d = k.axisPointRange || 0,
                g = 0,
                p = 0,
                q = k.linkedParent,
                e = !!k.categories,
                u = k.transA,
                B = k.isXAxis;

            if (B || e || d) {
              var l = k.getClosest();
              q ? (g = q.minPointOffset, p = q.pointRangePadding) : k.series.forEach(function (b) {
                var c = e ? 1 : B ? A(b.options.pointRange, l, 0) : k.axisPointRange || 0,
                    t = b.options.pointPlacement;
                d = Math.max(d, c);
                if (!k.single || e) b = b.is("xrange") ? !B : B, g = Math.max(g, b && a(t) ? 0 : c / 2), p = Math.max(p, b && "on" === t ? 0 : c);
              });
              q = k.ordinal && k.ordinal.slope && l ? k.ordinal.slope / l : 1;
              k.minPointOffset = g *= q;
              k.pointRangePadding = p *= q;
              k.pointRange = Math.min(d, k.single && e ? 1 : c);
              B && (k.closestPointRange = l);
            }

            b && (k.oldTransA = u);
            k.translationSlope = k.transA = u = k.staticScale || k.len / (c + p || 1);
            k.transB = k.horiz ? k.left : k.bottom;
            k.minPixelPadding = u * g;
            J(this, "afterSetAxisTranslation");
          };

          u.prototype.minFromRange = function () {
            return this.max - this.range;
          };

          u.prototype.setTickInterval = function (b) {
            var a = this,
                d = a.chart,
                g = a.logarithmic,
                q = a.options,
                e = a.isXAxis,
                u = a.isLinked,
                B = q.maxPadding,
                l = q.minPadding,
                f = q.tickInterval,
                h = q.tickPixelInterval,
                w = a.categories,
                G = c(a.threshold) ? a.threshold : null,
                E = a.softThreshold;
            a.dateTime || w || u || this.getTickAmount();
            var O = A(a.userMin, q.min);
            var D = A(a.userMax, q.max);

            if (u) {
              a.linkedParent = d[a.coll][q.linkedTo];
              var M = a.linkedParent.getExtremes();
              a.min = A(M.min, M.dataMin);
              a.max = A(M.max, M.dataMax);
              q.type !== a.linkedParent.options.type && n(11, 1, d);
            } else {
              if (E && x(G)) if (a.dataMin >= G) M = G, l = 0;else if (a.dataMax <= G) {
                var m = G;
                B = 0;
              }
              a.min = A(O, M, a.dataMin);
              a.max = A(D, m, a.dataMax);
            }

            g && (a.positiveValuesOnly && !b && 0 >= Math.min(a.min, A(a.dataMin, a.min)) && n(10, 1, d), a.min = v(g.log2lin(a.min), 16), a.max = v(g.log2lin(a.max), 16));
            a.range && x(a.max) && (a.userMin = a.min = O = Math.max(a.dataMin, a.minFromRange()), a.userMax = D = a.max, a.range = null);
            J(a, "foundExtremes");
            a.beforePadding && a.beforePadding();
            a.adjustForMinRange();
            !(w || a.axisPointRange || a.stacking && a.stacking.usePercentage || u) && x(a.min) && x(a.max) && (d = a.max - a.min) && (!x(O) && l && (a.min -= d * l), !x(D) && B && (a.max += d * B));
            c(a.userMin) || (c(q.softMin) && q.softMin < a.min && (a.min = O = q.softMin), c(q.floor) && (a.min = Math.max(a.min, q.floor)));
            c(a.userMax) || (c(q.softMax) && q.softMax > a.max && (a.max = D = q.softMax), c(q.ceiling) && (a.max = Math.min(a.max, q.ceiling)));
            E && x(a.dataMin) && (G = G || 0, !x(O) && a.min < G && a.dataMin >= G ? a.min = a.options.minRange ? Math.min(G, a.max - a.minRange) : G : !x(D) && a.max > G && a.dataMax <= G && (a.max = a.options.minRange ? Math.max(G, a.min + a.minRange) : G));
            a.tickInterval = a.min === a.max || "undefined" === typeof a.min || "undefined" === typeof a.max ? 1 : u && !f && h === a.linkedParent.options.tickPixelInterval ? f = a.linkedParent.tickInterval : A(f, this.tickAmount ? (a.max - a.min) / Math.max(this.tickAmount - 1, 1) : void 0, w ? 1 : (a.max - a.min) * h / Math.max(a.len, h));
            e && !b && a.series.forEach(function (b) {
              b.processData(a.min !== a.oldMin || a.max !== a.oldMax);
            });
            a.setAxisTranslation(!0);
            J(this, "initialAxisTranslation");
            a.pointRange && !f && (a.tickInterval = Math.max(a.pointRange, a.tickInterval));
            b = A(q.minTickInterval, a.dateTime && !a.series.some(function (b) {
              return b.noSharedTooltip;
            }) ? a.closestPointRange : 0);
            !f && a.tickInterval < b && (a.tickInterval = b);
            a.dateTime || a.logarithmic || f || (a.tickInterval = p(a.tickInterval, void 0, r(a.tickInterval), A(q.allowDecimals, .5 > a.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));
            this.tickAmount || (a.tickInterval = a.unsquish());
            this.setTickPositions();
          };

          u.prototype.setTickPositions = function () {
            var b = this.options,
                a = b.tickPositions;
            var c = this.getMinorTickInterval();
            var d = b.tickPositioner,
                g = this.hasVerticalPanning(),
                p = "colorAxis" === this.coll,
                q = (p || !g) && b.startOnTick;
            g = (p || !g) && b.endOnTick;
            this.tickmarkOffset = this.categories && "between" === b.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;
            this.minorTickInterval = "auto" === c && this.tickInterval ? this.tickInterval / 5 : c;
            this.single = this.min === this.max && x(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== b.allowDecimals);
            this.tickPositions = c = a && a.slice();
            !c && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? c = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b.units), this.min, this.max, b.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (c = [this.min, this.max], n(19, !1, this.chart)), c.length > this.len && (c = [c[0], c.pop()], c[0] === c[1] && (c.length = 1)), this.tickPositions = c, d && (d = d.apply(this, [this.min, this.max]))) && (this.tickPositions = c = d);
            this.paddedTicks = c.slice(0);
            this.trimTicks(c, q, g);
            this.isLinked || (this.single && 2 > c.length && !this.categories && !this.series.some(function (b) {
              return b.is("heatmap") && "between" === b.options.pointPlacement;
            }) && (this.min -= .5, this.max += .5), a || d || this.adjustTickAmount());
            J(this, "afterSetTickPositions");
          };

          u.prototype.trimTicks = function (b, a, c) {
            var k = b[0],
                d = b[b.length - 1],
                t = !this.isOrdinal && this.minPointOffset || 0;
            J(this, "trimTicks");

            if (!this.isLinked) {
              if (a && -Infinity !== k) this.min = k;else for (; this.min - t > b[0];) b.shift();
              if (c) this.max = d;else for (; this.max + t < b[b.length - 1];) b.pop();
              0 === b.length && x(k) && !this.options.tickPositions && b.push((d + k) / 2);
            }
          };

          u.prototype.alignToOthers = function () {
            var b = {},
                a,
                c = this.options;
            !1 === this.chart.options.chart.alignTicks || !1 === c.alignTicks || !1 === c.startOnTick || !1 === c.endOnTick || this.logarithmic || this.chart[this.coll].forEach(function (k) {
              var c = k.options;
              c = [k.horiz ? c.left : c.top, c.width, c.height, c.pane].join();
              k.series.length && (b[c] ? a = !0 : b[c] = 1);
            });
            return a;
          };

          u.prototype.getTickAmount = function () {
            var b = this.options,
                a = b.tickAmount,
                c = b.tickPixelInterval;
            !x(b.tickInterval) && !a && this.len < c && !this.isRadial && !this.logarithmic && b.startOnTick && b.endOnTick && (a = 2);
            !a && this.alignToOthers() && (a = Math.ceil(this.len / c) + 1);
            4 > a && (this.finalTickAmt = a, a = 5);
            this.tickAmount = a;
          };

          u.prototype.adjustTickAmount = function () {
            var b = this.options,
                a = this.tickInterval,
                c = this.tickPositions,
                d = this.tickAmount,
                g = this.finalTickAmt,
                p = c && c.length,
                q = A(this.threshold, this.softThreshold ? 0 : null),
                e;

            if (this.hasData()) {
              if (p < d) {
                for (e = this.min; c.length < d;) c.length % 2 || e === q ? c.push(v(c[c.length - 1] + a)) : c.unshift(v(c[0] - a));

                this.transA *= (p - 1) / (d - 1);
                this.min = b.startOnTick ? c[0] : Math.min(this.min, c[0]);
                this.max = b.endOnTick ? c[c.length - 1] : Math.max(this.max, c[c.length - 1]);
              } else p > d && (this.tickInterval *= 2, this.setTickPositions());

              if (x(g)) {
                for (a = b = c.length; a--;) (3 === g && 1 === a % 2 || 2 >= g && 0 < a && a < b - 1) && c.splice(a, 1);

                this.finalTickAmt = void 0;
              }
            }
          };

          u.prototype.setScale = function () {
            var b,
                a = !1,
                c = !1;
            this.series.forEach(function (b) {
              var k;
              a = a || b.isDirtyData || b.isDirty;
              c = c || (null === (k = b.xAxis) || void 0 === k ? void 0 : k.isDirty) || !1;
            });
            this.oldMin = this.min;
            this.oldMax = this.max;
            this.oldAxisLength = this.len;
            this.setAxisSize();
            (b = this.len !== this.oldAxisLength) || a || c || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.stacking && this.stacking.cleanStacks();
            a && this.panningState && (this.panningState.isDirty = !0);
            J(this, "afterSetScale");
          };

          u.prototype.setExtremes = function (b, a, c, d, g) {
            var k = this,
                t = k.chart;
            c = A(c, !0);
            k.series.forEach(function (b) {
              delete b.kdTree;
            });
            g = l(g, {
              min: b,
              max: a
            });
            J(k, "setExtremes", g, function () {
              k.userMin = b;
              k.userMax = a;
              k.eventArgs = g;
              c && t.redraw(d);
            });
          };

          u.prototype.zoom = function (b, a) {
            var k = this,
                c = this.dataMin,
                d = this.dataMax,
                g = this.options,
                p = Math.min(c, A(g.min, c)),
                q = Math.max(d, A(g.max, d));
            b = {
              newMin: b,
              newMax: a
            };
            J(this, "zoom", b, function (b) {
              var a = b.newMin,
                  g = b.newMax;
              if (a !== k.min || g !== k.max) k.allowZoomOutside || (x(c) && (a < p && (a = p), a > q && (a = q)), x(d) && (g < p && (g = p), g > q && (g = q))), k.displayBtn = "undefined" !== typeof a || "undefined" !== typeof g, k.setExtremes(a, g, !1, void 0, {
                trigger: "zoom"
              });
              b.zoomed = !0;
            });
            return b.zoomed;
          };

          u.prototype.setAxisSize = function () {
            var b = this.chart,
                a = this.options,
                c = a.offsets || [0, 0, 0, 0],
                d = this.horiz,
                g = this.width = Math.round(G(A(a.width, b.plotWidth - c[3] + c[1]), b.plotWidth)),
                p = this.height = Math.round(G(A(a.height, b.plotHeight - c[0] + c[2]), b.plotHeight)),
                q = this.top = Math.round(G(A(a.top, b.plotTop + c[0]), b.plotHeight, b.plotTop));
            a = this.left = Math.round(G(A(a.left, b.plotLeft + c[3]), b.plotWidth, b.plotLeft));
            this.bottom = b.chartHeight - p - q;
            this.right = b.chartWidth - g - a;
            this.len = Math.max(d ? g : p, 0);
            this.pos = d ? a : q;
          };

          u.prototype.getExtremes = function () {
            var b = this.logarithmic;
            return {
              min: b ? v(b.lin2log(this.min)) : this.min,
              max: b ? v(b.lin2log(this.max)) : this.max,
              dataMin: this.dataMin,
              dataMax: this.dataMax,
              userMin: this.userMin,
              userMax: this.userMax
            };
          };

          u.prototype.getThreshold = function (b) {
            var a = this.logarithmic,
                c = a ? a.lin2log(this.min) : this.min;
            a = a ? a.lin2log(this.max) : this.max;
            null === b || -Infinity === b ? b = c : Infinity === b ? b = a : c > b ? b = c : a < b && (b = a);
            return this.translate(b, 0, 1, 0, 1);
          };

          u.prototype.autoLabelAlign = function (b) {
            var a = (A(b, 0) - 90 * this.side + 720) % 360;
            b = {
              align: "center"
            };
            J(this, "autoLabelAlign", b, function (b) {
              15 < a && 165 > a ? b.align = "right" : 195 < a && 345 > a && (b.align = "left");
            });
            return b.align;
          };

          u.prototype.tickSize = function (b) {
            var a = this.options,
                c = a["tick" === b ? "tickLength" : "minorTickLength"],
                d = A(a["tick" === b ? "tickWidth" : "minorTickWidth"], "tick" === b && this.isXAxis && !this.categories ? 1 : 0);

            if (d && c) {
              "inside" === a[b + "Position"] && (c = -c);
              var g = [c, d];
            }

            b = {
              tickSize: g
            };
            J(this, "afterTickSize", b);
            return b.tickSize;
          };

          u.prototype.labelMetrics = function () {
            var b = this.tickPositions && this.tickPositions[0] || 0;
            return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[b] && this.ticks[b].label);
          };

          u.prototype.unsquish = function () {
            var b = this.options.labels,
                a = this.horiz,
                c = this.tickInterval,
                d = c,
                g = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / c),
                p,
                q = b.rotation,
                e = this.labelMetrics(),
                u,
                B = Number.MAX_VALUE,
                l,
                r = this.max - this.min,
                n = function n(b) {
              var a = b / (g || 1);
              a = 1 < a ? Math.ceil(a) : 1;
              a * c > r && Infinity !== b && Infinity !== g && r && (a = Math.ceil(r / c));
              return v(a * c);
            };

            a ? (l = !b.staggerLines && !b.step && (x(q) ? [q] : g < A(b.autoRotationLimit, 80) && b.autoRotation)) && l.forEach(function (b) {
              if (b === q || b && -90 <= b && 90 >= b) {
                u = n(Math.abs(e.h / Math.sin(E * b)));
                var a = u + Math.abs(b / 360);
                a < B && (B = a, p = b, d = u);
              }
            }) : b.step || (d = n(e.h));
            this.autoRotation = l;
            this.labelRotation = A(p, q);
            return d;
          };

          u.prototype.getSlotWidth = function (b) {
            var a,
                d = this.chart,
                g = this.horiz,
                p = this.options.labels,
                q = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                e = d.margin[3];
            if (b && c(b.slotWidth)) return b.slotWidth;
            if (g && p && 2 > (p.step || 0)) return p.rotation ? 0 : (this.staggerLines || 1) * this.len / q;

            if (!g) {
              b = null === (a = null === p || void 0 === p ? void 0 : p.style) || void 0 === a ? void 0 : a.width;
              if (void 0 !== b) return parseInt(b, 10);
              if (e) return e - d.spacing[3];
            }

            return .33 * d.chartWidth;
          };

          u.prototype.renderUnsquish = function () {
            var b = this.chart,
                k = b.renderer,
                c = this.tickPositions,
                d = this.ticks,
                g = this.options.labels,
                p = g && g.style || {},
                q = this.horiz,
                e = this.getSlotWidth(),
                u = Math.max(1, Math.round(e - 2 * (g.padding || 5))),
                B = {},
                l = this.labelMetrics(),
                r = g.style && g.style.textOverflow,
                n = 0;
            a(g.rotation) || (B.rotation = g.rotation || 0);
            c.forEach(function (b) {
              b = d[b];
              b.movedLabel && b.replaceMovedLabel();
              b && b.label && b.label.textPxLength > n && (n = b.label.textPxLength);
            });
            this.maxLabelLength = n;
            if (this.autoRotation) n > u && n > l.h ? B.rotation = this.labelRotation : this.labelRotation = 0;else if (e) {
              var A = u;

              if (!r) {
                var f = "clip";

                for (u = c.length; !q && u--;) {
                  var h = c[u];
                  if (h = d[h].label) h.styles && "ellipsis" === h.styles.textOverflow ? h.css({
                    textOverflow: "clip"
                  }) : h.textPxLength > e && h.css({
                    width: e + "px"
                  }), h.getBBox().height > this.len / c.length - (l.h - l.f) && (h.specificTextOverflow = "ellipsis");
                }
              }
            }
            B.rotation && (A = n > .5 * b.chartHeight ? .33 * b.chartHeight : n, r || (f = "ellipsis"));
            if (this.labelAlign = g.align || this.autoLabelAlign(this.labelRotation)) B.align = this.labelAlign;
            c.forEach(function (b) {
              var a = (b = d[b]) && b.label,
                  k = p.width,
                  c = {};
              a && (a.attr(B), b.shortenLabel ? b.shortenLabel() : A && !k && "nowrap" !== p.whiteSpace && (A < a.textPxLength || "SPAN" === a.element.tagName) ? (c.width = A + "px", r || (c.textOverflow = a.specificTextOverflow || f), a.css(c)) : a.styles && a.styles.width && !c.width && !k && a.css({
                width: null
              }), delete a.specificTextOverflow, b.rotation = B.rotation);
            }, this);
            this.tickRotCorr = k.rotCorr(l.b, this.labelRotation || 0, 0 !== this.side);
          };

          u.prototype.hasData = function () {
            return this.series.some(function (b) {
              return b.hasData();
            }) || this.options.showEmpty && x(this.min) && x(this.max);
          };

          u.prototype.addTitle = function (b) {
            var a = this.chart.renderer,
                c = this.horiz,
                d = this.opposite,
                g = this.options.title,
                p,
                e = this.chart.styledMode;
            this.axisTitle || ((p = g.textAlign) || (p = (c ? {
              low: "left",
              middle: "center",
              high: "right"
            } : {
              low: d ? "right" : "left",
              middle: "center",
              high: d ? "left" : "right"
            })[g.align]), this.axisTitle = a.text(g.text, 0, 0, g.useHTML).attr({
              zIndex: 7,
              rotation: g.rotation || 0,
              align: p
            }).addClass("highcharts-axis-title"), e || this.axisTitle.css(q(g.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);
            e || g.style.width || this.isRadial || this.axisTitle.css({
              width: this.len + "px"
            });
            this.axisTitle[b ? "show" : "hide"](b);
          };

          u.prototype.generateTick = function (b) {
            var a = this.ticks;
            a[b] ? a[b].addLabel() : a[b] = new z(this, b);
          };

          u.prototype.getOffset = function () {
            var b = this,
                a = b.chart,
                c = a.renderer,
                d = b.options,
                g = b.tickPositions,
                p = b.ticks,
                q = b.horiz,
                e = b.side,
                u = a.inverted && !b.isZAxis ? [1, 0, 3, 2][e] : e,
                l,
                n = 0,
                r = 0,
                f = d.title,
                h = d.labels,
                G = 0,
                w = a.axisOffset;
            a = a.clipOffset;
            var E = [-1, 1, 1, -1][e],
                v = d.className,
                O = b.axisParent;
            var D = b.hasData();
            b.showAxis = l = D || A(d.showEmpty, !0);
            b.staggerLines = b.horiz && h.staggerLines;
            b.axisGroup || (b.gridGroup = c.g("grid").attr({
              zIndex: d.gridZIndex || 1
            }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (v || "")).add(O), b.axisGroup = c.g("axis").attr({
              zIndex: d.zIndex || 2
            }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (v || "")).add(O), b.labelGroup = c.g("axis-labels").attr({
              zIndex: h.zIndex || 7
            }).addClass("highcharts-" + b.coll.toLowerCase() + "-labels " + (v || "")).add(O));
            D || b.isLinked ? (g.forEach(function (a, c) {
              b.generateTick(a, c);
            }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === e || 2 === e || {
              1: "left",
              3: "right"
            }[e] === b.labelAlign, A(h.reserveSpace, "center" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && g.forEach(function (b) {
              G = Math.max(p[b].getLabelSize(), G);
            }), b.staggerLines && (G *= b.staggerLines), b.labelOffset = G * (b.opposite ? -1 : 1)) : B(p, function (b, a) {
              b.destroy();
              delete p[a];
            });

            if (f && f.text && !1 !== f.enabled && (b.addTitle(l), l && !1 !== f.reserveSpace)) {
              b.titleOffset = n = b.axisTitle.getBBox()[q ? "height" : "width"];
              var M = f.offset;
              r = x(M) ? 0 : A(f.margin, q ? 5 : 10);
            }

            b.renderLine();
            b.offset = E * A(d.offset, w[e] ? w[e] + (d.margin || 0) : 0);
            b.tickRotCorr = b.tickRotCorr || {
              x: 0,
              y: 0
            };
            c = 0 === e ? -b.labelMetrics().h : 2 === e ? b.tickRotCorr.y : 0;
            r = Math.abs(G) + r;
            G && (r = r - c + E * (q ? A(h.y, b.tickRotCorr.y + 8 * E) : h.x));
            b.axisTitleMargin = A(M, r);
            b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(p, g));
            q = this.tickSize("tick");
            w[e] = Math.max(w[e], b.axisTitleMargin + n + E * b.offset, r, g && g.length && q ? q[0] + E * b.offset : 0);
            d = d.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2);
            a[u] = Math.max(a[u], d);
            J(this, "afterGetOffset");
          };

          u.prototype.getLinePath = function (b) {
            var a = this.chart,
                c = this.opposite,
                d = this.offset,
                g = this.horiz,
                p = this.left + (c ? this.width : 0) + d;
            d = a.chartHeight - this.bottom - (c ? this.height : 0) + d;
            c && (b *= -1);
            return a.renderer.crispLine([["M", g ? this.left : p, g ? d : this.top], ["L", g ? a.chartWidth - this.right : p, g ? d : a.chartHeight - this.bottom]], b);
          };

          u.prototype.renderLine = function () {
            this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({
              stroke: this.options.lineColor,
              "stroke-width": this.options.lineWidth,
              zIndex: 7
            }));
          };

          u.prototype.getTitlePosition = function () {
            var b = this.horiz,
                a = this.left,
                c = this.top,
                d = this.len,
                g = this.options.title,
                p = b ? a : c,
                q = this.opposite,
                e = this.offset,
                u = g.x || 0,
                B = g.y || 0,
                l = this.axisTitle,
                r = this.chart.renderer.fontMetrics(g.style && g.style.fontSize, l);
            l = Math.max(l.getBBox(null, 0).height - r.h - 1, 0);
            d = {
              low: p + (b ? 0 : d),
              middle: p + d / 2,
              high: p + (b ? d : 0)
            }[g.align];
            a = (b ? c + this.height : a) + (b ? 1 : -1) * (q ? -1 : 1) * this.axisTitleMargin + [-l, l, r.f, -l][this.side];
            b = {
              x: b ? d + u : a + (q ? this.width : 0) + e + u,
              y: b ? a + B - (q ? this.height : 0) + e : d + B
            };
            J(this, "afterGetTitlePosition", {
              titlePosition: b
            });
            return b;
          };

          u.prototype.renderMinorTick = function (b) {
            var a = this.chart.hasRendered && c(this.oldMin),
                d = this.minorTicks;
            d[b] || (d[b] = new z(this, b, "minor"));
            a && d[b].isNew && d[b].render(null, !0);
            d[b].render(null, !1, 1);
          };

          u.prototype.renderTick = function (b, a) {
            var k,
                d = this.isLinked,
                g = this.ticks,
                p = this.chart.hasRendered && c(this.oldMin);
            if (!d || b >= this.min && b <= this.max || (null === (k = this.grid) || void 0 === k ? 0 : k.isColumn)) g[b] || (g[b] = new z(this, b)), p && g[b].isNew && g[b].render(a, !0, -1), g[b].render(a);
          };

          u.prototype.render = function () {
            var b = this,
                a = b.chart,
                d = b.logarithmic,
                g = b.options,
                p = b.isLinked,
                q = b.tickPositions,
                e = b.axisTitle,
                u = b.ticks,
                l = b.minorTicks,
                r = b.alternateBands,
                n = g.stackLabels,
                f = g.alternateGridColor,
                A = b.tickmarkOffset,
                h = b.axisLine,
                G = b.showAxis,
                w = K(a.renderer.globalAnimation),
                E,
                v;
            b.labelEdge.length = 0;
            b.overlap = !1;
            [u, l, r].forEach(function (b) {
              B(b, function (b) {
                b.isActive = !1;
              });
            });
            if (b.hasData() || p) b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (a) {
              b.renderMinorTick(a);
            }), q.length && (q.forEach(function (a, c) {
              b.renderTick(a, c);
            }), A && (0 === b.min || b.single) && (u[-1] || (u[-1] = new z(b, -1, null, !0)), u[-1].render(-1))), f && q.forEach(function (c, k) {
              v = "undefined" !== typeof q[k + 1] ? q[k + 1] + A : b.max - A;
              0 === k % 2 && c < b.max && v <= b.max + (a.polar ? -A : A) && (r[c] || (r[c] = new m.PlotLineOrBand(b)), E = c + A, r[c].options = {
                from: d ? d.lin2log(E) : E,
                to: d ? d.lin2log(v) : v,
                color: f,
                className: "highcharts-alternate-grid"
              }, r[c].render(), r[c].isActive = !0);
            }), b._addedPlotLB || ((g.plotLines || []).concat(g.plotBands || []).forEach(function (a) {
              b.addPlotBandOrLine(a);
            }), b._addedPlotLB = !0);
            [u, l, r].forEach(function (b) {
              var c,
                  k = [],
                  d = w.duration;
              B(b, function (b, a) {
                b.isActive || (b.render(a, !1, 0), b.isActive = !1, k.push(a));
              });
              Q(function () {
                for (c = k.length; c--;) b[k[c]] && !b[k[c]].isActive && (b[k[c]].destroy(), delete b[k[c]]);
              }, b !== r && a.hasRendered && d ? d : 0);
            });
            h && (h[h.isPlaced ? "animate" : "attr"]({
              d: this.getLinePath(h.strokeWidth())
            }), h.isPlaced = !0, h[G ? "show" : "hide"](G));
            e && G && (g = b.getTitlePosition(), c(g.y) ? (e[e.isNew ? "attr" : "animate"](g), e.isNew = !1) : (e.attr("y", -9999), e.isNew = !0));
            n && n.enabled && b.stacking && b.stacking.renderStackTotals();
            b.isDirty = !1;
            J(this, "afterRender");
          };

          u.prototype.redraw = function () {
            this.visible && (this.render(), this.plotLinesAndBands.forEach(function (b) {
              b.render();
            }));
            this.series.forEach(function (b) {
              b.isDirty = !0;
            });
          };

          u.prototype.getKeepProps = function () {
            return this.keepProps || u.keepProps;
          };

          u.prototype.destroy = function (b) {
            var a = this,
                c = a.plotLinesAndBands,
                d;
            J(this, "destroy", {
              keepEvents: b
            });
            b || M(a);
            [a.ticks, a.minorTicks, a.alternateBands].forEach(function (b) {
              D(b);
            });
            if (c) for (b = c.length; b--;) c[b].destroy();
            "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function (b) {
              a[b] && (a[b] = a[b].destroy());
            });

            for (d in a.plotLinesAndBandsGroups) a.plotLinesAndBandsGroups[d] = a.plotLinesAndBandsGroups[d].destroy();

            B(a, function (b, c) {
              -1 === a.getKeepProps().indexOf(c) && delete a[c];
            });
          };

          u.prototype.drawCrosshair = function (b, a) {
            var c = this.crosshair,
                k = A(c.snap, !0),
                d,
                g = this.cross,
                p = this.chart;
            J(this, "drawCrosshair", {
              e: b,
              point: a
            });
            b || (b = this.cross && this.cross.e);

            if (this.crosshair && !1 !== (x(a) || !k)) {
              k ? x(a) && (d = A("colorAxis" !== this.coll ? a.crosshairPos : null, this.isXAxis ? a.plotX : this.len - a.plotY)) : d = b && (this.horiz ? b.chartX - this.pos : this.len - b.chartY + this.pos);

              if (x(d)) {
                var q = {
                  value: a && (this.isXAxis ? a.x : A(a.stackY, a.y)),
                  translatedValue: d
                };
                p.polar && l(q, {
                  isCrosshair: !0,
                  chartX: b && b.chartX,
                  chartY: b && b.chartY,
                  point: a
                });
                q = this.getPlotLinePath(q) || null;
              }

              if (!x(q)) {
                this.hideCrosshair();
                return;
              }

              k = this.categories && !this.isRadial;
              g || (this.cross = g = p.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (k ? "category " : "thin ") + c.className).attr({
                zIndex: A(c.zIndex, 2)
              }).add(), p.styledMode || (g.attr({
                stroke: c.color || (k ? h.parse("#ccd6eb").setOpacity(.25).get() : "#cccccc"),
                "stroke-width": A(c.width, 1)
              }).css({
                "pointer-events": "none"
              }), c.dashStyle && g.attr({
                dashstyle: c.dashStyle
              })));
              g.show().attr({
                d: q
              });
              k && !c.width && g.attr({
                "stroke-width": this.transA
              });
              this.cross.e = b;
            } else this.hideCrosshair();

            J(this, "afterDrawCrosshair", {
              e: b,
              point: a
            });
          };

          u.prototype.hideCrosshair = function () {
            this.cross && this.cross.hide();
            J(this, "afterHideCrosshair");
          };

          u.prototype.hasVerticalPanning = function () {
            var b, a;
            return /y/.test((null === (a = null === (b = this.chart.options.chart) || void 0 === b ? void 0 : b.panning) || void 0 === a ? void 0 : a.type) || "");
          };

          u.prototype.validatePositiveValue = function (b) {
            return c(b) && 0 < b;
          };

          u.defaultOptions = {
            dateTimeLabelFormats: {
              millisecond: {
                main: "%H:%M:%S.%L",
                range: !1
              },
              second: {
                main: "%H:%M:%S",
                range: !1
              },
              minute: {
                main: "%H:%M",
                range: !1
              },
              hour: {
                main: "%H:%M",
                range: !1
              },
              day: {
                main: "%e. %b"
              },
              week: {
                main: "%e. %b"
              },
              month: {
                main: "%b '%y"
              },
              year: {
                main: "%Y"
              }
            },
            endOnTick: !1,
            labels: {
              enabled: !0,
              indentation: 10,
              x: 0,
              style: {
                color: "#666666",
                cursor: "default",
                fontSize: "11px"
              }
            },
            maxPadding: .01,
            minorTickLength: 2,
            minorTickPosition: "outside",
            minPadding: .01,
            showEmpty: !0,
            startOfWeek: 1,
            startOnTick: !1,
            tickLength: 10,
            tickPixelInterval: 100,
            tickmarkPlacement: "between",
            tickPosition: "outside",
            title: {
              align: "middle",
              style: {
                color: "#666666"
              }
            },
            type: "linear",
            minorGridLineColor: "#f2f2f2",
            minorGridLineWidth: 1,
            minorTickColor: "#999999",
            lineColor: "#ccd6eb",
            lineWidth: 1,
            gridLineColor: "#e6e6e6",
            tickColor: "#ccd6eb"
          };
          u.defaultYAxisOptions = {
            endOnTick: !0,
            maxPadding: .05,
            minPadding: .05,
            tickPixelInterval: 72,
            showLastLabel: !0,
            labels: {
              x: -8
            },
            startOnTick: !0,
            title: {
              rotation: 270,
              text: "Values"
            },
            stackLabels: {
              animation: {},
              allowOverlap: !1,
              enabled: !1,
              crop: !0,
              overflow: "justify",
              formatter: function formatter() {
                var b = this.axis.chart.numberFormatter;
                return b(this.total, -1);
              },
              style: {
                color: "#000000",
                fontSize: "11px",
                fontWeight: "bold",
                textOutline: "1px contrast"
              }
            },
            gridLineWidth: 1,
            lineWidth: 0
          };
          u.defaultLeftAxisOptions = {
            labels: {
              x: -15
            },
            title: {
              rotation: 270
            }
          };
          u.defaultRightAxisOptions = {
            labels: {
              x: 15
            },
            title: {
              rotation: 90
            }
          };
          u.defaultBottomAxisOptions = {
            labels: {
              autoRotation: [-45],
              x: 0
            },
            margin: 15,
            title: {
              rotation: 0
            }
          };
          u.defaultTopAxisOptions = {
            labels: {
              autoRotation: [-45],
              x: 0
            },
            margin: 15,
            title: {
              rotation: 0
            }
          };
          u.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
          return u;
        }();

        m.Axis = f;
        return m.Axis;
      });
      N(m, "Core/Axis/DateTimeAxis.js", [m["Core/Axis/Axis.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.addEvent,
            z = h.getMagnitude,
            F = h.normalizeTickInterval,
            L = h.timeUnits,
            K = function () {
          function f(f) {
            this.axis = f;
          }

          f.prototype.normalizeTimeTickInterval = function (f, e) {
            var h = e || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
            e = h[h.length - 1];
            var v = L[e[0]],
                x = e[1],
                D;

            for (D = 0; D < h.length && !(e = h[D], v = L[e[0]], x = e[1], h[D + 1] && f <= (v * x[x.length - 1] + L[h[D + 1][0]]) / 2); D++);

            v === L.year && f < 5 * v && (x = [1, 2, 5]);
            f = F(f / v, x, "year" === e[0] ? Math.max(z(f / v), 1) : 1);
            return {
              unitRange: v,
              count: f,
              unitName: e[0]
            };
          };

          return f;
        }();

        h = function () {
          function f() {}

          f.compose = function (f) {
            f.keepProps.push("dateTime");

            f.prototype.getTimeTicks = function () {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            };

            m(f, "init", function (e) {
              "datetime" !== e.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new K(this));
            });
          };

          f.AdditionsClass = K;
          return f;
        }();

        h.compose(f);
        return h;
      });
      N(m, "Core/Axis/LogarithmicAxis.js", [m["Core/Axis/Axis.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.addEvent,
            z = h.getMagnitude,
            F = h.normalizeTickInterval,
            L = h.pick,
            K = function () {
          function f(f) {
            this.axis = f;
          }

          f.prototype.getLogTickPositions = function (f, e, h, v) {
            var x = this.axis,
                D = x.len,
                n = x.options,
                l = [];
            v || (this.minorAutoInterval = void 0);
            if (.5 <= f) f = Math.round(f), l = x.getLinearTickPositions(f, e, h);else if (.08 <= f) {
              n = Math.floor(e);
              var m, w;

              for (D = .3 < f ? [1, 2, 4] : .15 < f ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; n < h + 1 && !w; n++) {
                var r = D.length;

                for (m = 0; m < r && !w; m++) {
                  var d = this.log2lin(this.lin2log(n) * D[m]);
                  d > e && (!v || g <= h) && "undefined" !== typeof g && l.push(g);
                  g > h && (w = !0);
                  var g = d;
                }
              }
            } else e = this.lin2log(e), h = this.lin2log(h), f = v ? x.getMinorTickInterval() : n.tickInterval, f = L("auto" === f ? null : f, this.minorAutoInterval, n.tickPixelInterval / (v ? 5 : 1) * (h - e) / ((v ? D / x.tickPositions.length : D) || 1)), f = F(f, void 0, z(f)), l = x.getLinearTickPositions(f, e, h).map(this.log2lin), v || (this.minorAutoInterval = f / 5);
            v || (x.tickInterval = f);
            return l;
          };

          f.prototype.lin2log = function (f) {
            return Math.pow(10, f);
          };

          f.prototype.log2lin = function (f) {
            return Math.log(f) / Math.LN10;
          };

          return f;
        }();

        h = function () {
          function f() {}

          f.compose = function (f) {
            f.keepProps.push("logarithmic");
            var e = f.prototype,
                h = K.prototype;
            e.log2lin = h.log2lin;
            e.lin2log = h.lin2log;
            m(f, "init", function (e) {
              var f = this.logarithmic;
              "logarithmic" !== e.userOptions.type ? this.logarithmic = void 0 : (f || (f = this.logarithmic = new K(this)), this.log2lin !== f.log2lin && (f.log2lin = this.log2lin.bind(this)), this.lin2log !== f.lin2log && (f.lin2log = this.lin2log.bind(this)));
            });
            m(f, "afterInit", function () {
              var e = this.logarithmic;
              e && (this.lin2val = function (f) {
                return e.lin2log(f);
              }, this.val2lin = function (f) {
                return e.log2lin(f);
              });
            });
          };

          return f;
        }();

        h.compose(f);
        return h;
      });
      N(m, "Core/Axis/PlotLineOrBand.js", [m["Core/Axis/Axis.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m) {
        var z = m.arrayMax,
            F = m.arrayMin,
            P = m.defined,
            K = m.destroyObjectProperties,
            C = m.erase,
            y = m.extend,
            e = m.merge,
            I = m.objectEach,
            v = m.pick;

        m = function () {
          function f(e, f) {
            this.axis = e;
            f && (this.options = f, this.id = f.id);
          }

          f.prototype.render = function () {
            h.fireEvent(this, "render");
            var f = this,
                n = f.axis,
                l = n.horiz,
                m = n.logarithmic,
                w = f.options,
                r = w.label,
                d = f.label,
                g = w.to,
                c = w.from,
                a = w.value,
                q = P(c) && P(g),
                p = P(a),
                B = f.svgElem,
                A = !B,
                G = [],
                M = w.color,
                x = v(w.zIndex, 0),
                Q = w.events;
            G = {
              "class": "highcharts-plot-" + (q ? "band " : "line ") + (w.className || "")
            };
            var O = {},
                E = n.chart.renderer,
                u = q ? "bands" : "lines";
            m && (c = m.log2lin(c), g = m.log2lin(g), a = m.log2lin(a));
            n.chart.styledMode || (p ? (G.stroke = M || "#999999", G["stroke-width"] = v(w.width, 1), w.dashStyle && (G.dashstyle = w.dashStyle)) : q && (G.fill = M || "#e6ebf5", w.borderWidth && (G.stroke = w.borderColor, G["stroke-width"] = w.borderWidth)));
            O.zIndex = x;
            u += "-" + x;
            (m = n.plotLinesAndBandsGroups[u]) || (n.plotLinesAndBandsGroups[u] = m = E.g("plot-" + u).attr(O).add());
            A && (f.svgElem = B = E.path().attr(G).add(m));
            if (p) G = n.getPlotLinePath({
              value: a,
              lineWidth: B.strokeWidth(),
              acrossPanes: w.acrossPanes
            });else if (q) G = n.getPlotBandPath(c, g, w);else return;
            !f.eventsAdded && Q && (I(Q, function (b, a) {
              B.on(a, function (b) {
                Q[a].apply(f, [b]);
              });
            }), f.eventsAdded = !0);
            (A || !B.d) && G && G.length ? B.attr({
              d: G
            }) : B && (G ? (B.show(!0), B.animate({
              d: G
            })) : B.d && (B.hide(), d && (f.label = d = d.destroy())));
            r && (P(r.text) || P(r.formatter)) && G && G.length && 0 < n.width && 0 < n.height && !G.isFlat ? (r = e({
              align: l && q && "center",
              x: l ? !q && 4 : 10,
              verticalAlign: !l && q && "middle",
              y: l ? q ? 16 : 10 : q ? 6 : -4,
              rotation: l && !q && 90
            }, r), this.renderLabel(r, G, q, x)) : d && d.hide();
            return f;
          };

          f.prototype.renderLabel = function (e, f, l, h) {
            var n = this.label,
                r = this.axis.chart.renderer;
            n || (n = {
              align: e.textAlign || e.align,
              rotation: e.rotation,
              "class": "highcharts-plot-" + (l ? "band" : "line") + "-label " + (e.className || "")
            }, n.zIndex = h, h = this.getLabelText(e), this.label = n = r.text(h, 0, 0, e.useHTML).attr(n).add(), this.axis.chart.styledMode || n.css(e.style));
            r = f.xBounds || [f[0][1], f[1][1], l ? f[2][1] : f[0][1]];
            f = f.yBounds || [f[0][2], f[1][2], l ? f[2][2] : f[0][2]];
            l = F(r);
            h = F(f);
            n.align(e, !1, {
              x: l,
              y: h,
              width: z(r) - l,
              height: z(f) - h
            });
            n.show(!0);
          };

          f.prototype.getLabelText = function (e) {
            return P(e.formatter) ? e.formatter.call(this) : e.text;
          };

          f.prototype.destroy = function () {
            C(this.axis.plotLinesAndBands, this);
            delete this.axis;
            K(this);
          };

          return f;
        }();

        y(f.prototype, {
          getPlotBandPath: function getPlotBandPath(e, f, n) {
            void 0 === n && (n = this.options);
            var l = this.getPlotLinePath({
              value: f,
              force: !0,
              acrossPanes: n.acrossPanes
            });
            n = this.getPlotLinePath({
              value: e,
              force: !0,
              acrossPanes: n.acrossPanes
            });
            var h = [],
                w = this.horiz,
                r = 1;
            e = e < this.min && f < this.min || e > this.max && f > this.max;

            if (n && l) {
              if (e) {
                var d = n.toString() === l.toString();
                r = 0;
              }

              for (e = 0; e < n.length; e += 2) {
                f = n[e];
                var g = n[e + 1],
                    c = l[e],
                    a = l[e + 1];
                "M" !== f[0] && "L" !== f[0] || "M" !== g[0] && "L" !== g[0] || "M" !== c[0] && "L" !== c[0] || "M" !== a[0] && "L" !== a[0] || (w && c[1] === f[1] ? (c[1] += r, a[1] += r) : w || c[2] !== f[2] || (c[2] += r, a[2] += r), h.push(["M", f[1], f[2]], ["L", g[1], g[2]], ["L", a[1], a[2]], ["L", c[1], c[2]], ["Z"]));
                h.isFlat = d;
              }
            }

            return h;
          },
          addPlotBand: function addPlotBand(e) {
            return this.addPlotBandOrLine(e, "plotBands");
          },
          addPlotLine: function addPlotLine(e) {
            return this.addPlotBandOrLine(e, "plotLines");
          },
          addPlotBandOrLine: function addPlotBandOrLine(e, f) {
            var n = new h.PlotLineOrBand(this, e),
                l = this.userOptions;
            this.visible && (n = n.render());

            if (n) {
              if (f) {
                var v = l[f] || [];
                v.push(e);
                l[f] = v;
              }

              this.plotLinesAndBands.push(n);
              this._addedPlotLB = !0;
            }

            return n;
          },
          removePlotBandOrLine: function removePlotBandOrLine(e) {
            for (var f = this.plotLinesAndBands, n = this.options, l = this.userOptions, h = f.length; h--;) f[h].id === e && f[h].destroy();

            [n.plotLines || [], l.plotLines || [], n.plotBands || [], l.plotBands || []].forEach(function (f) {
              for (h = f.length; h--;) (f[h] || {}).id === e && C(f, f[h]);
            });
          },
          removePlotBand: function removePlotBand(e) {
            this.removePlotBandOrLine(e);
          },
          removePlotLine: function removePlotLine(e) {
            this.removePlotBandOrLine(e);
          }
        });
        h.PlotLineOrBand = m;
        return h.PlotLineOrBand;
      });
      N(m, "Core/Tooltip.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = f.doc,
            z = h.clamp,
            F = h.css,
            L = h.defined,
            K = h.discardElement,
            C = h.extend,
            y = h.fireEvent,
            e = h.format,
            I = h.isNumber,
            v = h.isString,
            x = h.merge,
            D = h.pick,
            n = h.splat,
            l = h.syncTimeout,
            J = h.timeUnits;
        "";

        var w = function () {
          function r(d, g) {
            this.container = void 0;
            this.crosshairs = [];
            this.distance = 0;
            this.isHidden = !0;
            this.isSticky = !1;
            this.now = {};
            this.options = {};
            this.outside = !1;
            this.chart = d;
            this.init(d, g);
          }

          r.prototype.applyFilter = function () {
            var d = this.chart;
            d.renderer.definition({
              tagName: "filter",
              id: "drop-shadow-" + d.index,
              opacity: .5,
              children: [{
                tagName: "feGaussianBlur",
                "in": "SourceAlpha",
                stdDeviation: 1
              }, {
                tagName: "feOffset",
                dx: 1,
                dy: 1
              }, {
                tagName: "feComponentTransfer",
                children: [{
                  tagName: "feFuncA",
                  type: "linear",
                  slope: .3
                }]
              }, {
                tagName: "feMerge",
                children: [{
                  tagName: "feMergeNode"
                }, {
                  tagName: "feMergeNode",
                  "in": "SourceGraphic"
                }]
              }]
            });
            d.renderer.definition({
              tagName: "style",
              textContent: ".highcharts-tooltip-" + d.index + "{filter:url(#drop-shadow-" + d.index + ")}"
            });
          };

          r.prototype.bodyFormatter = function (d) {
            return d.map(function (d) {
              var c = d.series.tooltipOptions;
              return (c[(d.point.formatPrefix || "point") + "Formatter"] || d.point.tooltipFormatter).call(d.point, c[(d.point.formatPrefix || "point") + "Format"] || "");
            });
          };

          r.prototype.cleanSplit = function (d) {
            this.chart.series.forEach(function (g) {
              var c = g && g.tt;
              c && (!c.isActive || d ? g.tt = c.destroy() : c.isActive = !1);
            });
          };

          r.prototype.defaultFormatter = function (d) {
            var g = this.points || n(this);
            var c = [d.tooltipFooterHeaderFormatter(g[0])];
            c = c.concat(d.bodyFormatter(g));
            c.push(d.tooltipFooterHeaderFormatter(g[0], !0));
            return c;
          };

          r.prototype.destroy = function () {
            this.label && (this.label = this.label.destroy());
            this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());
            this.renderer && (this.renderer = this.renderer.destroy(), K(this.container));
            h.clearTimeout(this.hideTimer);
            h.clearTimeout(this.tooltipTimeout);
          };

          r.prototype.getAnchor = function (d, g) {
            var c = this.chart,
                a = c.pointer,
                q = c.inverted,
                p = c.plotTop,
                e = c.plotLeft,
                f = 0,
                l = 0,
                r,
                h;
            d = n(d);
            this.followPointer && g ? ("undefined" === typeof g.chartX && (g = a.normalize(g)), d = [g.chartX - e, g.chartY - p]) : d[0].tooltipPos ? d = d[0].tooltipPos : (d.forEach(function (a) {
              r = a.series.yAxis;
              h = a.series.xAxis;
              f += a.plotX + (!q && h ? h.left - e : 0);
              l += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!q && r ? r.top - p : 0);
            }), f /= d.length, l /= d.length, d = [q ? c.plotWidth - l : f, this.shared && !q && 1 < d.length && g ? g.chartY - p : q ? c.plotHeight - f : l]);
            return d.map(Math.round);
          };

          r.prototype.getDateFormat = function (d, g, c, a) {
            var q = this.chart.time,
                p = q.dateFormat("%m-%d %H:%M:%S.%L", g),
                e = {
              millisecond: 15,
              second: 12,
              minute: 9,
              hour: 6,
              day: 3
            },
                f = "millisecond";

            for (l in J) {
              if (d === J.week && +q.dateFormat("%w", g) === c && "00:00:00.000" === p.substr(6)) {
                var l = "week";
                break;
              }

              if (J[l] > d) {
                l = f;
                break;
              }

              if (e[l] && p.substr(e[l]) !== "01-01 00:00:00.000".substr(e[l])) break;
              "week" !== l && (f = l);
            }

            if (l) var r = q.resolveDTLFormat(a[l]).main;
            return r;
          };

          r.prototype.getLabel = function () {
            var d,
                g,
                c = this,
                a = this.chart.renderer,
                q = this.chart.styledMode,
                p = this.options,
                e = "tooltip" + (L(p.className) ? " " + p.className : ""),
                l = (null === (d = p.style) || void 0 === d ? void 0 : d.pointerEvents) || (!this.followPointer && p.stickOnContact ? "auto" : "none"),
                r;

            d = function d() {
              c.inContact = !0;
            };

            var n = function n() {
              var a = c.chart.hoverSeries;
              c.inContact = !1;
              if (a && a.onMouseOut) a.onMouseOut();
            };

            if (!this.label) {
              this.outside && (this.container = r = f.doc.createElement("div"), r.className = "highcharts-tooltip-container", F(r, {
                position: "absolute",
                top: "1px",
                pointerEvents: l,
                zIndex: 3
              }), f.doc.body.appendChild(r), this.renderer = a = new f.Renderer(r, 0, 0, null === (g = this.chart.options.chart) || void 0 === g ? void 0 : g.style, void 0, void 0, a.styledMode));
              this.split ? this.label = a.g(e) : (this.label = a.label("", 0, 0, p.shape || "callout", null, null, p.useHTML, null, e).attr({
                padding: p.padding,
                r: p.borderRadius
              }), q || this.label.attr({
                fill: p.backgroundColor,
                "stroke-width": p.borderWidth
              }).css(p.style).css({
                pointerEvents: l
              }).shadow(p.shadow));
              q && (this.applyFilter(), this.label.addClass("highcharts-tooltip-" + this.chart.index));

              if (c.outside && !c.split) {
                var h = this.label,
                    w = h.xSetter,
                    v = h.ySetter;

                h.xSetter = function (a) {
                  w.call(h, c.distance);
                  r.style.left = a + "px";
                };

                h.ySetter = function (a) {
                  v.call(h, c.distance);
                  r.style.top = a + "px";
                };
              }

              this.label.on("mouseenter", d).on("mouseleave", n).attr({
                zIndex: 8
              }).add();
            }

            return this.label;
          };

          r.prototype.getPosition = function (d, g, c) {
            var a = this.chart,
                q = this.distance,
                p = {},
                e = a.inverted && c.h || 0,
                f,
                l = this.outside,
                r = l ? m.documentElement.clientWidth - 2 * q : a.chartWidth,
                n = l ? Math.max(m.body.scrollHeight, m.documentElement.scrollHeight, m.body.offsetHeight, m.documentElement.offsetHeight, m.documentElement.clientHeight) : a.chartHeight,
                h = a.pointer.getChartPosition(),
                w = a.containerScaling,
                E = function E(b) {
              return w ? b * w.scaleX : b;
            },
                u = function u(b) {
              return w ? b * w.scaleY : b;
            },
                b = function b(_b2) {
              var k = "x" === _b2;
              return [_b2, k ? r : n, k ? d : g].concat(l ? [k ? E(d) : u(g), k ? h.left - q + E(c.plotX + a.plotLeft) : h.top - q + u(c.plotY + a.plotTop), 0, k ? r : n] : [k ? d : g, k ? c.plotX + a.plotLeft : c.plotY + a.plotTop, k ? a.plotLeft : a.plotTop, k ? a.plotLeft + a.plotWidth : a.plotTop + a.plotHeight]);
            },
                k = b("y"),
                t = b("x"),
                H = !this.followPointer && D(c.ttBelow, !a.inverted === !!c.negative),
                v = function v(b, a, c, k, d, g, t) {
              var f = "y" === b ? u(q) : E(q),
                  l = (c - k) / 2,
                  r = k < d - q,
                  B = d + q + k < a,
                  n = d - f - c + l;
              d = d + f - l;
              if (H && B) p[b] = d;else if (!H && r) p[b] = n;else if (r) p[b] = Math.min(t - k, 0 > n - e ? n : n - e);else if (B) p[b] = Math.max(g, d + e + c > a ? d : d + e);else return !1;
            },
                U = function U(b, a, c, k, d) {
              var g;
              d < q || d > a - q ? g = !1 : p[b] = d < c / 2 ? 1 : d > a - k / 2 ? a - k - 2 : d - c / 2;
              return g;
            },
                x = function x(b) {
              var a = k;
              k = t;
              t = a;
              f = b;
            },
                I = function I() {
              !1 !== v.apply(0, k) ? !1 !== U.apply(0, t) || f || (x(!0), I()) : f ? p.x = p.y = 0 : (x(!0), I());
            };

            (a.inverted || 1 < this.len) && x();
            I();
            return p;
          };

          r.prototype.getXDateFormat = function (d, g, c) {
            g = g.dateTimeLabelFormats;
            var a = c && c.closestPointRange;
            return (a ? this.getDateFormat(a, d.x, c.options.startOfWeek, g) : g.day) || g.year;
          };

          r.prototype.hide = function (d) {
            var g = this;
            h.clearTimeout(this.hideTimer);
            d = D(d, this.options.hideDelay, 500);
            this.isHidden || (this.hideTimer = l(function () {
              g.getLabel().fadeOut(d ? void 0 : d);
              g.isHidden = !0;
            }, d));
          };

          r.prototype.init = function (d, g) {
            this.chart = d;
            this.options = g;
            this.crosshairs = [];
            this.now = {
              x: 0,
              y: 0
            };
            this.isHidden = !0;
            this.split = g.split && !d.inverted && !d.polar;
            this.shared = g.shared || this.split;
            this.outside = D(g.outside, !(!d.scrollablePixelsX && !d.scrollablePixelsY));
          };

          r.prototype.isStickyOnContact = function () {
            return !(this.followPointer || !this.options.stickOnContact || !this.inContact);
          };

          r.prototype.move = function (d, g, c, a) {
            var q = this,
                p = q.now,
                e = !1 !== q.options.animation && !q.isHidden && (1 < Math.abs(d - p.x) || 1 < Math.abs(g - p.y)),
                f = q.followPointer || 1 < q.len;
            C(p, {
              x: e ? (2 * p.x + d) / 3 : d,
              y: e ? (p.y + g) / 2 : g,
              anchorX: f ? void 0 : e ? (2 * p.anchorX + c) / 3 : c,
              anchorY: f ? void 0 : e ? (p.anchorY + a) / 2 : a
            });
            q.getLabel().attr(p);
            q.drawTracker();
            e && (h.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
              q && q.move(d, g, c, a);
            }, 32));
          };

          r.prototype.refresh = function (d, g) {
            var c = this.chart,
                a = this.options,
                q = d,
                p = {},
                e = [],
                f = a.formatter || this.defaultFormatter;
            p = this.shared;
            var l = c.styledMode;

            if (a.enabled) {
              h.clearTimeout(this.hideTimer);
              this.followPointer = n(q)[0].series.tooltipOptions.followPointer;
              var r = this.getAnchor(q, g);
              g = r[0];
              var w = r[1];
              !p || q.series && q.series.noSharedTooltip ? p = q.getLabelConfig() : (c.pointer.applyInactiveState(q), q.forEach(function (a) {
                a.setState("hover");
                e.push(a.getLabelConfig());
              }), p = {
                x: q[0].category,
                y: q[0].y
              }, p.points = e, q = q[0]);
              this.len = e.length;
              c = f.call(p, this);
              f = q.series;
              this.distance = D(f.tooltipOptions.distance, 16);
              !1 === c ? this.hide() : (this.split ? this.renderSplit(c, n(d)) : (d = this.getLabel(), a.style.width && !l || d.css({
                width: this.chart.spacingBox.width + "px"
              }), d.attr({
                text: c && c.join ? c.join("") : c
              }), d.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + D(q.colorIndex, f.colorIndex)), l || d.attr({
                stroke: a.borderColor || q.color || f.color || "#666666"
              }), this.updatePosition({
                plotX: g,
                plotY: w,
                negative: q.negative,
                ttBelow: q.ttBelow,
                h: r[2] || 0
              })), this.isHidden && this.label && this.label.attr({
                opacity: 1
              }).show(), this.isHidden = !1);
              y(this, "refresh");
            }
          };

          r.prototype.renderSplit = function (d, g) {
            function c(b, a, c, d, g) {
              void 0 === g && (g = !0);
              c ? (a = I ? 0 : F, b = z(b - d / 2, m.left, m.right - d)) : (a -= y, b = g ? b - d - k : b + k, b = z(b, g ? b : m.left, m.right));
              return {
                x: b,
                y: a
              };
            }

            var a = this,
                q = a.chart,
                p = a.chart,
                e = p.plotHeight,
                l = p.plotLeft,
                r = p.plotTop,
                n = p.pointer,
                h = p.renderer,
                w = p.scrollablePixelsY,
                O = void 0 === w ? 0 : w;
            w = p.scrollingContainer;
            w = void 0 === w ? {
              scrollLeft: 0,
              scrollTop: 0
            } : w;
            var E = w.scrollLeft,
                u = w.scrollTop,
                b = p.styledMode,
                k = a.distance,
                t = a.options,
                H = a.options.positioner,
                m = {
              left: E,
              right: E + p.chartWidth,
              top: u,
              bottom: u + p.chartHeight
            },
                x = a.getLabel(),
                I = !(!q.xAxis[0] || !q.xAxis[0].opposite),
                y = r + u,
                J = 0,
                F = e - O;
            v(d) && (d = [!1, d]);
            d = d.slice(0, g.length + 1).reduce(function (d, p, q) {
              if (!1 !== p && "" !== p) {
                q = g[q - 1] || {
                  isHeader: !0,
                  plotX: g[0].plotX,
                  plotY: e,
                  series: {}
                };
                var f = q.isHeader,
                    n = f ? a : q.series,
                    B = n.tt,
                    A = q.isHeader;
                var w = q.series;
                var E = "highcharts-color-" + D(q.colorIndex, w.colorIndex, "none");
                B || (B = {
                  padding: t.padding,
                  r: t.borderRadius
                }, b || (B.fill = t.backgroundColor, B["stroke-width"] = t.borderWidth), B = h.label("", 0, 0, t[A ? "headerShape" : "shape"] || "callout", void 0, void 0, t.useHTML).addClass((A ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + E).attr(B).add(x));
                B.isActive = !0;
                B.attr({
                  text: p
                });
                b || B.css(t.style).shadow(t.shadow).attr({
                  stroke: t.borderColor || q.color || w.color || "#333333"
                });
                p = n.tt = B;
                A = p.getBBox();
                n = A.width + p.strokeWidth();
                f && (J = A.height, F += J, I && (y -= J));
                w = q.plotX;
                w = void 0 === w ? 0 : w;
                E = q.plotY;
                E = void 0 === E ? 0 : E;
                var v = q.series;

                if (q.isHeader) {
                  w = l + w;
                  var G = r + e / 2;
                } else B = v.xAxis, v = v.yAxis, w = B.pos + z(w, -k, B.len + k), v.pos + E >= u + r && v.pos + E <= u + r + e - O && (G = v.pos + E);

                w = z(w, m.left - k, m.right + k);
                "number" === typeof G ? (A = A.height + 1, E = H ? H.call(a, n, A, q) : c(w, G, f, n), d.push({
                  align: H ? 0 : void 0,
                  anchorX: w,
                  anchorY: G,
                  boxWidth: n,
                  point: q,
                  rank: D(E.rank, f ? 1 : 0),
                  size: A,
                  target: E.y,
                  tt: p,
                  x: E.x
                })) : p.isActive = !1;
              }

              return d;
            }, []);
            !H && d.some(function (b) {
              return b.x < m.left;
            }) && (d = d.map(function (b) {
              var a = c(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);
              return C(b, {
                target: a.y,
                x: a.x
              });
            }));
            a.cleanSplit();
            f.distribute(d, F);
            d.forEach(function (b) {
              var a = b.pos;
              b.tt.attr({
                visibility: "undefined" === typeof a ? "hidden" : "inherit",
                x: b.x,
                y: a + y,
                anchorX: b.anchorX,
                anchorY: b.anchorY
              });
            });
            d = a.container;
            q = a.renderer;
            a.outside && d && q && (p = x.getBBox(), q.setSize(p.width + p.x, p.height + p.y, !1), n = n.getChartPosition(), d.style.left = n.left + "px", d.style.top = n.top + "px");
          };

          r.prototype.drawTracker = function () {
            if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {
              var d = this.chart,
                  g = this.label,
                  c = d.hoverPoint;

              if (g && c) {
                var a = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                c = this.getAnchor(c);
                var q = g.getBBox();
                c[0] += d.plotLeft - g.translateX;
                c[1] += d.plotTop - g.translateY;
                a.x = Math.min(0, c[0]);
                a.y = Math.min(0, c[1]);
                a.width = 0 > c[0] ? Math.max(Math.abs(c[0]), q.width - c[0]) : Math.max(Math.abs(c[0]), q.width);
                a.height = 0 > c[1] ? Math.max(Math.abs(c[1]), q.height - Math.abs(c[1])) : Math.max(Math.abs(c[1]), q.height);
                this.tracker ? this.tracker.attr(a) : (this.tracker = g.renderer.rect(a).addClass("highcharts-tracker").add(g), d.styledMode || this.tracker.attr({
                  fill: "rgba(0,0,0,0)"
                }));
              }
            }
          };

          r.prototype.styledModeFormat = function (d) {
            return d.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
          };

          r.prototype.tooltipFooterHeaderFormatter = function (d, g) {
            var c = g ? "footer" : "header",
                a = d.series,
                q = a.tooltipOptions,
                p = q.xDateFormat,
                f = a.xAxis,
                l = f && "datetime" === f.options.type && I(d.key),
                r = q[c + "Format"];
            g = {
              isFooter: g,
              labelConfig: d
            };
            y(this, "headerFormatter", g, function (c) {
              l && !p && (p = this.getXDateFormat(d, q, f));
              l && p && (d.point && d.point.tooltipDateKeys || ["key"]).forEach(function (a) {
                r = r.replace("{point." + a + "}", "{point." + a + ":" + p + "}");
              });
              a.chart.styledMode && (r = this.styledModeFormat(r));
              c.text = e(r, {
                point: d,
                series: a
              }, this.chart);
            });
            return g.text;
          };

          r.prototype.update = function (d) {
            this.destroy();
            x(!0, this.chart.options.tooltip.userOptions, d);
            this.init(this.chart, x(!0, this.options, d));
          };

          r.prototype.updatePosition = function (d) {
            var g = this.chart,
                c = g.pointer,
                a = this.getLabel(),
                q = d.plotX + g.plotLeft,
                p = d.plotY + g.plotTop;
            c = c.getChartPosition();
            d = (this.options.positioner || this.getPosition).call(this, a.width, a.height, d);

            if (this.outside) {
              var e = (this.options.borderWidth || 0) + 2 * this.distance;
              this.renderer.setSize(a.width + e, a.height + e, !1);
              if (g = g.containerScaling) F(this.container, {
                transform: "scale(" + g.scaleX + ", " + g.scaleY + ")"
              }), q *= g.scaleX, p *= g.scaleY;
              q += c.left - d.x;
              p += c.top - d.y;
            }

            this.move(Math.round(d.x), Math.round(d.y || 0), q, p);
          };

          return r;
        }();

        f.Tooltip = w;
        return f.Tooltip;
      });
      N(m, "Core/Pointer.js", [m["Core/Color/Color.js"], m["Core/Globals.js"], m["Core/Tooltip.js"], m["Core/Utilities.js"]], function (f, h, m, z) {
        var F = f.parse,
            P = h.charts,
            K = h.noop,
            C = z.addEvent,
            y = z.attr,
            e = z.css,
            I = z.defined,
            v = z.extend,
            x = z.find,
            D = z.fireEvent,
            n = z.isNumber,
            l = z.isObject,
            J = z.objectEach,
            w = z.offset,
            r = z.pick,
            d = z.splat;
        "";

        f = function () {
          function g(c, a) {
            this.lastValidTouch = {};
            this.pinchDown = [];
            this.runChartClick = !1;
            this.chart = c;
            this.hasDragged = !1;
            this.options = a;

            this.unbindContainerMouseLeave = function () {};

            this.unbindContainerMouseEnter = function () {};

            this.init(c, a);
          }

          g.prototype.applyInactiveState = function (c) {
            var a = [],
                d;
            (c || []).forEach(function (c) {
              d = c.series;
              a.push(d);
              d.linkedParent && a.push(d.linkedParent);
              d.linkedSeries && (a = a.concat(d.linkedSeries));
              d.navigatorSeries && a.push(d.navigatorSeries);
            });
            this.chart.series.forEach(function (c) {
              -1 === a.indexOf(c) ? c.setState("inactive", !0) : c.options.inactiveOtherPoints && c.setAllPointsToState("inactive");
            });
          };

          g.prototype.destroy = function () {
            var c = this;
            "undefined" !== typeof c.unDocMouseMove && c.unDocMouseMove();
            this.unbindContainerMouseLeave();
            h.chartCount || (h.unbindDocumentMouseUp && (h.unbindDocumentMouseUp = h.unbindDocumentMouseUp()), h.unbindDocumentTouchEnd && (h.unbindDocumentTouchEnd = h.unbindDocumentTouchEnd()));
            clearInterval(c.tooltipTimeout);
            J(c, function (a, d) {
              c[d] = void 0;
            });
          };

          g.prototype.drag = function (c) {
            var a = this.chart,
                d = a.options.chart,
                g = c.chartX,
                e = c.chartY,
                f = this.zoomHor,
                r = this.zoomVert,
                n = a.plotLeft,
                h = a.plotTop,
                w = a.plotWidth,
                v = a.plotHeight,
                E = this.selectionMarker,
                u = this.mouseDownX || 0,
                b = this.mouseDownY || 0,
                k = l(d.panning) ? d.panning && d.panning.enabled : d.panning,
                t = d.panKey && c[d.panKey + "Key"];
            if (!E || !E.touch) if (g < n ? g = n : g > n + w && (g = n + w), e < h ? e = h : e > h + v && (e = h + v), this.hasDragged = Math.sqrt(Math.pow(u - g, 2) + Math.pow(b - e, 2)), 10 < this.hasDragged) {
              var H = a.isInsidePlot(u - n, b - h);
              a.hasCartesianSeries && (this.zoomX || this.zoomY) && H && !t && !E && (this.selectionMarker = E = a.renderer.rect(n, h, f ? 1 : w, r ? 1 : v, 0).attr({
                "class": "highcharts-selection-marker",
                zIndex: 7
              }).add(), a.styledMode || E.attr({
                fill: d.selectionMarkerFill || F("#335cad").setOpacity(.25).get()
              }));
              E && f && (g -= u, E.attr({
                width: Math.abs(g),
                x: (0 < g ? 0 : g) + u
              }));
              E && r && (g = e - b, E.attr({
                height: Math.abs(g),
                y: (0 < g ? 0 : g) + b
              }));
              H && !E && k && a.pan(c, d.panning);
            }
          };

          g.prototype.dragStart = function (c) {
            var a = this.chart;
            a.mouseIsDown = c.type;
            a.cancelClick = !1;
            a.mouseDownX = this.mouseDownX = c.chartX;
            a.mouseDownY = this.mouseDownY = c.chartY;
          };

          g.prototype.drop = function (c) {
            var a = this,
                d = this.chart,
                g = this.hasPinched;

            if (this.selectionMarker) {
              var f = {
                originalEvent: c,
                xAxis: [],
                yAxis: []
              },
                  l = this.selectionMarker,
                  r = l.attr ? l.attr("x") : l.x,
                  h = l.attr ? l.attr("y") : l.y,
                  w = l.attr ? l.attr("width") : l.width,
                  m = l.attr ? l.attr("height") : l.height,
                  O;
              if (this.hasDragged || g) d.axes.forEach(function (d) {
                if (d.zoomEnabled && I(d.min) && (g || a[{
                  xAxis: "zoomX",
                  yAxis: "zoomY"
                }[d.coll]]) && n(r) && n(h)) {
                  var p = d.horiz,
                      b = "touchend" === c.type ? d.minPixelPadding : 0,
                      k = d.toValue((p ? r : h) + b);
                  p = d.toValue((p ? r + w : h + m) - b);
                  f[d.coll].push({
                    axis: d,
                    min: Math.min(k, p),
                    max: Math.max(k, p)
                  });
                  O = !0;
                }
              }), O && D(d, "selection", f, function (a) {
                d.zoom(v(a, g ? {
                  animation: !1
                } : null));
              });
              n(d.index) && (this.selectionMarker = this.selectionMarker.destroy());
              g && this.scaleGroups();
            }

            d && n(d.index) && (e(d.container, {
              cursor: d._cursor
            }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
          };

          g.prototype.findNearestKDPoint = function (c, a, d) {
            var g = this.chart,
                q = g.hoverPoint;
            g = g.tooltip;
            if (q && g && g.isStickyOnContact()) return q;
            var e;
            c.forEach(function (c) {
              var g = !(c.noSharedTooltip && a) && 0 > c.options.findNearestPointBy.indexOf("y");
              c = c.searchPoint(d, g);

              if ((g = l(c, !0)) && !(g = !l(e, !0))) {
                g = e.distX - c.distX;
                var p = e.dist - c.dist,
                    q = (c.series.group && c.series.group.zIndex) - (e.series.group && e.series.group.zIndex);
                g = 0 < (0 !== g && a ? g : 0 !== p ? p : 0 !== q ? q : e.series.index > c.series.index ? -1 : 1);
              }

              g && (e = c);
            });
            return e;
          };

          g.prototype.getChartCoordinatesFromPoint = function (c, a) {
            var d = c.series,
                g = d.xAxis;
            d = d.yAxis;
            var e = r(c.clientX, c.plotX),
                f = c.shapeArgs;
            if (g && d) return a ? {
              chartX: g.len + g.pos - e,
              chartY: d.len + d.pos - c.plotY
            } : {
              chartX: e + g.pos,
              chartY: c.plotY + d.pos
            };
            if (f && f.x && f.y) return {
              chartX: f.x,
              chartY: f.y
            };
          };

          g.prototype.getChartPosition = function () {
            return this.chartPosition || (this.chartPosition = w(this.chart.container));
          };

          g.prototype.getCoordinates = function (c) {
            var a = {
              xAxis: [],
              yAxis: []
            };
            this.chart.axes.forEach(function (d) {
              a[d.isXAxis ? "xAxis" : "yAxis"].push({
                axis: d,
                value: d.toValue(c[d.horiz ? "chartX" : "chartY"])
              });
            });
            return a;
          };

          g.prototype.getHoverData = function (c, a, d, g, e, f) {
            var p,
                q = [];
            g = !(!g || !c);
            var n = a && !a.stickyTracking,
                h = {
              chartX: f ? f.chartX : void 0,
              chartY: f ? f.chartY : void 0,
              shared: e
            };
            D(this, "beforeGetHoverData", h);
            n = n ? [a] : d.filter(function (a) {
              return h.filter ? h.filter(a) : a.visible && !(!e && a.directTouch) && r(a.options.enableMouseTracking, !0) && a.stickyTracking;
            });
            a = (p = g || !f ? c : this.findNearestKDPoint(n, e, f)) && p.series;
            p && (e && !a.noSharedTooltip ? (n = d.filter(function (a) {
              return h.filter ? h.filter(a) : a.visible && !(!e && a.directTouch) && r(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;
            }), n.forEach(function (a) {
              var c = x(a.points, function (a) {
                return a.x === p.x && !a.isNull;
              });
              l(c) && (a.chart.isBoosting && (c = a.getPoint(c)), q.push(c));
            })) : q.push(p));
            h = {
              hoverPoint: p
            };
            D(this, "afterGetHoverData", h);
            return {
              hoverPoint: h.hoverPoint,
              hoverSeries: a,
              hoverPoints: q
            };
          };

          g.prototype.getPointFromEvent = function (c) {
            c = c.target;

            for (var a; c && !a;) a = c.point, c = c.parentNode;

            return a;
          };

          g.prototype.onTrackerMouseOut = function (c) {
            c = c.relatedTarget || c.toElement;
            var a = this.chart.hoverSeries;
            this.isDirectTouch = !1;
            if (!(!a || !c || a.stickyTracking || this.inClass(c, "highcharts-tooltip") || this.inClass(c, "highcharts-series-" + a.index) && this.inClass(c, "highcharts-tracker"))) a.onMouseOut();
          };

          g.prototype.inClass = function (c, a) {
            for (var d; c;) {
              if (d = y(c, "class")) {
                if (-1 !== d.indexOf(a)) return !0;
                if (-1 !== d.indexOf("highcharts-container")) return !1;
              }

              c = c.parentNode;
            }
          };

          g.prototype.init = function (c, a) {
            this.options = a;
            this.chart = c;
            this.runChartClick = a.chart.events && !!a.chart.events.click;
            this.pinchDown = [];
            this.lastValidTouch = {};
            m && (c.tooltip = new m(c, a.tooltip), this.followTouchMove = r(a.tooltip.followTouchMove, !0));
            this.setDOMEvents();
          };

          g.prototype.normalize = function (c, a) {
            var d = c.touches,
                g = d ? d.length ? d.item(0) : r(d.changedTouches, c.changedTouches)[0] : c;
            a || (a = this.getChartPosition());
            d = g.pageX - a.left;
            a = g.pageY - a.top;
            if (g = this.chart.containerScaling) d /= g.scaleX, a /= g.scaleY;
            return v(c, {
              chartX: Math.round(d),
              chartY: Math.round(a)
            });
          };

          g.prototype.onContainerClick = function (c) {
            var a = this.chart,
                d = a.hoverPoint;
            c = this.normalize(c);
            var g = a.plotLeft,
                e = a.plotTop;
            a.cancelClick || (d && this.inClass(c.target, "highcharts-tracker") ? (D(d.series, "click", v(c, {
              point: d
            })), a.hoverPoint && d.firePointEvent("click", c)) : (v(c, this.getCoordinates(c)), a.isInsidePlot(c.chartX - g, c.chartY - e) && D(a, "click", c)));
          };

          g.prototype.onContainerMouseDown = function (c) {
            var a = 1 === ((c.buttons || c.button) & 1);
            c = this.normalize(c);
            if (h.isFirefox && 0 !== c.button) this.onContainerMouseMove(c);
            if ("undefined" === typeof c.button || a) this.zoomOption(c), a && c.preventDefault && c.preventDefault(), this.dragStart(c);
          };

          g.prototype.onContainerMouseLeave = function (c) {
            var a = P[r(h.hoverChartIndex, -1)],
                d = this.chart.tooltip;
            c = this.normalize(c);
            a && (c.relatedTarget || c.toElement) && (a.pointer.reset(), a.pointer.chartPosition = void 0);
            d && !d.isHidden && this.reset();
          };

          g.prototype.onContainerMouseEnter = function (c) {
            delete this.chartPosition;
          };

          g.prototype.onContainerMouseMove = function (c) {
            var a = this.chart;
            c = this.normalize(c);
            this.setHoverChartIndex();
            c.preventDefault || (c.returnValue = !1);
            "mousedown" === a.mouseIsDown && this.drag(c);
            a.openMenu || !this.inClass(c.target, "highcharts-tracker") && !a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.runPointActions(c);
          };

          g.prototype.onDocumentTouchEnd = function (c) {
            P[h.hoverChartIndex] && P[h.hoverChartIndex].pointer.drop(c);
          };

          g.prototype.onContainerTouchMove = function (c) {
            this.touch(c);
          };

          g.prototype.onContainerTouchStart = function (c) {
            this.zoomOption(c);
            this.touch(c, !0);
          };

          g.prototype.onDocumentMouseMove = function (c) {
            var a = this.chart,
                d = this.chartPosition;
            c = this.normalize(c, d);
            var g = a.tooltip;
            !d || g && g.isStickyOnContact() || a.isInsidePlot(c.chartX - a.plotLeft, c.chartY - a.plotTop) || this.inClass(c.target, "highcharts-tracker") || this.reset();
          };

          g.prototype.onDocumentMouseUp = function (c) {
            var a = P[r(h.hoverChartIndex, -1)];
            a && a.pointer.drop(c);
          };

          g.prototype.pinch = function (c) {
            var a = this,
                d = a.chart,
                g = a.pinchDown,
                e = c.touches || [],
                f = e.length,
                l = a.lastValidTouch,
                n = a.hasZoom,
                h = a.selectionMarker,
                w = {},
                m = 1 === f && (a.inClass(c.target, "highcharts-tracker") && d.runTrackerClick || a.runChartClick),
                E = {};
            1 < f && (a.initiated = !0);
            n && a.initiated && !m && !1 !== c.cancelable && c.preventDefault();
            [].map.call(e, function (c) {
              return a.normalize(c);
            });
            "touchstart" === c.type ? ([].forEach.call(e, function (a, b) {
              g[b] = {
                chartX: a.chartX,
                chartY: a.chartY
              };
            }), l.x = [g[0].chartX, g[1] && g[1].chartX], l.y = [g[0].chartY, g[1] && g[1].chartY], d.axes.forEach(function (a) {
              if (a.zoomEnabled) {
                var b = d.bounds[a.horiz ? "h" : "v"],
                    c = a.minPixelPadding,
                    g = a.toPixels(Math.min(r(a.options.min, a.dataMin), a.dataMin)),
                    p = a.toPixels(Math.max(r(a.options.max, a.dataMax), a.dataMax)),
                    q = Math.max(g, p);
                b.min = Math.min(a.pos, Math.min(g, p) - c);
                b.max = Math.max(a.pos + a.len, q + c);
              }
            }), a.res = !0) : a.followTouchMove && 1 === f ? this.runPointActions(a.normalize(c)) : g.length && (h || (a.selectionMarker = h = v({
              destroy: K,
              touch: !0
            }, d.plotBox)), a.pinchTranslate(g, e, w, h, E, l), a.hasPinched = n, a.scaleGroups(w, E), a.res && (a.res = !1, this.reset(!1, 0)));
          };

          g.prototype.pinchTranslate = function (c, a, d, g, e, f) {
            this.zoomHor && this.pinchTranslateDirection(!0, c, a, d, g, e, f);
            this.zoomVert && this.pinchTranslateDirection(!1, c, a, d, g, e, f);
          };

          g.prototype.pinchTranslateDirection = function (c, a, d, g, e, f, l, r) {
            var p = this.chart,
                q = c ? "x" : "y",
                n = c ? "X" : "Y",
                h = "chart" + n,
                u = c ? "width" : "height",
                b = p["plot" + (c ? "Left" : "Top")],
                k,
                t,
                B = r || 1,
                w = p.inverted,
                A = p.bounds[c ? "h" : "v"],
                v = 1 === a.length,
                G = a[0][h],
                m = d[0][h],
                D = !v && a[1][h],
                M = !v && d[1][h];

            d = function d() {
              "number" === typeof M && 20 < Math.abs(G - D) && (B = r || Math.abs(m - M) / Math.abs(G - D));
              t = (b - m) / B + G;
              k = p["plot" + (c ? "Width" : "Height")] / B;
            };

            d();
            a = t;

            if (a < A.min) {
              a = A.min;
              var x = !0;
            } else a + k > A.max && (a = A.max - k, x = !0);

            x ? (m -= .8 * (m - l[q][0]), "number" === typeof M && (M -= .8 * (M - l[q][1])), d()) : l[q] = [m, M];
            w || (f[q] = t - b, f[u] = k);
            f = w ? 1 / B : B;
            e[u] = k;
            e[q] = a;
            g[w ? c ? "scaleY" : "scaleX" : "scale" + n] = B;
            g["translate" + n] = f * b + (m - f * G);
          };

          g.prototype.reset = function (c, a) {
            var g = this.chart,
                p = g.hoverSeries,
                e = g.hoverPoint,
                f = g.hoverPoints,
                l = g.tooltip,
                r = l && l.shared ? f : e;
            c && r && d(r).forEach(function (a) {
              a.series.isCartesian && "undefined" === typeof a.plotX && (c = !1);
            });
            if (c) l && r && d(r).length && (l.refresh(r), l.shared && f ? f.forEach(function (a) {
              a.setState(a.state, !0);
              a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));
            }) : e && (e.setState(e.state, !0), g.axes.forEach(function (a) {
              a.crosshair && e.series[a.coll] === a && a.drawCrosshair(null, e);
            })));else {
              if (e) e.onMouseOut();
              f && f.forEach(function (a) {
                a.setState();
              });
              if (p) p.onMouseOut();
              l && l.hide(a);
              this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
              g.axes.forEach(function (a) {
                a.hideCrosshair();
              });
              this.hoverX = g.hoverPoints = g.hoverPoint = null;
            }
          };

          g.prototype.runPointActions = function (c, a) {
            var d = this.chart,
                g = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,
                e = g ? g.shared : !1,
                f = a || d.hoverPoint,
                l = f && f.series || d.hoverSeries;
            l = this.getHoverData(f, l, d.series, (!c || "touchmove" !== c.type) && (!!a || l && l.directTouch && this.isDirectTouch), e, c);
            f = l.hoverPoint;
            var n = l.hoverPoints;
            a = (l = l.hoverSeries) && l.tooltipOptions.followPointer;
            e = e && l && !l.noSharedTooltip;

            if (f && (f !== d.hoverPoint || g && g.isHidden)) {
              (d.hoverPoints || []).forEach(function (a) {
                -1 === n.indexOf(a) && a.setState();
              });
              if (d.hoverSeries !== l) l.onMouseOver();
              this.applyInactiveState(n);
              (n || []).forEach(function (a) {
                a.setState("hover");
              });
              d.hoverPoint && d.hoverPoint.firePointEvent("mouseOut");
              if (!f.series) return;
              d.hoverPoints = n;
              d.hoverPoint = f;
              f.firePointEvent("mouseOver");
              g && g.refresh(e ? n : f, c);
            } else a && g && !g.isHidden && (f = g.getAnchor([{}], c), g.updatePosition({
              plotX: f[0],
              plotY: f[1]
            }));

            this.unDocMouseMove || (this.unDocMouseMove = C(d.container.ownerDocument, "mousemove", function (a) {
              var c = P[h.hoverChartIndex];
              if (c) c.pointer.onDocumentMouseMove(a);
            }));
            d.axes.forEach(function (a) {
              var g = r((a.crosshair || {}).snap, !0),
                  p;
              g && ((p = d.hoverPoint) && p.series[a.coll] === a || (p = x(n, function (c) {
                return c.series[a.coll] === a;
              })));
              p || !g ? a.drawCrosshair(c, p) : a.hideCrosshair();
            });
          };

          g.prototype.scaleGroups = function (c, a) {
            var d = this.chart,
                g;
            d.series.forEach(function (p) {
              g = c || p.getPlotBox();
              p.xAxis && p.xAxis.zoomEnabled && p.group && (p.group.attr(g), p.markerGroup && (p.markerGroup.attr(g), p.markerGroup.clip(a ? d.clipRect : null)), p.dataLabelsGroup && p.dataLabelsGroup.attr(g));
            });
            d.clipRect.attr(a || d.clipBox);
          };

          g.prototype.setDOMEvents = function () {
            var c = this.chart.container,
                a = c.ownerDocument;
            c.onmousedown = this.onContainerMouseDown.bind(this);
            c.onmousemove = this.onContainerMouseMove.bind(this);
            c.onclick = this.onContainerClick.bind(this);
            this.unbindContainerMouseEnter = C(c, "mouseenter", this.onContainerMouseEnter.bind(this));
            this.unbindContainerMouseLeave = C(c, "mouseleave", this.onContainerMouseLeave.bind(this));
            h.unbindDocumentMouseUp || (h.unbindDocumentMouseUp = C(a, "mouseup", this.onDocumentMouseUp.bind(this)));
            h.hasTouch && (C(c, "touchstart", this.onContainerTouchStart.bind(this)), C(c, "touchmove", this.onContainerTouchMove.bind(this)), h.unbindDocumentTouchEnd || (h.unbindDocumentTouchEnd = C(a, "touchend", this.onDocumentTouchEnd.bind(this))));
          };

          g.prototype.setHoverChartIndex = function () {
            var c = this.chart,
                a = h.charts[r(h.hoverChartIndex, -1)];
            if (a && a !== c) a.pointer.onContainerMouseLeave({
              relatedTarget: !0
            });
            a && a.mouseIsDown || (h.hoverChartIndex = c.index);
          };

          g.prototype.touch = function (c, a) {
            var d = this.chart,
                g;
            this.setHoverChartIndex();
            if (1 === c.touches.length) {
              if (c = this.normalize(c), (g = d.isInsidePlot(c.chartX - d.plotLeft, c.chartY - d.plotTop)) && !d.openMenu) {
                a && this.runPointActions(c);

                if ("touchmove" === c.type) {
                  a = this.pinchDown;
                  var e = a[0] ? 4 <= Math.sqrt(Math.pow(a[0].chartX - c.chartX, 2) + Math.pow(a[0].chartY - c.chartY, 2)) : !1;
                }

                r(e, !0) && this.pinch(c);
              } else a && this.reset();
            } else 2 === c.touches.length && this.pinch(c);
          };

          g.prototype.zoomOption = function (c) {
            var a = this.chart,
                d = a.options.chart,
                g = d.zoomType || "";
            a = a.inverted;
            /touch/.test(c.type) && (g = r(d.pinchType, g));
            this.zoomX = c = /x/.test(g);
            this.zoomY = g = /y/.test(g);
            this.zoomHor = c && !a || g && a;
            this.zoomVert = g && !a || c && a;
            this.hasZoom = c || g;
          };

          return g;
        }();

        return h.Pointer = f;
      });
      N(m, "Core/MSPointer.js", [m["Core/Globals.js"], m["Core/Pointer.js"], m["Core/Utilities.js"]], function (f, h, m) {
        function z() {
          var e = [];

          e.item = function (e) {
            return this[e];
          };

          v(D, function (f) {
            e.push({
              pageX: f.pageX,
              pageY: f.pageY,
              target: f.target
            });
          });
          return e;
        }

        function F(e, n, h, r) {
          "touch" !== e.pointerType && e.pointerType !== e.MSPOINTER_TYPE_TOUCH || !K[f.hoverChartIndex] || (r(e), r = K[f.hoverChartIndex].pointer, r[n]({
            type: h,
            target: e.currentTarget,
            preventDefault: y,
            touches: z()
          }));
        }

        var P = this && this.__extends || function () {
          var _e = function e(f, l) {
            _e = Object.setPrototypeOf || {
              __proto__: []
            } instanceof Array && function (e, d) {
              e.__proto__ = d;
            } || function (e, d) {
              for (var g in d) d.hasOwnProperty(g) && (e[g] = d[g]);
            };

            return _e(f, l);
          };

          return function (f, l) {
            function r() {
              this.constructor = f;
            }

            _e(f, l);

            f.prototype = null === l ? Object.create(l) : (r.prototype = l.prototype, new r());
          };
        }(),
            K = f.charts,
            C = f.doc,
            y = f.noop,
            e = m.addEvent,
            I = m.css,
            v = m.objectEach,
            x = m.removeEvent,
            D = {},
            n = !!f.win.PointerEvent;

        return function (f) {
          function l() {
            return null !== f && f.apply(this, arguments) || this;
          }

          P(l, f);

          l.prototype.batchMSEvents = function (e) {
            e(this.chart.container, n ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
            e(this.chart.container, n ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
            e(C, n ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
          };

          l.prototype.destroy = function () {
            this.batchMSEvents(x);
            f.prototype.destroy.call(this);
          };

          l.prototype.init = function (e, l) {
            f.prototype.init.call(this, e, l);
            this.hasZoom && I(e.container, {
              "-ms-touch-action": "none",
              "touch-action": "none"
            });
          };

          l.prototype.onContainerPointerDown = function (e) {
            F(e, "onContainerTouchStart", "touchstart", function (e) {
              D[e.pointerId] = {
                pageX: e.pageX,
                pageY: e.pageY,
                target: e.currentTarget
              };
            });
          };

          l.prototype.onContainerPointerMove = function (e) {
            F(e, "onContainerTouchMove", "touchmove", function (e) {
              D[e.pointerId] = {
                pageX: e.pageX,
                pageY: e.pageY
              };
              D[e.pointerId].target || (D[e.pointerId].target = e.currentTarget);
            });
          };

          l.prototype.onDocumentPointerUp = function (e) {
            F(e, "onDocumentTouchEnd", "touchend", function (e) {
              delete D[e.pointerId];
            });
          };

          l.prototype.setDOMEvents = function () {
            f.prototype.setDOMEvents.call(this);
            (this.hasZoom || this.followTouchMove) && this.batchMSEvents(e);
          };

          return l;
        }(h);
      });
      N(m, "Core/Legend.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m) {
        var z = f.animObject,
            F = f.setAnimation,
            L = m.addEvent,
            K = m.css,
            C = m.defined,
            y = m.discardElement,
            e = m.find,
            I = m.fireEvent,
            v = m.format,
            x = m.isNumber,
            D = m.merge,
            n = m.pick,
            l = m.relativeLength,
            J = m.stableSort,
            w = m.syncTimeout;
        f = m.wrap;
        m = h.isFirefox;

        var r = h.marginNames,
            d = h.win,
            g = function () {
          function c(a, c) {
            this.allItems = [];
            this.contentGroup = this.box = void 0;
            this.display = !1;
            this.group = void 0;
            this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
            this.options = {};
            this.padding = 0;
            this.pages = [];
            this.proximate = !1;
            this.scrollGroup = void 0;
            this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
            this.chart = a;
            this.init(a, c);
          }

          c.prototype.init = function (a, c) {
            this.chart = a;
            this.setOptions(c);
            c.enabled && (this.render(), L(this.chart, "endResize", function () {
              this.legend.positionCheckboxes();
            }), this.proximate ? this.unchartrender = L(this.chart, "render", function () {
              this.legend.proximatePositions();
              this.legend.positionItems();
            }) : this.unchartrender && this.unchartrender());
          };

          c.prototype.setOptions = function (a) {
            var c = n(a.padding, 8);
            this.options = a;
            this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = D(this.itemStyle, a.itemHiddenStyle));
            this.itemMarginTop = a.itemMarginTop || 0;
            this.itemMarginBottom = a.itemMarginBottom || 0;
            this.padding = c;
            this.initialItemY = c - 5;
            this.symbolWidth = n(a.symbolWidth, 16);
            this.pages = [];
            this.proximate = "proximate" === a.layout && !this.chart.inverted;
            this.baseline = void 0;
          };

          c.prototype.update = function (a, c) {
            var d = this.chart;
            this.setOptions(D(!0, this.options, a));
            this.destroy();
            d.isDirtyLegend = d.isDirtyBox = !0;
            n(c, !0) && d.redraw();
            I(this, "afterUpdate");
          };

          c.prototype.colorizeItem = function (a, c) {
            a.legendGroup[c ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");

            if (!this.chart.styledMode) {
              var d = this.options,
                  g = a.legendItem,
                  e = a.legendLine,
                  f = a.legendSymbol,
                  q = this.itemHiddenStyle.color;
              d = c ? d.itemStyle.color : q;
              var l = c ? a.color || q : q,
                  r = a.options && a.options.marker,
                  n = {
                fill: l
              };
              g && g.css({
                fill: d,
                color: d
              });
              e && e.attr({
                stroke: l
              });
              f && (r && f.isMarker && (n = a.pointAttribs(), c || (n.stroke = n.fill = q)), f.attr(n));
            }

            I(this, "afterColorizeItem", {
              item: a,
              visible: c
            });
          };

          c.prototype.positionItems = function () {
            this.allItems.forEach(this.positionItem, this);
            this.chart.isResizing || this.positionCheckboxes();
          };

          c.prototype.positionItem = function (a) {
            var c = this,
                d = this.options,
                g = d.symbolPadding,
                e = !d.rtl,
                f = a._legendItemPos;
            d = f[0];
            f = f[1];
            var l = a.checkbox,
                n = a.legendGroup;
            n && n.element && (g = {
              translateX: e ? d : this.legendWidth - d - 2 * g - 4,
              translateY: f
            }, e = function e() {
              I(c, "afterPositionItem", {
                item: a
              });
            }, C(n.translateY) ? n.animate(g, void 0, e) : (n.attr(g), e()));
            l && (l.x = d, l.y = f);
          };

          c.prototype.destroyItem = function (a) {
            var c = a.checkbox;
            ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function (c) {
              a[c] && (a[c] = a[c].destroy());
            });
            c && y(a.checkbox);
          };

          c.prototype.destroy = function () {
            function a(a) {
              this[a] && (this[a] = this[a].destroy());
            }

            this.getAllItems().forEach(function (c) {
              ["legendItem", "legendGroup"].forEach(a, c);
            });
            "clipRect up down pager nav box title group".split(" ").forEach(a, this);
            this.display = null;
          };

          c.prototype.positionCheckboxes = function () {
            var a = this.group && this.group.alignAttr,
                c = this.clipHeight || this.legendHeight,
                d = this.titleHeight;

            if (a) {
              var g = a.translateY;
              this.allItems.forEach(function (e) {
                var p = e.checkbox;

                if (p) {
                  var f = g + d + p.y + (this.scrollOffset || 0) + 3;
                  K(p, {
                    left: a.translateX + e.checkboxOffset + p.x - 20 + "px",
                    top: f + "px",
                    display: this.proximate || f > g - 6 && f < g + c - 6 ? "" : "none"
                  });
                }
              }, this);
            }
          };

          c.prototype.renderTitle = function () {
            var a = this.options,
                c = this.padding,
                d = a.title,
                g = 0;
            d.text && (this.title || (this.title = this.chart.renderer.label(d.text, c - 3, c - 4, null, null, null, a.useHTML, null, "legend-title").attr({
              zIndex: 1
            }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({
              width: this.maxLegendWidth + "px"
            }), a = this.title.getBBox(), g = a.height, this.offsetWidth = a.width, this.contentGroup.attr({
              translateY: g
            }));
            this.titleHeight = g;
          };

          c.prototype.setText = function (a) {
            var c = this.options;
            a.legendItem.attr({
              text: c.labelFormat ? v(c.labelFormat, a, this.chart) : c.labelFormatter.call(a)
            });
          };

          c.prototype.renderItem = function (a) {
            var c = this.chart,
                d = c.renderer,
                g = this.options,
                e = this.symbolWidth,
                f = g.symbolPadding,
                l = this.itemStyle,
                r = this.itemHiddenStyle,
                h = "horizontal" === g.layout ? n(g.itemDistance, 20) : 0,
                w = !g.rtl,
                v = a.legendItem,
                u = !a.series,
                b = !u && a.series.drawLegendSymbol ? a.series : a,
                k = b.options;
            k = this.createCheckboxForItem && k && k.showCheckbox;
            h = e + f + h + (k ? 20 : 0);
            var t = g.useHTML,
                H = a.options.className;
            v || (a.legendGroup = d.g("legend-item").addClass("highcharts-" + b.type + "-series highcharts-color-" + a.colorIndex + (H ? " " + H : "") + (u ? " highcharts-series-" + a.index : "")).attr({
              zIndex: 1
            }).add(this.scrollGroup), a.legendItem = v = d.text("", w ? e + f : -f, this.baseline || 0, t), c.styledMode || v.css(D(a.visible ? l : r)), v.attr({
              align: w ? "left" : "right",
              zIndex: 2
            }).add(a.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(c.styledMode ? 12 : l.fontSize, v), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, v.attr("y", this.baseline)), this.symbolHeight = g.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, v, t));
            k && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);
            this.colorizeItem(a, a.visible);
            !c.styledMode && l.width || v.css({
              width: (g.itemWidth || this.widthOption || c.spacingBox.width) - h + "px"
            });
            this.setText(a);
            c = v.getBBox();
            a.itemWidth = a.checkboxOffset = g.itemWidth || a.legendItemWidth || c.width + h;
            this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);
            this.totalItemWidth += a.itemWidth;
            this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || c.height || this.symbolHeight);
          };

          c.prototype.layoutItem = function (a) {
            var c = this.options,
                d = this.padding,
                g = "horizontal" === c.layout,
                e = a.itemHeight,
                f = this.itemMarginBottom,
                l = this.itemMarginTop,
                r = g ? n(c.itemDistance, 20) : 0,
                h = this.maxLegendWidth;
            c = c.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : a.itemWidth;
            g && this.itemX - d + c > h && (this.itemX = d, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + f), this.lastLineHeight = 0);
            this.lastItemY = l + this.itemY + f;
            this.lastLineHeight = Math.max(e, this.lastLineHeight);
            a._legendItemPos = [this.itemX, this.itemY];
            g ? this.itemX += c : (this.itemY += l + e + f, this.lastLineHeight = e);
            this.offsetWidth = this.widthOption || Math.max((g ? this.itemX - d - (a.checkbox ? 0 : r) : c) + d, this.offsetWidth);
          };

          c.prototype.getAllItems = function () {
            var a = [];
            this.chart.series.forEach(function (c) {
              var d = c && c.options;
              c && n(d.showInLegend, C(d.linkedTo) ? !1 : void 0, !0) && (a = a.concat(c.legendItems || ("point" === d.legendType ? c.data : c)));
            });
            I(this, "afterGetAllItems", {
              allItems: a
            });
            return a;
          };

          c.prototype.getAlignment = function () {
            var a = this.options;
            return this.proximate ? a.align.charAt(0) + "tv" : a.floating ? "" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);
          };

          c.prototype.adjustMargins = function (a, c) {
            var d = this.chart,
                g = this.options,
                e = this.getAlignment();
            e && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (f, p) {
              f.test(e) && !C(a[p]) && (d[r[p]] = Math.max(d[r[p]], d.legend[(p + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][p] * g[p % 2 ? "x" : "y"] + n(g.margin, 12) + c[p] + (d.titleOffset[p] || 0)));
            });
          };

          c.prototype.proximatePositions = function () {
            var a = this.chart,
                c = [],
                d = "left" === this.options.align;
            this.allItems.forEach(function (g) {
              var f;
              var p = d;

              if (g.yAxis) {
                g.xAxis.options.reversed && (p = !p);
                g.points && (f = e(p ? g.points : g.points.slice(0).reverse(), function (a) {
                  return x(a.plotY);
                }));
                p = this.itemMarginTop + g.legendItem.getBBox().height + this.itemMarginBottom;
                var q = g.yAxis.top - a.plotTop;
                g.visible ? (f = f ? f.plotY : g.yAxis.height, f += q - .3 * p) : f = q + g.yAxis.height;
                c.push({
                  target: f,
                  size: p,
                  item: g
                });
              }
            }, this);
            h.distribute(c, a.plotHeight);
            c.forEach(function (c) {
              c.item._legendItemPos[1] = a.plotTop - a.spacing[0] + c.pos;
            });
          };

          c.prototype.render = function () {
            var a = this.chart,
                c = a.renderer,
                d = this.group,
                g = this.box,
                e = this.options,
                f = this.padding;
            this.itemX = f;
            this.itemY = this.initialItemY;
            this.lastItemY = this.offsetWidth = 0;
            this.widthOption = l(e.width, a.spacingBox.width - f);
            var n = a.spacingBox.width - 2 * f - e.x;
            -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (n /= 2);
            this.maxLegendWidth = this.widthOption || n;
            d || (this.group = d = c.g("legend").attr({
              zIndex: 7
            }).add(), this.contentGroup = c.g().attr({
              zIndex: 1
            }).add(d), this.scrollGroup = c.g().add(this.contentGroup));
            this.renderTitle();
            var r = this.getAllItems();
            J(r, function (a, c) {
              return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);
            });
            e.reversed && r.reverse();
            this.allItems = r;
            this.display = n = !!r.length;
            this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
            r.forEach(this.renderItem, this);
            r.forEach(this.layoutItem, this);
            r = (this.widthOption || this.offsetWidth) + f;
            var h = this.lastItemY + this.lastLineHeight + this.titleHeight;
            h = this.handleOverflow(h);
            h += f;
            g || (this.box = g = c.rect().addClass("highcharts-legend-box").attr({
              r: e.borderRadius
            }).add(d), g.isNew = !0);
            a.styledMode || g.attr({
              stroke: e.borderColor,
              "stroke-width": e.borderWidth || 0,
              fill: e.backgroundColor || "none"
            }).shadow(e.shadow);
            0 < r && 0 < h && (g[g.isNew ? "attr" : "animate"](g.crisp.call({}, {
              x: 0,
              y: 0,
              width: r,
              height: h
            }, g.strokeWidth())), g.isNew = !1);
            g[n ? "show" : "hide"]();
            a.styledMode && "none" === d.getStyle("display") && (r = h = 0);
            this.legendWidth = r;
            this.legendHeight = h;
            n && this.align();
            this.proximate || this.positionItems();
            I(this, "afterRender");
          };

          c.prototype.align = function (a) {
            void 0 === a && (a = this.chart.spacingBox);
            var c = this.chart,
                d = this.options,
                g = a.y;
            /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? g += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (g -= c.titleOffset[2]);
            g !== a.y && (a = D(a, {
              y: g
            }));
            this.group.align(D(d, {
              width: this.legendWidth,
              height: this.legendHeight,
              verticalAlign: this.proximate ? "top" : d.verticalAlign
            }), !0, a);
          };

          c.prototype.handleOverflow = function (a) {
            var c = this,
                d = this.chart,
                g = d.renderer,
                e = this.options,
                f = e.y,
                l = this.padding;
            f = d.spacingBox.height + ("top" === e.verticalAlign ? -f : f) - l;

            var r = e.maxHeight,
                h,
                w = this.clipRect,
                v = e.navigation,
                u = n(v.animation, !0),
                b = v.arrowSize || 12,
                k = this.nav,
                t = this.pages,
                H,
                m = this.allItems,
                D = function D(a) {
              "number" === typeof a ? w.attr({
                height: a
              }) : w && (c.clipRect = w.destroy(), c.contentGroup.clip());
              c.contentGroup.div && (c.contentGroup.div.style.clip = a ? "rect(" + l + "px,9999px," + (l + a) + "px,0)" : "auto");
            },
                x = function x(a) {
              c[a] = g.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(k);
              d.styledMode || c[a].attr("fill", "rgba(0,0,0,0.0001)");
              return c[a];
            };

            "horizontal" !== e.layout || "middle" === e.verticalAlign || e.floating || (f /= 2);
            r && (f = Math.min(f, r));
            t.length = 0;
            a > f && !1 !== v.enabled ? (this.clipHeight = h = Math.max(f - 20 - this.titleHeight - l, 0), this.currentPage = n(this.currentPage, 1), this.fullHeight = a, m.forEach(function (a, b) {
              var c = a._legendItemPos[1],
                  d = Math.round(a.legendItem.getBBox().height),
                  g = t.length;
              if (!g || c - t[g - 1] > h && (H || c) !== t[g - 1]) t.push(H || c), g++;
              a.pageIx = g - 1;
              H && (m[b - 1].pageIx = g - 1);
              b === m.length - 1 && c + d - t[g - 1] > h && c !== H && (t.push(c), a.pageIx = g);
              c !== H && (H = c);
            }), w || (w = c.clipRect = g.clipRect(0, l, 9999, 0), c.contentGroup.clip(w)), D(h), k || (this.nav = k = g.g().attr({
              zIndex: 1
            }).add(this.group), this.up = g.symbol("triangle", 0, 0, b, b).add(k), x("upTracker").on("click", function () {
              c.scroll(-1, u);
            }), this.pager = g.text("", 15, 10).addClass("highcharts-legend-navigation"), d.styledMode || this.pager.css(v.style), this.pager.add(k), this.down = g.symbol("triangle-down", 0, 0, b, b).add(k), x("downTracker").on("click", function () {
              c.scroll(1, u);
            })), c.scroll(0), a = f) : k && (D(), this.nav = k.destroy(), this.scrollGroup.attr({
              translateY: 1
            }), this.clipHeight = 0);
            return a;
          };

          c.prototype.scroll = function (a, c) {
            var d = this,
                g = this.chart,
                e = this.pages,
                f = e.length,
                l = this.currentPage + a;
            a = this.clipHeight;
            var q = this.options.navigation,
                r = this.pager,
                h = this.padding;
            l > f && (l = f);
            0 < l && ("undefined" !== typeof c && F(c, g), this.nav.attr({
              translateX: h,
              translateY: a + this.padding + 7 + this.titleHeight,
              visibility: "visible"
            }), [this.up, this.upTracker].forEach(function (a) {
              a.attr({
                "class": 1 === l ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
              });
            }), r.attr({
              text: l + "/" + f
            }), [this.down, this.downTracker].forEach(function (a) {
              a.attr({
                x: 18 + this.pager.getBBox().width,
                "class": l === f ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
              });
            }, this), g.styledMode || (this.up.attr({
              fill: 1 === l ? q.inactiveColor : q.activeColor
            }), this.upTracker.css({
              cursor: 1 === l ? "default" : "pointer"
            }), this.down.attr({
              fill: l === f ? q.inactiveColor : q.activeColor
            }), this.downTracker.css({
              cursor: l === f ? "default" : "pointer"
            })), this.scrollOffset = -e[l - 1] + this.initialItemY, this.scrollGroup.animate({
              translateY: this.scrollOffset
            }), this.currentPage = l, this.positionCheckboxes(), c = z(n(c, g.renderer.globalAnimation, !0)), w(function () {
              I(d, "afterScroll", {
                currentPage: l
              });
            }, c.duration));
          };

          return c;
        }();

        (/Trident\/7\.0/.test(d.navigator && d.navigator.userAgent) || m) && f(g.prototype, "positionItem", function (c, a) {
          var d = this,
              g = function g() {
            a._legendItemPos && c.call(d, a);
          };

          g();
          d.bubbleLegend || setTimeout(g);
        });
        h.Legend = g;
        return h.Legend;
      });
      N(m, "Core/Series/Point.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m) {
        var z = f.animObject,
            F = m.defined,
            L = m.erase,
            K = m.extend,
            C = m.fireEvent,
            y = m.format,
            e = m.getNestedProperty,
            I = m.isArray,
            v = m.isNumber,
            x = m.isObject,
            D = m.syncTimeout,
            n = m.pick,
            l = m.removeEvent,
            J = m.uniqueKey;
        "";

        f = function () {
          function f() {
            this.colorIndex = this.category = void 0;
            this.formatPrefix = "point";
            this.id = void 0;
            this.isNull = !1;
            this.percentage = this.options = this.name = void 0;
            this.selected = !1;
            this.total = this.series = void 0;
            this.visible = !0;
            this.x = void 0;
          }

          f.prototype.animateBeforeDestroy = function () {
            var e = this,
                d = {
              x: e.startXPos,
              opacity: 0
            },
                g,
                c = e.getGraphicalProps();
            c.singular.forEach(function (a) {
              g = "dataLabel" === a;
              e[a] = e[a].animate(g ? {
                x: e[a].startXPos,
                y: e[a].startYPos,
                opacity: 0
              } : d);
            });
            c.plural.forEach(function (a) {
              e[a].forEach(function (a) {
                a.element && a.animate(K({
                  x: e.startXPos
                }, a.startYPos ? {
                  x: a.startXPos,
                  y: a.startYPos
                } : {}));
              });
            });
          };

          f.prototype.applyOptions = function (e, d) {
            var g = this.series,
                c = g.options.pointValKey || g.pointValKey;
            e = f.prototype.optionsToObject.call(this, e);
            K(this, e);
            this.options = this.options ? K(this.options, e) : e;
            e.group && delete this.group;
            e.dataLabels && delete this.dataLabels;
            c && (this.y = f.prototype.getNestedProperty.call(this, c));
            this.formatPrefix = (this.isNull = n(this.isValid && !this.isValid(), null === this.x || !v(this.y))) ? "null" : "point";
            this.selected && (this.state = "select");
            "name" in this && "undefined" === typeof d && g.xAxis && g.xAxis.hasNames && (this.x = g.xAxis.nameToX(this));
            "undefined" === typeof this.x && g && (this.x = "undefined" === typeof d ? g.autoIncrement(this) : d);
            return this;
          };

          f.prototype.destroy = function () {
            function e() {
              if (d.graphic || d.dataLabel || d.dataLabels) l(d), d.destroyElements();

              for (p in d) d[p] = null;
            }

            var d = this,
                g = d.series,
                c = g.chart;
            g = g.options.dataSorting;
            var a = c.hoverPoints,
                f = z(d.series.chart.renderer.globalAnimation),
                p;
            d.legendItem && c.legend.destroyItem(d);
            a && (d.setState(), L(a, d), a.length || (c.hoverPoints = null));
            if (d === c.hoverPoint) d.onMouseOut();
            g && g.enabled ? (this.animateBeforeDestroy(), D(e, f.duration)) : e();
            c.pointCount--;
          };

          f.prototype.destroyElements = function (e) {
            var d = this;
            e = d.getGraphicalProps(e);
            e.singular.forEach(function (g) {
              d[g] = d[g].destroy();
            });
            e.plural.forEach(function (g) {
              d[g].forEach(function (c) {
                c.element && c.destroy();
              });
              delete d[g];
            });
          };

          f.prototype.firePointEvent = function (e, d, g) {
            var c = this,
                a = this.series.options;
            (a.point.events[e] || c.options && c.options.events && c.options.events[e]) && c.importEvents();
            "click" === e && a.allowPointSelect && (g = function g(a) {
              c.select && c.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
            });
            C(c, e, d, g);
          };

          f.prototype.getClassName = function () {
            return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + ("undefined" !== typeof this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
          };

          f.prototype.getGraphicalProps = function (e) {
            var d = this,
                g = [],
                c,
                a = {
              singular: [],
              plural: []
            };
            e = e || {
              graphic: 1,
              dataLabel: 1
            };
            e.graphic && g.push("graphic", "shadowGroup");
            e.dataLabel && g.push("dataLabel", "dataLabelUpper", "connector");

            for (c = g.length; c--;) {
              var f = g[c];
              d[f] && a.singular.push(f);
            }

            ["dataLabel", "connector"].forEach(function (c) {
              var g = c + "s";
              e[c] && d[g] && a.plural.push(g);
            });
            return a;
          };

          f.prototype.getLabelConfig = function () {
            return {
              x: this.category,
              y: this.y,
              color: this.color,
              colorIndex: this.colorIndex,
              key: this.name || this.category,
              series: this.series,
              point: this,
              percentage: this.percentage,
              total: this.total || this.stackTotal
            };
          };

          f.prototype.getNestedProperty = function (f) {
            if (f) return 0 === f.indexOf("custom.") ? e(f, this.options) : this[f];
          };

          f.prototype.getZone = function () {
            var e = this.series,
                d = e.zones;
            e = e.zoneAxis || "y";
            var g = 0,
                c;

            for (c = d[g]; this[e] >= c.value;) c = d[++g];

            this.nonZonedColor || (this.nonZonedColor = this.color);
            this.color = c && c.color && !this.options.color ? c.color : this.nonZonedColor;
            return c;
          };

          f.prototype.hasNewShapeType = function () {
            return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
          };

          f.prototype.init = function (e, d, g) {
            this.series = e;
            this.applyOptions(d, g);
            this.id = F(this.id) ? this.id : J();
            this.resolveColor();
            e.chart.pointCount++;
            C(this, "afterInit");
            return this;
          };

          f.prototype.optionsToObject = function (e) {
            var d = {},
                g = this.series,
                c = g.options.keys,
                a = c || g.pointArrayMap || ["y"],
                l = a.length,
                p = 0,
                n = 0;
            if (v(e) || null === e) d[a[0]] = e;else if (I(e)) for (!c && e.length > l && (g = typeof e[0], "string" === g ? d.name = e[0] : "number" === g && (d.x = e[0]), p++); n < l;) c && "undefined" === typeof e[p] || (0 < a[n].indexOf(".") ? f.prototype.setNestedProperty(d, e[p], a[n]) : d[a[n]] = e[p]), p++, n++;else "object" === typeof e && (d = e, e.dataLabels && (g._hasPointLabels = !0), e.marker && (g._hasPointMarkers = !0));
            return d;
          };

          f.prototype.resolveColor = function () {
            var e = this.series;
            var d = e.chart.options.chart.colorCount;
            var g = e.chart.styledMode;
            delete this.nonZonedColor;
            g || this.options.color || (this.color = e.color);
            e.options.colorByPoint ? (g || (d = e.options.colors || e.chart.options.colors, this.color = this.color || d[e.colorCounter], d = d.length), g = e.colorCounter, e.colorCounter++, e.colorCounter === d && (e.colorCounter = 0)) : g = e.colorIndex;
            this.colorIndex = n(this.colorIndex, g);
          };

          f.prototype.setNestedProperty = function (e, d, g) {
            g.split(".").reduce(function (c, a, g, e) {
              c[a] = e.length - 1 === g ? d : x(c[a], !0) ? c[a] : {};
              return c[a];
            }, e);
            return e;
          };

          f.prototype.tooltipFormatter = function (e) {
            var d = this.series,
                g = d.tooltipOptions,
                c = n(g.valueDecimals, ""),
                a = g.valuePrefix || "",
                f = g.valueSuffix || "";
            d.chart.styledMode && (e = d.chart.tooltip.styledModeFormat(e));
            (d.pointArrayMap || ["y"]).forEach(function (d) {
              d = "{point." + d;
              if (a || f) e = e.replace(RegExp(d + "}", "g"), a + d + "}" + f);
              e = e.replace(RegExp(d + "}", "g"), d + ":,." + c + "f}");
            });
            return y(e, {
              point: this,
              series: this.series
            }, d.chart);
          };

          return f;
        }();

        return h.Point = f;
      });
      N(m, "Core/Series/Series.js", [m["Core/Globals.js"], m["Core/Series/Point.js"], m["Core/Utilities.js"]], function (f, h, m) {
        var z = m.error,
            F = m.extendClass,
            L = m.fireEvent,
            K = m.getOptions,
            C = m.isObject,
            y = m.merge,
            e = m.objectEach;

        m = function () {
          function f(e, h) {
            var v = y(f.defaultOptions, h);
            this.chart = e;
            this._i = e.series.length;
            e.series.push(this);
            this.options = v;
            this.userOptions = y(h);
          }

          f.addSeries = function (e, h) {
            f.seriesTypes[e] = h;
          };

          f.cleanRecursively = function (h, m) {
            var v = {};
            e(h, function (e, l) {
              if (C(h[l], !0) && !h.nodeType && m[l]) e = f.cleanRecursively(h[l], m[l]), Object.keys(e).length && (v[l] = e);else if (C(h[l]) || h[l] !== m[l]) v[l] = h[l];
            });
            return v;
          };

          f.getSeries = function (e, h) {
            void 0 === h && (h = {});
            var v = e.options.chart;
            v = h.type || v.type || v.defaultSeriesType || "";
            var n = f.seriesTypes[v];
            n || z(17, !0, e, {
              missingModuleFor: v
            });
            return new n(e, h);
          };

          f.seriesType = function (e, m, D, n, l) {
            var v = K().plotOptions || {},
                w = f.seriesTypes;
            m = m || "";
            v[e] = y(v[m], D);
            f.addSeries(e, F(w[m] || function () {}, n));
            w[e].prototype.type = e;
            l && (w[e].prototype.pointClass = F(h, l));
            return w[e];
          };

          f.prototype.update = function (e, h) {
            void 0 === h && (h = !0);
            var m = this;
            e = f.cleanRecursively(e, this.userOptions);
            var n = e.type;
            "undefined" !== typeof n && n !== m.type && (m = f.getSeries(m.chart, e));
            L(m, "update", {
              newOptions: e
            });
            m.userOptions = y(e);
            L(m, "afterUpdate", {
              newOptions: e
            });
            h && m.chart.redraw();
            return m;
          };

          f.defaultOptions = {
            type: "base"
          };
          f.seriesTypes = {};
          return f;
        }();

        m.prototype.pointClass = h;
        f.seriesType = m.seriesType;
        f.seriesTypes = m.seriesTypes;
        return m;
      });
      N(m, "Core/Chart/Chart.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Axis/Axis.js"], m["Core/Series/Series.js"], m["Core/Globals.js"], m["Core/Legend.js"], m["Core/MSPointer.js"], m["Core/Options.js"], m["Core/Pointer.js"], m["Core/Time.js"], m["Core/Utilities.js"]], function (f, h, m, z, F, L, K, C, y, e) {
        var I = f.animate,
            v = f.animObject,
            x = f.setAnimation,
            D = z.charts,
            n = z.doc,
            l = z.win,
            J = K.defaultOptions,
            w = e.addEvent,
            r = e.attr,
            d = e.createElement,
            g = e.css,
            c = e.defined,
            a = e.discardElement,
            q = e.erase,
            p = e.error,
            B = e.extend,
            A = e.find,
            G = e.fireEvent,
            M = e.getStyle,
            T = e.isArray,
            Q = e.isFunction,
            O = e.isNumber,
            E = e.isObject,
            u = e.isString,
            b = e.merge,
            k = e.numberFormat,
            t = e.objectEach,
            H = e.pick,
            R = e.pInt,
            U = e.relativeLength,
            Z = e.removeEvent,
            aa = e.splat,
            ba = e.syncTimeout,
            S = e.uniqueKey,
            Y = z.marginNames,
            W = function () {
          function f(a, b, c) {
            this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
            this.getArgs(a, b, c);
          }

          f.prototype.getArgs = function (a, b, c) {
            u(a) || a.nodeName ? (this.renderTo = a, this.init(b, c)) : this.init(a, b);
          };

          f.prototype.init = function (a, c) {
            var d,
                g = a.series,
                e = a.plotOptions || {};
            G(this, "init", {
              args: arguments
            }, function () {
              a.series = null;
              d = b(J, a);
              var f = d.chart || {};
              t(d.plotOptions, function (a, c) {
                E(a) && (a.tooltip = e[c] && b(e[c].tooltip) || void 0);
              });
              d.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;
              d.series = a.series = g;
              this.userOptions = a;
              var p = f.events;
              this.margin = [];
              this.spacing = [];
              this.bounds = {
                h: {},
                v: {}
              };
              this.labelCollectors = [];
              this.callback = c;
              this.isResizing = 0;
              this.options = d;
              this.axes = [];
              this.series = [];
              this.time = a.time && Object.keys(a.time).length ? new y(a.time) : z.time;
              this.numberFormatter = f.numberFormatter || k;
              this.styledMode = f.styledMode;
              this.hasCartesianSeries = f.showAxes;
              var l = this;
              l.index = D.length;
              D.push(l);
              z.chartCount++;
              p && t(p, function (a, b) {
                Q(a) && w(l, b, a);
              });
              l.xAxis = [];
              l.yAxis = [];
              l.pointCount = l.colorCounter = l.symbolCounter = 0;
              G(l, "afterInit");
              l.firstRender();
            });
          };

          f.prototype.initSeries = function (a) {
            var b = this.options.chart;
            b = a.type || b.type || b.defaultSeriesType;
            var c = m.seriesTypes[b];
            c || p(17, !0, this, {
              missingModuleFor: b
            });
            b = new c(this, a);
            "function" === typeof b.init && b.init(this, a);
            return b;
          };

          f.prototype.setSeriesData = function () {
            this.getSeriesOrderByLinks().forEach(function (a) {
              a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);
            });
          };

          f.prototype.getSeriesOrderByLinks = function () {
            return this.series.concat().sort(function (a, b) {
              return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;
            });
          };

          f.prototype.orderSeries = function (a) {
            var b = this.series;

            for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());
          };

          f.prototype.isInsidePlot = function (a, b, c) {
            var d = c ? b : a;
            a = c ? a : b;
            d = {
              x: d,
              y: a,
              isInsidePlot: 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight
            };
            G(this, "afterIsInsidePlot", d);
            return d.isInsidePlot;
          };

          f.prototype.redraw = function (a) {
            G(this, "beforeRedraw");
            var b = this,
                c = b.axes,
                d = b.series,
                g = b.pointer,
                k = b.legend,
                e = b.userOptions.legend,
                f = b.isDirtyLegend,
                t = b.hasCartesianSeries,
                p = b.isDirtyBox,
                l = b.renderer,
                q = l.isHidden(),
                h = [];
            b.setResponsive && b.setResponsive(!1);
            x(b.hasRendered ? a : !1, b);
            q && b.temporaryDisplay();
            b.layOutTitles();

            for (a = d.length; a--;) {
              var n = d[a];

              if (n.options.stacking) {
                var u = !0;

                if (n.isDirty) {
                  var r = !0;
                  break;
                }
              }
            }

            if (r) for (a = d.length; a--;) n = d[a], n.options.stacking && (n.isDirty = !0);
            d.forEach(function (a) {
              a.isDirty && ("point" === a.options.legendType ? ("function" === typeof a.updateTotals && a.updateTotals(), f = !0) : e && (e.labelFormatter || e.labelFormat) && (f = !0));
              a.isDirtyData && G(a, "updatedData");
            });
            f && k && k.options.enabled && (k.render(), b.isDirtyLegend = !1);
            u && b.getStacks();
            t && c.forEach(function (a) {
              b.isResizing && O(a.min) || (a.updateNames(), a.setScale());
            });
            b.getMargins();
            t && (c.forEach(function (a) {
              a.isDirty && (p = !0);
            }), c.forEach(function (a) {
              var b = a.min + "," + a.max;
              a.extKey !== b && (a.extKey = b, h.push(function () {
                G(a, "afterSetExtremes", B(a.eventArgs, a.getExtremes()));
                delete a.eventArgs;
              }));
              (p || u) && a.redraw();
            }));
            p && b.drawChartBox();
            G(b, "predraw");
            d.forEach(function (a) {
              (p || a.isDirty) && a.visible && a.redraw();
              a.isDirtyData = !1;
            });
            g && g.reset(!0);
            l.draw();
            G(b, "redraw");
            G(b, "render");
            q && b.temporaryDisplay(!0);
            h.forEach(function (a) {
              a.call();
            });
          };

          f.prototype.get = function (a) {
            function b(b) {
              return b.id === a || b.options && b.options.id === a;
            }

            var c = this.series,
                d;
            var g = A(this.axes, b) || A(this.series, b);

            for (d = 0; !g && d < c.length; d++) g = A(c[d].points || [], b);

            return g;
          };

          f.prototype.getAxes = function () {
            var a = this,
                b = this.options,
                c = b.xAxis = aa(b.xAxis || {});
            b = b.yAxis = aa(b.yAxis || {});
            G(this, "getAxes");
            c.forEach(function (a, b) {
              a.index = b;
              a.isX = !0;
            });
            b.forEach(function (a, b) {
              a.index = b;
            });
            c.concat(b).forEach(function (b) {
              new h(a, b);
            });
            G(this, "afterGetAxes");
          };

          f.prototype.getSelectedPoints = function () {
            var a = [];
            this.series.forEach(function (b) {
              a = a.concat(b.getPointsCollection().filter(function (a) {
                return H(a.selectedStaging, a.selected);
              }));
            });
            return a;
          };

          f.prototype.getSelectedSeries = function () {
            return this.series.filter(function (a) {
              return a.selected;
            });
          };

          f.prototype.setTitle = function (a, b, c) {
            this.applyDescription("title", a);
            this.applyDescription("subtitle", b);
            this.applyDescription("caption", void 0);
            this.layOutTitles(c);
          };

          f.prototype.applyDescription = function (a, c) {
            var d = this,
                g = "title" === a ? {
              color: "#333333",
              fontSize: this.options.isStock ? "16px" : "18px"
            } : {
              color: "#666666"
            };
            g = this.options[a] = b(!this.styledMode && {
              style: g
            }, this.options[a], c);
            var k = this[a];
            k && c && (this[a] = k = k.destroy());
            g && !k && (k = this.renderer.text(g.text, 0, 0, g.useHTML).attr({
              align: g.align,
              "class": "highcharts-" + a,
              zIndex: g.zIndex || 4
            }).add(), k.update = function (b) {
              d[{
                title: "setTitle",
                subtitle: "setSubtitle",
                caption: "setCaption"
              }[a]](b);
            }, this.styledMode || k.css(g.style), this[a] = k);
          };

          f.prototype.layOutTitles = function (a) {
            var b = [0, 0, 0],
                c = this.renderer,
                d = this.spacingBox;
            ["title", "subtitle", "caption"].forEach(function (a) {
              var g = this[a],
                  k = this.options[a],
                  e = k.verticalAlign || "top";
              a = "title" === a ? -3 : "top" === e ? b[0] + 2 : 0;

              if (g) {
                if (!this.styledMode) var f = k.style.fontSize;
                f = c.fontMetrics(f, g).b;
                g.css({
                  width: (k.width || d.width + (k.widthAdjust || 0)) + "px"
                });
                var t = Math.round(g.getBBox(k.useHTML).height);
                g.align(B({
                  y: "bottom" === e ? f : a + f,
                  height: t
                }, k), !1, "spacingBox");
                k.floating || ("top" === e ? b[0] = Math.ceil(b[0] + t) : "bottom" === e && (b[2] = Math.ceil(b[2] + t)));
              }
            }, this);
            b[0] && "top" === (this.options.title.verticalAlign || "top") && (b[0] += this.options.title.margin);
            b[2] && "bottom" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);
            var g = !this.titleOffset || this.titleOffset.join(",") !== b.join(",");
            this.titleOffset = b;
            G(this, "afterLayOutTitles");
            !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && H(a, !0) && this.isDirtyBox && this.redraw());
          };

          f.prototype.getChartSize = function () {
            var a = this.options.chart,
                b = a.width;
            a = a.height;
            var d = this.renderTo;
            c(b) || (this.containerWidth = M(d, "width"));
            c(a) || (this.containerHeight = M(d, "height"));
            this.chartWidth = Math.max(0, b || this.containerWidth || 600);
            this.chartHeight = Math.max(0, U(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
          };

          f.prototype.temporaryDisplay = function (a) {
            var b = this.renderTo;
            if (a) for (; b && b.style;) b.hcOrigStyle && (g(b, b.hcOrigStyle), delete b.hcOrigStyle), b.hcOrigDetached && (n.body.removeChild(b), b.hcOrigDetached = !1), b = b.parentNode;else for (; b && b.style;) {
              n.body.contains(b) || b.parentNode || (b.hcOrigDetached = !0, n.body.appendChild(b));
              if ("none" === M(b, "display", !1) || b.hcOricDetached) b.hcOrigStyle = {
                display: b.style.display,
                height: b.style.height,
                overflow: b.style.overflow
              }, a = {
                display: "block",
                overflow: "hidden"
              }, b !== this.renderTo && (a.height = 0), g(b, a), b.offsetWidth || b.style.setProperty("display", "block", "important");
              b = b.parentNode;
              if (b === n.body) break;
            }
          };

          f.prototype.setClassName = function (a) {
            this.container.className = "highcharts-container " + (a || "");
          };

          f.prototype.getContainer = function () {
            var a = this.options,
                b = a.chart;
            var c = this.renderTo;
            var k = S(),
                e,
                f;
            c || (this.renderTo = c = b.renderTo);
            u(c) && (this.renderTo = c = n.getElementById(c));
            c || p(13, !0, this);
            var t = R(r(c, "data-highcharts-chart"));
            O(t) && D[t] && D[t].hasRendered && D[t].destroy();
            r(c, "data-highcharts-chart", this.index);
            c.innerHTML = "";
            b.skipClone || c.offsetWidth || this.temporaryDisplay();
            this.getChartSize();
            t = this.chartWidth;
            var l = this.chartHeight;
            g(c, {
              overflow: "hidden"
            });
            this.styledMode || (e = B({
              position: "relative",
              overflow: "hidden",
              width: t + "px",
              height: l + "px",
              textAlign: "left",
              lineHeight: "normal",
              zIndex: 0,
              "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
              userSelect: "none"
            }, b.style));
            this.container = c = d("div", {
              id: k
            }, e, c);
            this._cursor = c.style.cursor;
            this.renderer = new (z[b.renderer] || z.Renderer)(c, t, l, null, b.forExport, a.exporting && a.exporting.allowHTML, this.styledMode);
            x(void 0, this);
            this.setClassName(b.className);
            if (this.styledMode) for (f in a.defs) this.renderer.definition(a.defs[f]);else this.renderer.setStyle(b.style);
            this.renderer.chartIndex = this.index;
            G(this, "afterGetContainer");
          };

          f.prototype.getMargins = function (a) {
            var b = this.spacing,
                d = this.margin,
                g = this.titleOffset;
            this.resetMargins();
            g[0] && !c(d[0]) && (this.plotTop = Math.max(this.plotTop, g[0] + b[0]));
            g[2] && !c(d[2]) && (this.marginBottom = Math.max(this.marginBottom, g[2] + b[2]));
            this.legend && this.legend.display && this.legend.adjustMargins(d, b);
            G(this, "getMargins");
            a || this.getAxisMargins();
          };

          f.prototype.getAxisMargins = function () {
            var a = this,
                b = a.axisOffset = [0, 0, 0, 0],
                d = a.colorAxis,
                g = a.margin,
                k = function k(a) {
              a.forEach(function (a) {
                a.visible && a.getOffset();
              });
            };

            a.hasCartesianSeries ? k(a.axes) : d && d.length && k(d);
            Y.forEach(function (d, k) {
              c(g[k]) || (a[d] += b[k]);
            });
            a.setChartSize();
          };

          f.prototype.reflow = function (a) {
            var b = this,
                d = b.options.chart,
                g = b.renderTo,
                k = c(d.width) && c(d.height),
                f = d.width || M(g, "width");
            d = d.height || M(g, "height");
            g = a ? a.target : l;

            if (!k && !b.isPrinting && f && d && (g === l || g === n)) {
              if (f !== b.containerWidth || d !== b.containerHeight) e.clearTimeout(b.reflowTimeout), b.reflowTimeout = ba(function () {
                b.container && b.setSize(void 0, void 0, !1);
              }, a ? 100 : 0);
              b.containerWidth = f;
              b.containerHeight = d;
            }
          };

          f.prototype.setReflow = function (a) {
            var b = this;
            !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = w(l, "resize", function (a) {
              b.options && b.reflow(a);
            }), w(this, "destroy", this.unbindReflow));
          };

          f.prototype.setSize = function (a, b, c) {
            var d = this,
                k = d.renderer;
            d.isResizing += 1;
            x(c, d);
            c = k.globalAnimation;
            d.oldChartHeight = d.chartHeight;
            d.oldChartWidth = d.chartWidth;
            "undefined" !== typeof a && (d.options.chart.width = a);
            "undefined" !== typeof b && (d.options.chart.height = b);
            d.getChartSize();
            d.styledMode || (c ? I : g)(d.container, {
              width: d.chartWidth + "px",
              height: d.chartHeight + "px"
            }, c);
            d.setChartSize(!0);
            k.setSize(d.chartWidth, d.chartHeight, c);
            d.axes.forEach(function (a) {
              a.isDirty = !0;
              a.setScale();
            });
            d.isDirtyLegend = !0;
            d.isDirtyBox = !0;
            d.layOutTitles();
            d.getMargins();
            d.redraw(c);
            d.oldChartHeight = null;
            G(d, "resize");
            ba(function () {
              d && G(d, "endResize", null, function () {
                --d.isResizing;
              });
            }, v(c).duration);
          };

          f.prototype.setChartSize = function (a) {
            var b = this.inverted,
                c = this.renderer,
                d = this.chartWidth,
                g = this.chartHeight,
                k = this.options.chart,
                e = this.spacing,
                f = this.clipOffset,
                t,
                p,
                l,
                q;
            this.plotLeft = t = Math.round(this.plotLeft);
            this.plotTop = p = Math.round(this.plotTop);
            this.plotWidth = l = Math.max(0, Math.round(d - t - this.marginRight));
            this.plotHeight = q = Math.max(0, Math.round(g - p - this.marginBottom));
            this.plotSizeX = b ? q : l;
            this.plotSizeY = b ? l : q;
            this.plotBorderWidth = k.plotBorderWidth || 0;
            this.spacingBox = c.spacingBox = {
              x: e[3],
              y: e[0],
              width: d - e[3] - e[1],
              height: g - e[0] - e[2]
            };
            this.plotBox = c.plotBox = {
              x: t,
              y: p,
              width: l,
              height: q
            };
            d = 2 * Math.floor(this.plotBorderWidth / 2);
            b = Math.ceil(Math.max(d, f[3]) / 2);
            c = Math.ceil(Math.max(d, f[0]) / 2);
            this.clipBox = {
              x: b,
              y: c,
              width: Math.floor(this.plotSizeX - Math.max(d, f[1]) / 2 - b),
              height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, f[2]) / 2 - c))
            };
            a || this.axes.forEach(function (a) {
              a.setAxisSize();
              a.setAxisTranslation();
            });
            G(this, "afterSetChartSize", {
              skipAxes: a
            });
          };

          f.prototype.resetMargins = function () {
            G(this, "resetMargins");
            var a = this,
                b = a.options.chart;
            ["margin", "spacing"].forEach(function (c) {
              var d = b[c],
                  g = E(d) ? d : [d, d, d, d];
              ["Top", "Right", "Bottom", "Left"].forEach(function (d, k) {
                a[c][k] = H(b[c + d], g[k]);
              });
            });
            Y.forEach(function (b, c) {
              a[b] = H(a.margin[c], a.spacing[c]);
            });
            a.axisOffset = [0, 0, 0, 0];
            a.clipOffset = [0, 0, 0, 0];
          };

          f.prototype.drawChartBox = function () {
            var a = this.options.chart,
                b = this.renderer,
                c = this.chartWidth,
                d = this.chartHeight,
                g = this.chartBackground,
                k = this.plotBackground,
                e = this.plotBorder,
                f = this.styledMode,
                t = this.plotBGImage,
                p = a.backgroundColor,
                l = a.plotBackgroundColor,
                q = a.plotBackgroundImage,
                h,
                n = this.plotLeft,
                u = this.plotTop,
                r = this.plotWidth,
                m = this.plotHeight,
                w = this.plotBox,
                v = this.clipRect,
                H = this.clipBox,
                B = "animate";
            g || (this.chartBackground = g = b.rect().addClass("highcharts-background").add(), B = "attr");
            if (f) var A = h = g.strokeWidth();else {
              A = a.borderWidth || 0;
              h = A + (a.shadow ? 8 : 0);
              p = {
                fill: p || "none"
              };
              if (A || g["stroke-width"]) p.stroke = a.borderColor, p["stroke-width"] = A;
              g.attr(p).shadow(a.shadow);
            }
            g[B]({
              x: h / 2,
              y: h / 2,
              width: c - h - A % 2,
              height: d - h - A % 2,
              r: a.borderRadius
            });
            B = "animate";
            k || (B = "attr", this.plotBackground = k = b.rect().addClass("highcharts-plot-background").add());
            k[B](w);
            f || (k.attr({
              fill: l || "none"
            }).shadow(a.plotShadow), q && (t ? (q !== t.attr("href") && t.attr("href", q), t.animate(w)) : this.plotBGImage = b.image(q, n, u, r, m).add()));
            v ? v.animate({
              width: H.width,
              height: H.height
            }) : this.clipRect = b.clipRect(H);
            B = "animate";
            e || (B = "attr", this.plotBorder = e = b.rect().addClass("highcharts-plot-border").attr({
              zIndex: 1
            }).add());
            f || e.attr({
              stroke: a.plotBorderColor,
              "stroke-width": a.plotBorderWidth || 0,
              fill: "none"
            });
            e[B](e.crisp({
              x: n,
              y: u,
              width: r,
              height: m
            }, -e.strokeWidth()));
            this.isDirtyBox = !1;
            G(this, "afterDrawChartBox");
          };

          f.prototype.propFromSeries = function () {
            var a = this,
                b = a.options.chart,
                c,
                d = a.options.series,
                g,
                k;
            ["inverted", "angular", "polar"].forEach(function (e) {
              c = m.seriesTypes[b.type || b.defaultSeriesType];
              k = b[e] || c && c.prototype[e];

              for (g = d && d.length; !k && g--;) (c = m.seriesTypes[d[g].type]) && c.prototype[e] && (k = !0);

              a[e] = k;
            });
          };

          f.prototype.linkSeries = function () {
            var a = this,
                b = a.series;
            b.forEach(function (a) {
              a.linkedSeries.length = 0;
            });
            b.forEach(function (b) {
              var c = b.options.linkedTo;
              u(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = H(b.options.visible, c.options.visible, b.visible));
            });
            G(this, "afterLinkSeries");
          };

          f.prototype.renderSeries = function () {
            this.series.forEach(function (a) {
              a.translate();
              a.render();
            });
          };

          f.prototype.renderLabels = function () {
            var a = this,
                b = a.options.labels;
            b.items && b.items.forEach(function (c) {
              var d = B(b.style, c.style),
                  g = R(d.left) + a.plotLeft,
                  k = R(d.top) + a.plotTop + 12;
              delete d.left;
              delete d.top;
              a.renderer.text(c.html, g, k).attr({
                zIndex: 2
              }).css(d).add();
            });
          };

          f.prototype.render = function () {
            var a = this.axes,
                b = this.colorAxis,
                c = this.renderer,
                d = this.options,
                g = 0,
                k = function k(a) {
              a.forEach(function (a) {
                a.visible && a.render();
              });
            };

            this.setTitle();
            this.legend = new F(this, d.legend);
            this.getStacks && this.getStacks();
            this.getMargins(!0);
            this.setChartSize();
            d = this.plotWidth;
            a.some(function (a) {
              if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return g = 21, !0;
            });
            var e = this.plotHeight = Math.max(this.plotHeight - g, 0);
            a.forEach(function (a) {
              a.setScale();
            });
            this.getAxisMargins();
            var f = 1.1 < d / this.plotWidth;
            var t = 1.05 < e / this.plotHeight;
            if (f || t) a.forEach(function (a) {
              (a.horiz && f || !a.horiz && t) && a.setTickInterval(!0);
            }), this.getMargins();
            this.drawChartBox();
            this.hasCartesianSeries ? k(a) : b && b.length && k(b);
            this.seriesGroup || (this.seriesGroup = c.g("series-group").attr({
              zIndex: 3
            }).add());
            this.renderSeries();
            this.renderLabels();
            this.addCredits();
            this.setResponsive && this.setResponsive();
            this.updateContainerScaling();
            this.hasRendered = !0;
          };

          f.prototype.addCredits = function (a) {
            var c = this,
                d = b(!0, this.options.credits, a);
            d.enabled && !this.credits && (this.credits = this.renderer.text(d.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
              d.href && (l.location.href = d.href);
            }).attr({
              align: d.position.align,
              zIndex: 8
            }), c.styledMode || this.credits.css(d.style), this.credits.add().align(d.position), this.credits.update = function (a) {
              c.credits = c.credits.destroy();
              c.addCredits(a);
            });
          };

          f.prototype.updateContainerScaling = function () {
            var a = this.container;

            if (2 < a.offsetWidth && 2 < a.offsetHeight && a.getBoundingClientRect) {
              var b = a.getBoundingClientRect(),
                  c = b.width / a.offsetWidth;
              a = b.height / a.offsetHeight;
              1 !== c || 1 !== a ? this.containerScaling = {
                scaleX: c,
                scaleY: a
              } : delete this.containerScaling;
            }
          };

          f.prototype.destroy = function () {
            var b = this,
                c = b.axes,
                d = b.series,
                g = b.container,
                k,
                e = g && g.parentNode;
            G(b, "destroy");
            b.renderer.forExport ? q(D, b) : D[b.index] = void 0;
            z.chartCount--;
            b.renderTo.removeAttribute("data-highcharts-chart");
            Z(b);

            for (k = c.length; k--;) c[k] = c[k].destroy();

            this.scroller && this.scroller.destroy && this.scroller.destroy();

            for (k = d.length; k--;) d[k] = d[k].destroy();

            "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function (a) {
              var c = b[a];
              c && c.destroy && (b[a] = c.destroy());
            });
            g && (g.innerHTML = "", Z(g), e && a(g));
            t(b, function (a, c) {
              delete b[c];
            });
          };

          f.prototype.firstRender = function () {
            var a = this,
                b = a.options;

            if (!a.isReadyToRender || a.isReadyToRender()) {
              a.getContainer();
              a.resetMargins();
              a.setChartSize();
              a.propFromSeries();
              a.getAxes();
              (T(b.series) ? b.series : []).forEach(function (b) {
                a.initSeries(b);
              });
              a.linkSeries();
              a.setSeriesData();
              G(a, "beforeRender");
              C && (a.pointer = z.hasTouch || !l.PointerEvent && !l.MSPointerEvent ? new C(a, b) : new L(a, b));
              a.render();
              if (!a.renderer.imgCount && !a.hasLoaded) a.onload();
              a.temporaryDisplay(!0);
            }
          };

          f.prototype.onload = function () {
            this.callbacks.concat([this.callback]).forEach(function (a) {
              a && "undefined" !== typeof this.index && a.apply(this, [this]);
            }, this);
            G(this, "load");
            G(this, "render");
            c(this.index) && this.setReflow(this.options.chart.reflow);
            this.hasLoaded = !0;
          };

          return f;
        }();

        W.prototype.callbacks = [];

        z.chart = function (a, b, c) {
          return new W(a, b, c);
        };

        return z.Chart = W;
      });
      N(m, "Extensions/ScrollablePlotArea.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Chart/Chart.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m, z) {
        var F = f.stop,
            L = z.addEvent,
            K = z.createElement,
            C = z.pick;
        "";
        L(h, "afterSetChartSize", function (f) {
          var e = this.options.chart.scrollablePlotArea,
              h = e && e.minWidth;
          e = e && e.minHeight;

          if (!this.renderer.forExport) {
            if (h) {
              if (this.scrollablePixelsX = h = Math.max(0, h - this.chartWidth)) {
                this.plotWidth += h;
                this.inverted ? (this.clipBox.height += h, this.plotBox.height += h) : (this.clipBox.width += h, this.plotBox.width += h);
                var v = {
                  1: {
                    name: "right",
                    value: h
                  }
                };
              }
            } else e && (this.scrollablePixelsY = h = Math.max(0, e - this.chartHeight)) && (this.plotHeight += h, this.inverted ? (this.clipBox.width += h, this.plotBox.width += h) : (this.clipBox.height += h, this.plotBox.height += h), v = {
              2: {
                name: "bottom",
                value: h
              }
            });

            v && !f.skipAxes && this.axes.forEach(function (e) {
              v[e.side] ? e.getPlotLinePath = function () {
                var f = v[e.side].name,
                    h = this[f];
                this[f] = h - v[e.side].value;
                var l = m.Axis.prototype.getPlotLinePath.apply(this, arguments);
                this[f] = h;
                return l;
              } : (e.setAxisSize(), e.setAxisTranslation());
            });
          }
        });
        L(h, "render", function () {
          this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
        });

        h.prototype.setUpScrolling = function () {
          var f = this,
              e = {
            WebkitOverflowScrolling: "touch",
            overflowX: "hidden",
            overflowY: "hidden"
          };
          this.scrollablePixelsX && (e.overflowX = "auto");
          this.scrollablePixelsY && (e.overflowY = "auto");
          this.scrollingParent = K("div", {
            className: "highcharts-scrolling-parent"
          }, {
            position: "relative"
          }, this.renderTo);
          this.scrollingContainer = K("div", {
            className: "highcharts-scrolling"
          }, e, this.scrollingParent);
          L(this.scrollingContainer, "scroll", function () {
            f.pointer && delete f.pointer.chartPosition;
          });
          this.innerContainer = K("div", {
            className: "highcharts-inner-container"
          }, null, this.scrollingContainer);
          this.innerContainer.appendChild(this.container);
          this.setUpScrolling = null;
        };

        h.prototype.moveFixedElements = function () {
          var f = this.container,
              e = this.fixedRenderer,
              h = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "),
              m;
          this.scrollablePixelsX && !this.inverted ? m = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? m = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? m = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (m = ".highcharts-yaxis");
          h.push(m, m + "-labels");
          h.forEach(function (h) {
            [].forEach.call(f.querySelectorAll(h), function (f) {
              (f.namespaceURI === e.SVG_NS ? e.box : e.box.parentNode).appendChild(f);
              f.style.pointerEvents = "auto";
            });
          });
        };

        h.prototype.applyFixed = function () {
          var f,
              e,
              h = !this.fixedDiv,
              v = this.options.chart.scrollablePlotArea;
          h ? (this.fixedDiv = K("div", {
            className: "highcharts-fixed"
          }, {
            position: "absolute",
            overflow: "hidden",
            pointerEvents: "none",
            zIndex: 2,
            top: 0
          }, null, !0), null === (f = this.scrollingContainer) || void 0 === f ? void 0 : f.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = f = new m.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, null === (e = this.options.chart) || void 0 === e ? void 0 : e.style), this.scrollableMask = f.path().attr({
            fill: this.options.chart.backgroundColor || "#fff",
            "fill-opacity": C(v.opacity, .85),
            zIndex: -1
          }).addClass("highcharts-scrollable-mask").add(), this.moveFixedElements(), L(this, "afterShowResetZoom", this.moveFixedElements), L(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
          e = this.chartWidth + (this.scrollablePixelsX || 0);
          f = this.chartHeight + (this.scrollablePixelsY || 0);
          F(this.container);
          this.container.style.width = e + "px";
          this.container.style.height = f + "px";
          this.renderer.boxWrapper.attr({
            width: e,
            height: f,
            viewBox: [0, 0, e, f].join(" ")
          });
          this.chartBackground.attr({
            width: e,
            height: f
          });
          this.scrollingContainer.style.height = this.chartHeight + "px";
          h && (v.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * v.scrollPositionX), v.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * v.scrollPositionY));
          f = this.axisOffset;
          h = this.plotTop - f[0] - 1;
          v = this.plotLeft - f[3] - 1;
          e = this.plotTop + this.plotHeight + f[2] + 1;
          f = this.plotLeft + this.plotWidth + f[1] + 1;
          var x = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),
              D = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
          h = this.scrollablePixelsX ? [["M", 0, h], ["L", this.plotLeft - 1, h], ["L", this.plotLeft - 1, e], ["L", 0, e], ["Z"], ["M", x, h], ["L", this.chartWidth, h], ["L", this.chartWidth, e], ["L", x, e], ["Z"]] : this.scrollablePixelsY ? [["M", v, 0], ["L", v, this.plotTop - 1], ["L", f, this.plotTop - 1], ["L", f, 0], ["Z"], ["M", v, D], ["L", v, this.chartHeight], ["L", f, this.chartHeight], ["L", f, D], ["Z"]] : [["M", 0, 0]];
          "adjustHeight" !== this.redrawTrigger && this.scrollableMask.attr({
            d: h
          });
        };
      });
      N(m, "Core/Axis/StackingAxis.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = f.getDeferredAnimation,
            z = h.addEvent,
            F = h.destroyObjectProperties,
            L = h.fireEvent,
            K = h.objectEach,
            C = h.pick,
            y = function () {
          function e(e) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = e;
          }

          e.prototype.buildStacks = function () {
            var e = this.axis,
                f = e.series,
                h = C(e.options.reversedStacks, !0),
                m = f.length,
                n;

            if (!e.isXAxis) {
              this.usePercentage = !1;

              for (n = m; n--;) {
                var l = f[h ? n : m - n - 1];
                l.setStackedPoints();
                l.setGroupedPoints();
              }

              for (n = 0; n < m; n++) f[n].modifyStacks();

              L(e, "afterBuildStacks");
            }
          };

          e.prototype.cleanStacks = function () {
            if (!this.axis.isXAxis) {
              if (this.oldStacks) var e = this.stacks = this.oldStacks;
              K(e, function (e) {
                K(e, function (e) {
                  e.cumulative = e.total;
                });
              });
            }
          };

          e.prototype.resetStacks = function () {
            var e = this,
                f = e.stacks;
            e.axis.isXAxis || K(f, function (f) {
              K(f, function (h, n) {
                h.touched < e.stacksTouched ? (h.destroy(), delete f[n]) : (h.total = null, h.cumulative = null);
              });
            });
          };

          e.prototype.renderStackTotals = function () {
            var e = this.axis,
                f = e.chart,
                h = f.renderer,
                D = this.stacks;
            e = m(f, e.options.stackLabels.animation);
            var n = this.stackTotalGroup = this.stackTotalGroup || h.g("stack-labels").attr({
              visibility: "visible",
              zIndex: 6,
              opacity: 0
            }).add();
            n.translate(f.plotLeft, f.plotTop);
            K(D, function (e) {
              K(e, function (e) {
                e.render(n);
              });
            });
            n.animate({
              opacity: 1
            }, e);
          };

          return e;
        }();

        return function () {
          function e() {}

          e.compose = function (f) {
            z(f, "init", e.onInit);
            z(f, "destroy", e.onDestroy);
          };

          e.onDestroy = function () {
            var e = this.stacking;

            if (e) {
              var f = e.stacks;
              K(f, function (e, h) {
                F(e);
                f[h] = null;
              });
              e && e.stackTotalGroup && e.stackTotalGroup.destroy();
            }
          };

          e.onInit = function () {
            this.stacking || (this.stacking = new y(this));
          };

          return e;
        }();
      });
      N(m, "Mixins/LegendSymbol.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.merge,
            z = h.pick;
        return f.LegendSymbolMixin = {
          drawRectangle: function drawRectangle(f, h) {
            var m = f.symbolHeight,
                C = f.options.squareSymbol;
            h.legendSymbol = this.chart.renderer.rect(C ? (f.symbolWidth - m) / 2 : 0, f.baseline - m + 1, C ? m : f.symbolWidth, m, z(f.options.symbolRadius, m / 2)).addClass("highcharts-point").attr({
              zIndex: 3
            }).add(h.legendGroup);
          },
          drawLineMarker: function drawLineMarker(f) {
            var h = this.options,
                F = h.marker,
                C = f.symbolWidth,
                y = f.symbolHeight,
                e = y / 2,
                I = this.chart.renderer,
                v = this.legendGroup;
            f = f.baseline - Math.round(.3 * f.fontMetrics.b);
            var x = {};
            this.chart.styledMode || (x = {
              "stroke-width": h.lineWidth || 0
            }, h.dashStyle && (x.dashstyle = h.dashStyle));
            this.legendLine = I.path([["M", 0, f], ["L", C, f]]).addClass("highcharts-graph").attr(x).add(v);
            F && !1 !== F.enabled && C && (h = Math.min(z(F.radius, e), e), 0 === this.symbol.indexOf("url") && (F = m(F, {
              width: y,
              height: y
            }), h = 0), this.legendSymbol = F = I.symbol(this.symbol, C / 2 - h, f - h, 2 * h, 2 * h, F).addClass("highcharts-point").add(v), F.isMarker = !0);
          }
        };
      });
      N(m, "Core/Series/CartesianSeries.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Series/Series.js"], m["Core/Globals.js"], m["Mixins/LegendSymbol.js"], m["Core/Options.js"], m["Core/Series/Point.js"], m["Core/Renderer/SVG/SVGElement.js"], m["Core/Utilities.js"]], function (f, h, m, z, F, L, K, C) {
        var y = f.animObject,
            e = F.defaultOptions,
            I = C.addEvent,
            v = C.arrayMax,
            x = C.arrayMin,
            D = C.clamp,
            n = C.correctFloat,
            l = C.defined,
            J = C.erase,
            w = C.error,
            r = C.extend,
            d = C.find,
            g = C.fireEvent,
            c = C.getNestedProperty,
            a = C.isArray,
            q = C.isFunction,
            p = C.isNumber,
            B = C.isString,
            A = C.merge,
            G = C.objectEach,
            M = C.pick,
            T = C.removeEvent,
            Q = C.splat,
            O = C.syncTimeout;
        "";
        var E = h.seriesTypes,
            u = m.win;
        f = h.seriesType("line", void 0, {
          lineWidth: 2,
          allowPointSelect: !1,
          crisp: !0,
          showCheckbox: !1,
          animation: {
            duration: 1E3
          },
          events: {},
          marker: {
            enabledThreshold: 2,
            lineColor: "#ffffff",
            lineWidth: 0,
            radius: 4,
            states: {
              normal: {
                animation: !0
              },
              hover: {
                animation: {
                  duration: 50
                },
                enabled: !0,
                radiusPlus: 2,
                lineWidthPlus: 1
              },
              select: {
                fillColor: "#cccccc",
                lineColor: "#000000",
                lineWidth: 2
              }
            }
          },
          point: {
            events: {}
          },
          dataLabels: {
            animation: {},
            align: "center",
            defer: !0,
            formatter: function formatter() {
              var a = this.series.chart.numberFormatter;
              return "number" !== typeof this.y ? "" : a(this.y, -1);
            },
            padding: 5,
            style: {
              fontSize: "11px",
              fontWeight: "bold",
              color: "contrast",
              textOutline: "1px contrast"
            },
            verticalAlign: "bottom",
            x: 0,
            y: 0
          },
          cropThreshold: 300,
          opacity: 1,
          pointRange: 0,
          softThreshold: !0,
          states: {
            normal: {
              animation: !0
            },
            hover: {
              animation: {
                duration: 50
              },
              lineWidthPlus: 1,
              marker: {},
              halo: {
                size: 10,
                opacity: .25
              }
            },
            select: {
              animation: {
                duration: 0
              }
            },
            inactive: {
              animation: {
                duration: 50
              },
              opacity: .2
            }
          },
          stickyTracking: !0,
          turboThreshold: 1E3,
          findNearestPointBy: "x"
        }, {
          axisTypes: ["xAxis", "yAxis"],
          coll: "series",
          colorCounter: 0,
          cropShoulder: 1,
          directTouch: !1,
          isCartesian: !0,
          parallelArrays: ["x", "y"],
          pointClass: L,
          requireSorting: !0,
          sorted: !0,
          init: function init(a, c) {
            g(this, "init", {
              options: c
            });
            var b = this,
                d = a.series,
                k;
            this.eventOptions = this.eventOptions || {};
            this.eventsToUnbind = [];
            b.chart = a;
            b.options = c = b.setOptions(c);
            b.linkedSeries = [];
            b.bindAxes();
            r(b, {
              name: c.name,
              state: "",
              visible: !1 !== c.visible,
              selected: !0 === c.selected
            });
            var e = c.events;
            G(e, function (a, c) {
              q(a) && b.eventOptions[c] !== a && (q(b.eventOptions[c]) && T(b, c, b.eventOptions[c]), b.eventOptions[c] = a, I(b, c, a));
            });
            if (e && e.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;
            b.getColor();
            b.getSymbol();
            b.parallelArrays.forEach(function (a) {
              b[a + "Data"] || (b[a + "Data"] = []);
            });
            b.isCartesian && (a.hasCartesianSeries = !0);
            d.length && (k = d[d.length - 1]);
            b._i = M(k && k._i, -1) + 1;
            b.opacity = b.options.opacity;
            a.orderSeries(this.insert(d));
            c.dataSorting && c.dataSorting.enabled ? b.setDataSortingOptions() : b.points || b.data || b.setData(c.data, !1);
            g(this, "afterInit");
          },
          is: function is(a) {
            return E[a] && this instanceof E[a];
          },
          insert: function insert(a) {
            var b = this.options.index,
                c;

            if (p(b)) {
              for (c = a.length; c--;) if (b >= M(a[c].options.index, a[c]._i)) {
                a.splice(c + 1, 0, this);
                break;
              }

              -1 === c && a.unshift(this);
              c += 1;
            } else a.push(this);

            return M(c, a.length - 1);
          },
          bindAxes: function bindAxes() {
            var a = this,
                c = a.options,
                d = a.chart,
                e;
            g(this, "bindAxes", null, function () {
              (a.axisTypes || []).forEach(function (b) {
                d[b].forEach(function (d) {
                  e = d.options;
                  if (c[b] === e.index || "undefined" !== typeof c[b] && c[b] === e.id || "undefined" === typeof c[b] && 0 === e.index) a.insert(d.series), a[b] = d, d.isDirty = !0;
                });
                a[b] || a.optionalAxis === b || w(18, !0, d);
              });
            });
            g(this, "afterBindAxes");
          },
          updateParallelArrays: function updateParallelArrays(a, c) {
            var b = a.series,
                d = arguments,
                g = p(c) ? function (d) {
              var g = "y" === d && b.toYData ? b.toYData(a) : a[d];
              b[d + "Data"][c] = g;
            } : function (a) {
              Array.prototype[c].apply(b[a + "Data"], Array.prototype.slice.call(d, 2));
            };
            b.parallelArrays.forEach(g);
          },
          hasData: function hasData() {
            return this.visible && "undefined" !== typeof this.dataMax && "undefined" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;
          },
          autoIncrement: function autoIncrement() {
            var a = this.options,
                c = this.xIncrement,
                d,
                g = a.pointIntervalUnit,
                e = this.chart.time;
            c = M(c, a.pointStart, 0);
            this.pointInterval = d = M(this.pointInterval, a.pointInterval, 1);
            g && (a = new e.Date(c), "day" === g ? e.set("Date", a, e.get("Date", a) + d) : "month" === g ? e.set("Month", a, e.get("Month", a) + d) : "year" === g && e.set("FullYear", a, e.get("FullYear", a) + d), d = a.getTime() - c);
            this.xIncrement = c + d;
            return c;
          },
          setDataSortingOptions: function setDataSortingOptions() {
            var a = this.options;
            r(this, {
              requireSorting: !1,
              sorted: !1,
              enabledDataSorting: !0,
              allowDG: !1
            });
            l(a.pointRange) || (a.pointRange = 1);
          },
          setOptions: function setOptions(a) {
            var b = this.chart,
                c = b.options,
                d = c.plotOptions,
                f = b.userOptions || {};
            a = A(a);
            b = b.styledMode;
            var p = {
              plotOptions: d,
              userOptions: a
            };
            g(this, "setOptions", p);
            var h = p.plotOptions[this.type],
                q = f.plotOptions || {};
            this.userOptions = p.userOptions;
            f = A(h, d.series, f.plotOptions && f.plotOptions[this.type], a);
            this.tooltipOptions = A(e.tooltip, e.plotOptions.series && e.plotOptions.series.tooltip, e.plotOptions[this.type].tooltip, c.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);
            this.stickyTracking = M(a.stickyTracking, q[this.type] && q[this.type].stickyTracking, q.series && q.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);
            null === h.marker && delete f.marker;
            this.zoneAxis = f.zoneAxis;
            c = this.zones = (f.zones || []).slice();
            !f.negativeColor && !f.negativeFillColor || f.zones || (d = {
              value: f[this.zoneAxis + "Threshold"] || f.threshold || 0,
              className: "highcharts-negative"
            }, b || (d.color = f.negativeColor, d.fillColor = f.negativeFillColor), c.push(d));
            c.length && l(c[c.length - 1].value) && c.push(b ? {} : {
              color: this.color,
              fillColor: this.fillColor
            });
            g(this, "afterSetOptions", {
              options: f
            });
            return f;
          },
          getName: function getName() {
            return M(this.options.name, "Series " + (this.index + 1));
          },
          getCyclic: function getCyclic(a, c, d) {
            var b = this.chart,
                g = this.userOptions,
                k = a + "Index",
                e = a + "Counter",
                f = d ? d.length : M(b.options.chart[a + "Count"], b[a + "Count"]);

            if (!c) {
              var p = M(g[k], g["_" + k]);
              l(p) || (b.series.length || (b[e] = 0), g["_" + k] = p = b[e] % f, b[e] += 1);
              d && (c = d[p]);
            }

            "undefined" !== typeof p && (this[k] = p);
            this[a] = c;
          },
          getColor: function getColor() {
            this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || e.plotOptions[this.type].color, this.chart.options.colors);
          },
          getPointsCollection: function getPointsCollection() {
            return (this.hasGroupedData ? this.points : this.data) || [];
          },
          getSymbol: function getSymbol() {
            this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
          },
          findPointIndex: function findPointIndex(a, c) {
            var b = a.id,
                g = a.x,
                k = this.points,
                e,
                f = this.options.dataSorting;
            if (b) var l = this.chart.get(b);else if (this.linkedParent || this.enabledDataSorting) {
              var h = f && f.matchByName ? "name" : "index";
              l = d(k, function (b) {
                return !b.touched && b[h] === a[h];
              });
              if (!l) return;
            }

            if (l) {
              var q = l && l.index;
              "undefined" !== typeof q && (e = !0);
            }

            "undefined" === typeof q && p(g) && (q = this.xData.indexOf(g, c));
            -1 !== q && "undefined" !== typeof q && this.cropped && (q = q >= this.cropStart ? q - this.cropStart : q);
            !e && k[q] && k[q].touched && (q = void 0);
            return q;
          },
          drawLegendSymbol: z.drawLineMarker,
          updateData: function updateData(a, c) {
            var b = this.options,
                d = b.dataSorting,
                g = this.points,
                k = [],
                e,
                f,
                h,
                q = this.requireSorting,
                n = a.length === g.length,
                u = !0;
            this.xIncrement = null;
            a.forEach(function (a, c) {
              var f = l(a) && this.pointClass.prototype.optionsToObject.call({
                series: this
              }, a) || {};
              var t = f.x;

              if (f.id || p(t)) {
                if (t = this.findPointIndex(f, h), -1 === t || "undefined" === typeof t ? k.push(a) : g[t] && a !== b.data[t] ? (g[t].update(a, !1, null, !1), g[t].touched = !0, q && (h = t + 1)) : g[t] && (g[t].touched = !0), !n || c !== t || d && d.enabled || this.hasDerivedData) e = !0;
              } else k.push(a);
            }, this);
            if (e) for (a = g.length; a--;) (f = g[a]) && !f.touched && f.remove && f.remove(!1, c);else !n || d && d.enabled ? u = !1 : (a.forEach(function (a, b) {
              g[b].update && a !== g[b].y && g[b].update(a, !1, null, !1);
            }), k.length = 0);
            g.forEach(function (a) {
              a && (a.touched = !1);
            });
            if (!u) return !1;
            k.forEach(function (a) {
              this.addPoint(a, !1, null, null, !1);
            }, this);
            null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = v(this.xData), this.autoIncrement());
            return !0;
          },
          setData: function setData(b, c, d, g) {
            var k = this,
                e = k.points,
                f = e && e.length || 0,
                t,
                l = k.options,
                h = k.chart,
                q = l.dataSorting,
                n = null,
                u = k.xAxis;
            n = l.turboThreshold;
            var r = this.xData,
                m = this.yData,
                A = (t = k.pointArrayMap) && t.length,
                v = l.keys,
                E = 0,
                H = 1,
                O;
            b = b || [];
            t = b.length;
            c = M(c, !0);
            q && q.enabled && (b = this.sortData(b));
            !1 !== g && t && f && !k.cropped && !k.hasGroupedData && k.visible && !k.isSeriesBoosting && (O = this.updateData(b, d));

            if (!O) {
              k.xIncrement = null;
              k.colorCounter = 0;
              this.parallelArrays.forEach(function (a) {
                k[a + "Data"].length = 0;
              });
              if (n && t > n) {
                if (n = k.getFirstValidPoint(b), p(n)) for (d = 0; d < t; d++) r[d] = this.autoIncrement(), m[d] = b[d];else if (a(n)) {
                  if (A) for (d = 0; d < t; d++) g = b[d], r[d] = g[0], m[d] = g.slice(1, A + 1);else for (v && (E = v.indexOf("x"), H = v.indexOf("y"), E = 0 <= E ? E : 0, H = 0 <= H ? H : 1), d = 0; d < t; d++) g = b[d], r[d] = g[E], m[d] = g[H];
                } else w(12, !1, h);
              } else for (d = 0; d < t; d++) "undefined" !== typeof b[d] && (g = {
                series: k
              }, k.pointClass.prototype.applyOptions.apply(g, [b[d]]), k.updateParallelArrays(g, d));
              m && B(m[0]) && w(14, !0, h);
              k.data = [];
              k.options.data = k.userOptions.data = b;

              for (d = f; d--;) e[d] && e[d].destroy && e[d].destroy();

              u && (u.minRange = u.userMinRange);
              k.isDirty = h.isDirtyBox = !0;
              k.isDirtyData = !!e;
              d = !1;
            }

            "point" === l.legendType && (this.processData(), this.generatePoints());
            c && h.redraw(d);
          },
          sortData: function sortData(a) {
            var b = this,
                d = b.options.dataSorting.sortKey || "y",
                g = function g(a, b) {
              return l(b) && a.pointClass.prototype.optionsToObject.call({
                series: a
              }, b) || {};
            };

            a.forEach(function (c, d) {
              a[d] = g(b, c);
              a[d].index = d;
            }, this);
            a.concat().sort(function (a, b) {
              a = c(d, a);
              b = c(d, b);
              return b < a ? -1 : b > a ? 1 : 0;
            }).forEach(function (a, b) {
              a.x = b;
            }, this);
            b.linkedSeries && b.linkedSeries.forEach(function (b) {
              var c = b.options,
                  d = c.data;
              c.dataSorting && c.dataSorting.enabled || !d || (d.forEach(function (c, k) {
                d[k] = g(b, c);
                a[k] && (d[k].x = a[k].x, d[k].index = k);
              }), b.setData(d, !1));
            });
            return a;
          },
          getProcessedData: function getProcessedData(a) {
            var b = this.xData,
                c = this.yData,
                d = b.length;
            var g = 0;
            var e = this.xAxis,
                f = this.options;
            var p = f.cropThreshold;
            var l = a || this.getExtremesFromAll || f.getExtremesFromAll,
                h = this.isCartesian;
            a = e && e.val2lin;
            f = !(!e || !e.logarithmic);
            var q = this.requireSorting;

            if (e) {
              e = e.getExtremes();
              var n = e.min;
              var u = e.max;
            }

            if (h && this.sorted && !l && (!p || d > p || this.forceCrop)) if (b[d - 1] < n || b[0] > u) b = [], c = [];else if (this.yData && (b[0] < n || b[d - 1] > u)) {
              g = this.cropData(this.xData, this.yData, n, u);
              b = g.xData;
              c = g.yData;
              g = g.start;
              var r = !0;
            }

            for (p = b.length || 1; --p;) if (d = f ? a(b[p]) - a(b[p - 1]) : b[p] - b[p - 1], 0 < d && ("undefined" === typeof m || d < m)) var m = d;else 0 > d && q && (w(15, !1, this.chart), q = !1);

            return {
              xData: b,
              yData: c,
              cropped: r,
              cropStart: g,
              closestPointRange: m
            };
          },
          processData: function processData(a) {
            var b = this.xAxis;
            if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;
            a = this.getProcessedData();
            this.cropped = a.cropped;
            this.cropStart = a.cropStart;
            this.processedXData = a.xData;
            this.processedYData = a.yData;
            this.closestPointRange = this.basePointRange = a.closestPointRange;
          },
          cropData: function cropData(a, c, d, g, e) {
            var b = a.length,
                k = 0,
                f = b,
                p;
            e = M(e, this.cropShoulder);

            for (p = 0; p < b; p++) if (a[p] >= d) {
              k = Math.max(0, p - e);
              break;
            }

            for (d = p; d < b; d++) if (a[d] > g) {
              f = d + e;
              break;
            }

            return {
              xData: a.slice(k, f),
              yData: c.slice(k, f),
              start: k,
              end: f
            };
          },
          generatePoints: function generatePoints() {
            var a = this.options,
                c = a.data,
                d = this.data,
                e,
                f = this.processedXData,
                p = this.processedYData,
                l = this.pointClass,
                h = f.length,
                q = this.cropStart || 0,
                n = this.hasGroupedData;
            a = a.keys;
            var u = [],
                m;
            d || n || (d = [], d.length = c.length, d = this.data = d);
            a && n && (this.options.keys = !1);

            for (m = 0; m < h; m++) {
              var w = q + m;

              if (n) {
                var v = new l().init(this, [f[m]].concat(Q(p[m])));
                v.dataGroup = this.groupMap[m];
                v.dataGroup.options && (v.options = v.dataGroup.options, r(v, v.dataGroup.options), delete v.dataLabels);
              } else (v = d[w]) || "undefined" === typeof c[w] || (d[w] = v = new l().init(this, c[w], f[m]));

              v && (v.index = w, u[m] = v);
            }

            this.options.keys = a;
            if (d && (h !== (e = d.length) || n)) for (m = 0; m < e; m++) m !== q || n || (m += h), d[m] && (d[m].destroyElements(), d[m].plotX = void 0);
            this.data = d;
            this.points = u;
            g(this, "afterGeneratePoints");
          },
          getXExtremes: function getXExtremes(a) {
            return {
              min: x(a),
              max: v(a)
            };
          },
          getExtremes: function getExtremes(b, c) {
            var d = this.xAxis,
                k = this.yAxis,
                e = this.processedXData || this.xData,
                f = [],
                l = 0,
                h = 0;
            var q = 0;
            var n = this.requireSorting ? this.cropShoulder : 0,
                u = k ? k.positiveValuesOnly : !1,
                r;
            b = b || this.stackedYData || this.processedYData || [];
            k = b.length;
            d && (q = d.getExtremes(), h = q.min, q = q.max);

            for (r = 0; r < k; r++) {
              var m = e[r];
              var w = b[r];
              var A = (p(w) || a(w)) && (w.length || 0 < w || !u);
              m = c || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !d || (e[r + n] || m) >= h && (e[r - n] || m) <= q;
              if (A && m) if (A = w.length) for (; A--;) p(w[A]) && (f[l++] = w[A]);else f[l++] = w;
            }

            b = {
              dataMin: x(f),
              dataMax: v(f)
            };
            g(this, "afterGetExtremes", {
              dataExtremes: b
            });
            return b;
          },
          applyExtremes: function applyExtremes() {
            var a = this.getExtremes();
            this.dataMin = a.dataMin;
            this.dataMax = a.dataMax;
            return a;
          },
          getFirstValidPoint: function getFirstValidPoint(a) {
            for (var b = null, c = a.length, d = 0; null === b && d < c;) b = a[d], d++;

            return b;
          },
          translate: function translate() {
            this.processedXData || this.processData();
            this.generatePoints();
            var b = this.options,
                c = b.stacking,
                d = this.xAxis,
                e = d.categories,
                f = this.enabledDataSorting,
                h = this.yAxis,
                q = this.points,
                u = q.length,
                r = !!this.modifyValue,
                m,
                w = this.pointPlacementToXValue(),
                v = !!w,
                A = b.threshold,
                B = b.startFromThreshold ? A : 0,
                E,
                O = this.zoneAxis || "y",
                G = Number.MAX_VALUE;

            for (m = 0; m < u; m++) {
              var x = q[m],
                  y = x.x,
                  z = x.y,
                  C = x.low,
                  J = c && h.stacking && h.stacking.stacks[(this.negStacks && z < (B ? 0 : A) ? "-" : "") + this.stackKey];
              if (h.positiveValuesOnly && !h.validatePositiveValue(z) || d.positiveValuesOnly && !d.validatePositiveValue(y)) x.isNull = !0;
              x.plotX = E = n(D(d.translate(y, 0, 0, 0, 1, w, "flags" === this.type), -1E5, 1E5));

              if (c && this.visible && J && J[y]) {
                var F = this.getStackIndicator(F, y, this.index);

                if (!x.isNull) {
                  var Q = J[y];
                  var I = Q.points[F.key];
                }
              }

              a(I) && (C = I[0], z = I[1], C === B && F.key === J[y].base && (C = M(p(A) && A, h.min)), h.positiveValuesOnly && 0 >= C && (C = null), x.total = x.stackTotal = Q.total, x.percentage = Q.total && x.y / Q.total * 100, x.stackY = z, this.irregularWidths || Q.setOffset(this.pointXOffset || 0, this.barW || 0));
              x.yBottom = l(C) ? D(h.translate(C, 0, 1, 0, 1), -1E5, 1E5) : null;
              r && (z = this.modifyValue(z, x));
              x.plotY = "number" === typeof z && Infinity !== z ? D(h.translate(z, 0, 1, 0, 1), -1E5, 1E5) : void 0;
              x.isInside = this.isPointInside(x);
              x.clientX = v ? n(d.translate(y, 0, 0, 0, 1, w)) : E;
              x.negative = x[O] < (b[O + "Threshold"] || A || 0);
              x.category = e && "undefined" !== typeof e[x.x] ? e[x.x] : x.x;

              if (!x.isNull && !1 !== x.visible) {
                "undefined" !== typeof K && (G = Math.min(G, Math.abs(E - K)));
                var K = E;
              }

              x.zone = this.zones.length && x.getZone();
              !x.graphic && this.group && f && (x.isNew = !0);
            }

            this.closestPointRangePx = G;
            g(this, "afterTranslate");
          },
          getValidPoints: function getValidPoints(a, c, d) {
            var b = this.chart;
            return (a || this.points || []).filter(function (a) {
              return c && !b.isInsidePlot(a.plotX, a.plotY, b.inverted) ? !1 : !1 !== a.visible && (d || !a.isNull);
            });
          },
          getClipBox: function getClipBox(a, c) {
            var b = this.options,
                d = this.chart,
                g = d.inverted,
                k = this.xAxis,
                e = k && this.yAxis,
                f = d.options.chart.scrollablePlotArea || {};
            a && !1 === b.clip && e ? a = g ? {
              y: -d.chartWidth + e.len + e.pos,
              height: d.chartWidth,
              width: d.chartHeight,
              x: -d.chartHeight + k.len + k.pos
            } : {
              y: -e.pos,
              height: d.chartHeight,
              width: d.chartWidth,
              x: -k.pos
            } : (a = this.clipBox || d.clipBox, c && (a.width = d.plotSizeX, a.x = (d.scrollablePixelsX || 0) * (f.scrollPositionX || 0)));
            return c ? {
              width: a.width,
              x: a.x
            } : a;
          },
          setClip: function setClip(a) {
            var b = this.chart,
                c = this.options,
                d = b.renderer,
                g = b.inverted,
                e = this.clipBox,
                f = this.getClipBox(a),
                p = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, f.height, c.xAxis, c.yAxis].join(),
                l = b[p],
                h = b[p + "m"];
            a && (f.width = 0, g && (f.x = b.plotHeight + (!1 !== c.clip ? 0 : b.plotTop)));
            l ? b.hasLoaded || l.attr(f) : (a && (b[p + "m"] = h = d.clipRect(g ? b.plotSizeX + 99 : -99, g ? -b.plotLeft : -b.plotTop, 99, g ? b.chartWidth : b.chartHeight)), b[p] = l = d.clipRect(f), l.count = {
              length: 0
            });
            a && !l.count[this.index] && (l.count[this.index] = !0, l.count.length += 1);
            if (!1 !== c.clip || a) this.group.clip(a || e ? l : b.clipRect), this.markerGroup.clip(h), this.sharedClipKey = p;
            a || (l.count[this.index] && (delete l.count[this.index], --l.count.length), 0 === l.count.length && p && b[p] && (e || (b[p] = b[p].destroy()), b[p + "m"] && (b[p + "m"] = b[p + "m"].destroy())));
          },
          animate: function animate(a) {
            var b = this.chart,
                c = y(this.options.animation);
            if (!b.hasRendered) if (a) this.setClip(c);else {
              var d = this.sharedClipKey;
              a = b[d];
              var g = this.getClipBox(c, !0);
              a && a.animate(g, c);
              b[d + "m"] && b[d + "m"].animate({
                width: g.width + 99,
                x: g.x - (b.inverted ? 0 : 99)
              }, c);
            }
          },
          afterAnimate: function afterAnimate() {
            this.setClip();
            g(this, "afterAnimate");
            this.finishedAnimating = !0;
          },
          drawPoints: function drawPoints() {
            var a = this.points,
                c = this.chart,
                d,
                g,
                e = this.options.marker,
                f = this[this.specialGroup] || this.markerGroup,
                p = this.xAxis,
                l = M(e.enabled, !p || p.isRadial ? !0 : null, this.closestPointRangePx >= e.enabledThreshold * e.radius);
            if (!1 !== e.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {
              var h = a[d];
              var q = (g = h.graphic) ? "animate" : "attr";
              var n = h.marker || {};
              var u = !!h.marker;

              if ((l && "undefined" === typeof n.enabled || n.enabled) && !h.isNull && !1 !== h.visible) {
                var r = M(n.symbol, this.symbol);
                var m = this.markerAttribs(h, h.selected && "select");
                this.enabledDataSorting && (h.startXPos = p.reversed ? -m.width : p.width);
                var w = !1 !== h.isInside;
                g ? g[w ? "show" : "hide"](w).animate(m) : w && (0 < m.width || h.hasImage) && (h.graphic = g = c.renderer.symbol(r, m.x, m.y, m.width, m.height, u ? n : e).add(f), this.enabledDataSorting && c.hasRendered && (g.attr({
                  x: h.startXPos
                }), q = "animate"));
                g && "animate" === q && g[w ? "show" : "hide"](w).animate(m);
                if (g && !c.styledMode) g[q](this.pointAttribs(h, h.selected && "select"));
                g && g.addClass(h.getClassName(), !0);
              } else g && (h.graphic = g.destroy());
            }
          },
          markerAttribs: function markerAttribs(a, c) {
            var b = this.options,
                d = b.marker,
                g = a.marker || {},
                e = g.symbol || d.symbol,
                k = M(g.radius, d.radius);
            c && (d = d.states[c], c = g.states && g.states[c], k = M(c && c.radius, d && d.radius, k + (d && d.radiusPlus || 0)));
            a.hasImage = e && 0 === e.indexOf("url");
            a.hasImage && (k = 0);
            a = {
              x: b.crisp ? Math.floor(a.plotX) - k : a.plotX - k,
              y: a.plotY - k
            };
            k && (a.width = a.height = 2 * k);
            return a;
          },
          pointAttribs: function pointAttribs(a, c) {
            var b = this.options.marker,
                d = a && a.options,
                g = d && d.marker || {},
                e = this.color,
                k = d && d.color,
                f = a && a.color;
            d = M(g.lineWidth, b.lineWidth);
            var p = a && a.zone && a.zone.color;
            a = 1;
            e = k || p || f || e;
            k = g.fillColor || b.fillColor || e;
            e = g.lineColor || b.lineColor || e;
            c = c || "normal";
            b = b.states[c];
            c = g.states && g.states[c] || {};
            d = M(c.lineWidth, b.lineWidth, d + M(c.lineWidthPlus, b.lineWidthPlus, 0));
            k = c.fillColor || b.fillColor || k;
            e = c.lineColor || b.lineColor || e;
            a = M(c.opacity, b.opacity, a);
            return {
              stroke: e,
              "stroke-width": d,
              fill: k,
              opacity: a
            };
          },
          destroy: function destroy(a) {
            var b = this,
                c = b.chart,
                d = /AppleWebKit\/533/.test(u.navigator.userAgent),
                e,
                f,
                p = b.data || [],
                h,
                l;
            g(b, "destroy");
            this.removeEvents(a);
            (b.axisTypes || []).forEach(function (a) {
              (l = b[a]) && l.series && (J(l.series, b), l.isDirty = l.forceRedraw = !0);
            });
            b.legendItem && b.chart.legend.destroyItem(b);

            for (f = p.length; f--;) (h = p[f]) && h.destroy && h.destroy();

            b.points = null;
            C.clearTimeout(b.animationTimeout);
            G(b, function (a, b) {
              a instanceof K && !a.survive && (e = d && "group" === b ? "hide" : "destroy", a[e]());
            });
            c.hoverSeries === b && (c.hoverSeries = null);
            J(c.series, b);
            c.orderSeries();
            G(b, function (c, d) {
              a && "hcEvents" === d || delete b[d];
            });
          },
          getGraphPath: function getGraphPath(a, c, d) {
            var b = this,
                g = b.options,
                e = g.step,
                k,
                f = [],
                p = [],
                h;
            a = a || b.points;
            (k = a.reversed) && a.reverse();
            (e = {
              right: 1,
              center: 2
            }[e] || e && 3) && k && (e = 4 - e);
            a = this.getValidPoints(a, !1, !(g.connectNulls && !c && !d));
            a.forEach(function (k, q) {
              var t = k.plotX,
                  n = k.plotY,
                  u = a[q - 1];
              (k.leftCliff || u && u.rightCliff) && !d && (h = !0);
              k.isNull && !l(c) && 0 < q ? h = !g.connectNulls : k.isNull && !c ? h = !0 : (0 === q || h ? q = [["M", k.plotX, k.plotY]] : b.getPointSpline ? q = [b.getPointSpline(a, k, q)] : e ? (q = 1 === e ? [["L", u.plotX, n]] : 2 === e ? [["L", (u.plotX + t) / 2, u.plotY], ["L", (u.plotX + t) / 2, n]] : [["L", t, u.plotY]], q.push(["L", t, n])) : q = [["L", t, n]], p.push(k.x), e && (p.push(k.x), 2 === e && p.push(k.x)), f.push.apply(f, q), h = !1);
            });
            f.xMap = p;
            return b.graphPath = f;
          },
          drawGraph: function drawGraph() {
            var a = this,
                c = this.options,
                d = (this.gappedPath || this.getGraphPath).call(this),
                g = this.chart.styledMode,
                e = [["graph", "highcharts-graph"]];
            g || e[0].push(c.lineColor || this.color || "#cccccc", c.dashStyle);
            e = a.getZonesGraphs(e);
            e.forEach(function (b, e) {
              var k = b[0],
                  f = a[k],
                  p = f ? "animate" : "attr";
              f ? (f.endX = a.preventGraphAnimation ? null : d.xMap, f.animate({
                d: d
              })) : d.length && (a[k] = f = a.chart.renderer.path(d).addClass(b[1]).attr({
                zIndex: 1
              }).add(a.group));
              f && !g && (k = {
                stroke: b[2],
                "stroke-width": c.lineWidth,
                fill: a.fillGraph && a.color || "none"
              }, b[3] ? k.dashstyle = b[3] : "square" !== c.linecap && (k["stroke-linecap"] = k["stroke-linejoin"] = "round"), f[p](k).shadow(2 > e && c.shadow));
              f && (f.startX = d.xMap, f.isArea = d.isArea);
            });
          },
          getZonesGraphs: function getZonesGraphs(a) {
            this.zones.forEach(function (b, c) {
              c = ["zone-graph-" + c, "highcharts-graph highcharts-zone-graph-" + c + " " + (b.className || "")];
              this.chart.styledMode || c.push(b.color || this.color, b.dashStyle || this.options.dashStyle);
              a.push(c);
            }, this);
            return a;
          },
          applyZones: function applyZones() {
            var a = this,
                c = this.chart,
                d = c.renderer,
                g = this.zones,
                e,
                f,
                p = this.clips || [],
                h,
                l = this.graph,
                q = this.area,
                n = Math.max(c.chartWidth, c.chartHeight),
                u = this[(this.zoneAxis || "y") + "Axis"],
                r = c.inverted,
                m,
                w,
                v,
                A = !1,
                B,
                E;

            if (g.length && (l || q) && u && "undefined" !== typeof u.min) {
              var O = u.reversed;
              var G = u.horiz;
              l && !this.showLine && l.hide();
              q && q.hide();
              var x = u.getExtremes();
              g.forEach(function (b, g) {
                e = O ? G ? c.plotWidth : 0 : G ? 0 : u.toPixels(x.min) || 0;
                e = D(M(f, e), 0, n);
                f = D(Math.round(u.toPixels(M(b.value, x.max), !0) || 0), 0, n);
                A && (e = f = u.toPixels(x.max));
                m = Math.abs(e - f);
                w = Math.min(e, f);
                v = Math.max(e, f);
                u.isXAxis ? (h = {
                  x: r ? v : w,
                  y: 0,
                  width: m,
                  height: n
                }, G || (h.x = c.plotHeight - h.x)) : (h = {
                  x: 0,
                  y: r ? v : w,
                  width: n,
                  height: m
                }, G && (h.y = c.plotWidth - h.y));
                r && d.isVML && (h = u.isXAxis ? {
                  x: 0,
                  y: O ? w : v,
                  height: h.width,
                  width: c.chartWidth
                } : {
                  x: h.y - c.plotLeft - c.spacingBox.x,
                  y: 0,
                  width: h.height,
                  height: c.chartHeight
                });
                p[g] ? p[g].animate(h) : p[g] = d.clipRect(h);
                B = a["zone-area-" + g];
                E = a["zone-graph-" + g];
                l && E && E.clip(p[g]);
                q && B && B.clip(p[g]);
                A = b.value > x.max;
                a.resetZones && 0 === f && (f = void 0);
              });
              this.clips = p;
            } else a.visible && (l && l.show(!0), q && q.show(!0));
          },
          invertGroups: function invertGroups(a) {
            function b() {
              ["group", "markerGroup"].forEach(function (b) {
                c[b] && (d.renderer.isVML && c[b].attr({
                  width: c.yAxis.len,
                  height: c.xAxis.len
                }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));
              });
            }

            var c = this,
                d = c.chart;
            c.xAxis && (c.eventsToUnbind.push(I(d, "resize", b)), b(), c.invertGroups = b);
          },
          plotGroup: function plotGroup(a, c, d, g, e) {
            var b = this[a],
                k = !b;
            d = {
              visibility: d,
              zIndex: g || .1
            };
            "undefined" === typeof this.opacity || this.chart.styledMode || "inactive" === this.state || (d.opacity = this.opacity);
            k && (this[a] = b = this.chart.renderer.g().add(e));
            b.addClass("highcharts-" + c + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (l(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (b.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0);
            b.attr(d)[k ? "attr" : "animate"](this.getPlotBox());
            return b;
          },
          getPlotBox: function getPlotBox() {
            var a = this.chart,
                c = this.xAxis,
                d = this.yAxis;
            a.inverted && (c = d, d = this.xAxis);
            return {
              translateX: c ? c.left : a.plotLeft,
              translateY: d ? d.top : a.plotTop,
              scaleX: 1,
              scaleY: 1
            };
          },
          removeEvents: function removeEvents(a) {
            a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {
              a();
            }), this.eventsToUnbind.length = 0) : T(this);
          },
          render: function render() {
            var a = this,
                c = a.chart,
                d = a.options,
                e = y(d.animation),
                f = !a.finishedAnimating && c.renderer.isSVG && e.duration,
                p = a.visible ? "inherit" : "hidden",
                h = d.zIndex,
                l = a.hasRendered,
                q = c.seriesGroup,
                n = c.inverted;
            g(this, "render");
            var u = a.plotGroup("group", "series", p, h, q);
            a.markerGroup = a.plotGroup("markerGroup", "markers", p, h, q);
            f && a.animate && a.animate(!0);
            u.inverted = a.isCartesian || a.invertable ? n : !1;
            a.drawGraph && (a.drawGraph(), a.applyZones());
            a.visible && a.drawPoints();
            a.drawDataLabels && a.drawDataLabels();
            a.redrawPoints && a.redrawPoints();
            a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();
            a.invertGroups(n);
            !1 === d.clip || a.sharedClipKey || l || u.clip(c.clipRect);
            f && a.animate && a.animate();
            l || (f && e.defer && (f += e.defer), a.animationTimeout = O(function () {
              a.afterAnimate();
            }, f || 0));
            a.isDirty = !1;
            a.hasRendered = !0;
            g(a, "afterRender");
          },
          redraw: function redraw() {
            var a = this.chart,
                c = this.isDirty || this.isDirtyData,
                d = this.group,
                g = this.xAxis,
                e = this.yAxis;
            d && (a.inverted && d.attr({
              width: a.plotWidth,
              height: a.plotHeight
            }), d.animate({
              translateX: M(g && g.left, a.plotLeft),
              translateY: M(e && e.top, a.plotTop)
            }));
            this.translate();
            this.render();
            c && delete this.kdTree;
          },
          kdAxisArray: ["clientX", "plotY"],
          searchPoint: function searchPoint(a, c) {
            var b = this.xAxis,
                d = this.yAxis,
                g = this.chart.inverted;
            return this.searchKDTree({
              clientX: g ? b.len - a.chartY + b.pos : a.chartX - b.pos,
              plotY: g ? d.len - a.chartX + d.pos : a.chartY - d.pos
            }, c, a);
          },
          buildKDTree: function buildKDTree(a) {
            function b(a, d, g) {
              var e;

              if (e = a && a.length) {
                var f = c.kdAxisArray[d % g];
                a.sort(function (a, b) {
                  return a[f] - b[f];
                });
                e = Math.floor(e / 2);
                return {
                  point: a[e],
                  left: b(a.slice(0, e), d + 1, g),
                  right: b(a.slice(e + 1), d + 1, g)
                };
              }
            }

            this.buildingKdTree = !0;
            var c = this,
                d = -1 < c.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            delete c.kdTree;
            O(function () {
              c.kdTree = b(c.getValidPoints(null, !c.directTouch), d, d);
              c.buildingKdTree = !1;
            }, c.options.kdNow || a && "touchstart" === a.type ? 0 : 1);
          },
          searchKDTree: function searchKDTree(a, c, d) {
            function b(a, c, d, p) {
              var h = c.point,
                  q = g.kdAxisArray[d % p],
                  n = h;
              var u = l(a[e]) && l(h[e]) ? Math.pow(a[e] - h[e], 2) : null;
              var t = l(a[f]) && l(h[f]) ? Math.pow(a[f] - h[f], 2) : null;
              t = (u || 0) + (t || 0);
              h.dist = l(t) ? Math.sqrt(t) : Number.MAX_VALUE;
              h.distX = l(u) ? Math.sqrt(u) : Number.MAX_VALUE;
              q = a[q] - h[q];
              t = 0 > q ? "left" : "right";
              u = 0 > q ? "right" : "left";
              c[t] && (t = b(a, c[t], d + 1, p), n = t[k] < n[k] ? t : h);
              c[u] && Math.sqrt(q * q) < n[k] && (a = b(a, c[u], d + 1, p), n = a[k] < n[k] ? a : n);
              return n;
            }

            var g = this,
                e = this.kdAxisArray[0],
                f = this.kdAxisArray[1],
                k = c ? "distX" : "dist";
            c = -1 < g.options.findNearestPointBy.indexOf("y") ? 2 : 1;
            this.kdTree || this.buildingKdTree || this.buildKDTree(d);
            if (this.kdTree) return b(a, this.kdTree, c, c);
          },
          pointPlacementToXValue: function pointPlacementToXValue() {
            var a = this.options,
                c = a.pointRange,
                d = this.xAxis;
            a = a.pointPlacement;
            "between" === a && (a = d.reversed ? -.5 : .5);
            return p(a) ? a * M(c, d.pointRange) : 0;
          },
          isPointInside: function isPointInside(a) {
            return "undefined" !== typeof a.plotY && "undefined" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;
          }
        });
        "";
        return f;
      });
      N(m, "Series/LineSeries.js", [m["Core/Series/CartesianSeries.js"], m["Core/Globals.js"]], function (f, h) {
        h.Series = f;
        return h.Series;
      });
      N(m, "Extensions/Stacking.js", [m["Core/Axis/Axis.js"], m["Core/Chart/Chart.js"], m["Core/Globals.js"], m["Core/Axis/StackingAxis.js"], m["Core/Utilities.js"]], function (f, h, m, z, F) {
        var L = F.correctFloat,
            K = F.defined,
            C = F.destroyObjectProperties,
            y = F.format,
            e = F.isNumber,
            I = F.pick;
        "";

        var v = m.Series,
            x = function () {
          function f(e, f, h, m, r) {
            var d = e.chart.inverted;
            this.axis = e;
            this.isNegative = h;
            this.options = f = f || {};
            this.x = m;
            this.total = null;
            this.points = {};
            this.hasValidPoints = !1;
            this.stack = r;
            this.rightCliff = this.leftCliff = 0;
            this.alignOptions = {
              align: f.align || (d ? h ? "left" : "right" : "center"),
              verticalAlign: f.verticalAlign || (d ? "middle" : h ? "bottom" : "top"),
              y: f.y,
              x: f.x
            };
            this.textAlign = f.textAlign || (d ? h ? "right" : "left" : "center");
          }

          f.prototype.destroy = function () {
            C(this, this.axis);
          };

          f.prototype.render = function (e) {
            var f = this.axis.chart,
                h = this.options,
                n = h.format;
            n = n ? y(n, this, f) : h.formatter.call(this);
            this.label ? this.label.attr({
              text: n,
              visibility: "hidden"
            }) : (this.label = f.renderer.label(n, null, null, h.shape, null, null, h.useHTML, !1, "stack-labels"), n = {
              r: h.borderRadius || 0,
              text: n,
              rotation: h.rotation,
              padding: I(h.padding, 5),
              visibility: "hidden"
            }, f.styledMode || (n.fill = h.backgroundColor, n.stroke = h.borderColor, n["stroke-width"] = h.borderWidth, this.label.css(h.style)), this.label.attr(n), this.label.added || this.label.add(e));
            this.label.labelrank = f.plotHeight;
          };

          f.prototype.setOffset = function (f, h, m, w, r) {
            var d = this.axis,
                g = d.chart;
            w = d.translate(d.stacking.usePercentage ? 100 : w ? w : this.total, 0, 0, 0, 1);
            m = d.translate(m ? m : 0);
            m = K(w) && Math.abs(w - m);
            f = I(r, g.xAxis[0].translate(this.x)) + f;
            d = K(w) && this.getStackBox(g, this, f, w, h, m, d);
            h = this.label;
            m = this.isNegative;
            f = "justify" === I(this.options.overflow, "justify");
            var c = this.textAlign;
            h && d && (r = h.getBBox(), w = h.padding, c = "left" === c ? g.inverted ? -w : w : "right" === c ? r.width : g.inverted && "center" === c ? r.width / 2 : g.inverted ? m ? r.width + w : -w : r.width / 2, m = g.inverted ? r.height / 2 : m ? -w : r.height, this.alignOptions.x = I(this.options.x, 0), this.alignOptions.y = I(this.options.y, 0), d.x -= c, d.y -= m, h.align(this.alignOptions, null, d), g.isInsidePlot(h.alignAttr.x + c - this.alignOptions.x, h.alignAttr.y + m - this.alignOptions.y) ? h.show() : (h.alignAttr.y = -9999, f = !1), f && v.prototype.justifyDataLabel.call(this.axis, h, this.alignOptions, h.alignAttr, r, d), h.attr({
              x: h.alignAttr.x,
              y: h.alignAttr.y
            }), I(!f && this.options.crop, !0) && ((g = e(h.x) && e(h.y) && g.isInsidePlot(h.x - w + h.width, h.y) && g.isInsidePlot(h.x + w, h.y)) || h.hide()));
          };

          f.prototype.getStackBox = function (e, f, h, m, r, d, g) {
            var c = f.axis.reversed,
                a = e.inverted,
                q = g.height + g.pos - (a ? e.plotLeft : e.plotTop);
            f = f.isNegative && !c || !f.isNegative && c;
            return {
              x: a ? f ? m - g.right : m - d + g.pos - e.plotLeft : h + e.xAxis[0].transB - e.plotLeft,
              y: a ? g.height - h - r : f ? q - m - d : q - m,
              width: a ? d : r,
              height: a ? r : d
            };
          };

          return f;
        }();

        h.prototype.getStacks = function () {
          var e = this,
              f = e.inverted;
          e.yAxis.forEach(function (e) {
            e.stacking && e.stacking.stacks && e.hasVisibleSeries && (e.stacking.oldStacks = e.stacking.stacks);
          });
          e.series.forEach(function (h) {
            var l = h.xAxis && h.xAxis.options || {};
            !h.options.stacking || !0 !== h.visible && !1 !== e.options.chart.ignoreHiddenSeries || (h.stackKey = [h.type, I(h.options.stack, ""), f ? l.top : l.left, f ? l.height : l.width].join());
          });
        };

        z.compose(f);

        v.prototype.setGroupedPoints = function () {
          this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length && v.prototype.setStackedPoints.call(this, "group");
        };

        v.prototype.setStackedPoints = function (e) {
          var f = e || this.options.stacking;

          if (f && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
            var h = this.processedXData,
                m = this.processedYData,
                w = [],
                r = m.length,
                d = this.options,
                g = d.threshold,
                c = I(d.startFromThreshold && g, 0);
            d = d.stack;
            e = e ? this.type + "," + f : this.stackKey;
            var a = "-" + e,
                q = this.negStacks,
                p = this.yAxis,
                v = p.stacking.stacks,
                A = p.stacking.oldStacks,
                G,
                D;
            p.stacking.stacksTouched += 1;

            for (D = 0; D < r; D++) {
              var y = h[D];
              var z = m[D];
              var O = this.getStackIndicator(O, y, this.index);
              var E = O.key;
              var u = (G = q && z < (c ? 0 : g)) ? a : e;
              v[u] || (v[u] = {});
              v[u][y] || (A[u] && A[u][y] ? (v[u][y] = A[u][y], v[u][y].total = null) : v[u][y] = new x(p, p.options.stackLabels, G, y, d));
              u = v[u][y];
              null !== z ? (u.points[E] = u.points[this.index] = [I(u.cumulative, c)], K(u.cumulative) || (u.base = E), u.touched = p.stacking.stacksTouched, 0 < O.index && !1 === this.singleStacks && (u.points[E][0] = u.points[this.index + "," + y + ",0"][0])) : u.points[E] = u.points[this.index] = null;
              "percent" === f ? (G = G ? e : a, q && v[G] && v[G][y] ? (G = v[G][y], u.total = G.total = Math.max(G.total, u.total) + Math.abs(z) || 0) : u.total = L(u.total + (Math.abs(z) || 0))) : "group" === f ? null !== z && (u.total = (u.total || 0) + 1) : u.total = L(u.total + (z || 0));
              u.cumulative = "group" === f ? (u.total || 1) - 1 : I(u.cumulative, c) + (z || 0);
              null !== z && (u.points[E].push(u.cumulative), w[D] = u.cumulative, u.hasValidPoints = !0);
            }

            "percent" === f && (p.stacking.usePercentage = !0);
            "group" !== f && (this.stackedYData = w);
            p.stacking.oldStacks = {};
          }
        };

        v.prototype.modifyStacks = function () {
          var e = this,
              f = e.stackKey,
              h = e.yAxis.stacking.stacks,
              m = e.processedXData,
              w,
              r = e.options.stacking;
          e[r + "Stacker"] && [f, "-" + f].forEach(function (d) {
            for (var g = m.length, c, a; g--;) if (c = m[g], w = e.getStackIndicator(w, c, e.index, d), a = (c = h[d] && h[d][c]) && c.points[w.key]) e[r + "Stacker"](a, c, g);
          });
        };

        v.prototype.percentStacker = function (e, f, h) {
          f = f.total ? 100 / f.total : 0;
          e[0] = L(e[0] * f);
          e[1] = L(e[1] * f);
          this.stackedYData[h] = e[1];
        };

        v.prototype.getStackIndicator = function (e, f, h, m) {
          !K(e) || e.x !== f || m && e.key !== m ? e = {
            x: f,
            index: 0,
            key: m
          } : e.index++;
          e.key = [h, f, e.index].join();
          return e;
        };

        m.StackItem = x;
        return m.StackItem;
      });
      N(m, "Core/Dynamics.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Axis/Axis.js"], m["Core/Series/Series.js"], m["Core/Chart/Chart.js"], m["Core/Globals.js"], m["Series/LineSeries.js"], m["Core/Options.js"], m["Core/Series/Point.js"], m["Core/Time.js"], m["Core/Utilities.js"]], function (f, h, m, z, F, L, K, C, y, e) {
        var I = f.animate,
            v = f.setAnimation,
            x = m.seriesTypes,
            D = K.time,
            n = e.addEvent,
            l = e.createElement,
            J = e.css,
            w = e.defined,
            r = e.erase,
            d = e.error,
            g = e.extend,
            c = e.fireEvent,
            a = e.isArray,
            q = e.isNumber,
            p = e.isObject,
            B = e.isString,
            A = e.merge,
            G = e.objectEach,
            M = e.pick,
            T = e.relativeLength,
            Q = e.splat;

        F.cleanRecursively = function (a, c) {
          var d = {};
          G(a, function (b, g) {
            if (p(a[g], !0) && !a.nodeType && c[g]) b = F.cleanRecursively(a[g], c[g]), Object.keys(b).length && (d[g] = b);else if (p(a[g]) || a[g] !== c[g]) d[g] = a[g];
          });
          return d;
        };

        g(z.prototype, {
          addSeries: function addSeries(a, d, g) {
            var b,
                e = this;
            a && (d = M(d, !0), c(e, "addSeries", {
              options: a
            }, function () {
              b = e.initSeries(a);
              e.isDirtyLegend = !0;
              e.linkSeries();
              b.enabledDataSorting && b.setData(a.data, !1);
              c(e, "afterAddSeries", {
                series: b
              });
              d && e.redraw(g);
            }));
            return b;
          },
          addAxis: function addAxis(a, c, d, b) {
            return this.createAxis(c ? "xAxis" : "yAxis", {
              axis: a,
              redraw: d,
              animation: b
            });
          },
          addColorAxis: function addColorAxis(a, c, d) {
            return this.createAxis("colorAxis", {
              axis: a,
              redraw: c,
              animation: d
            });
          },
          createAxis: function createAxis(a, c) {
            var d = this.options,
                b = "colorAxis" === a,
                g = c.redraw,
                e = c.animation;
            c = A(c.axis, {
              index: this[a].length,
              isX: "xAxis" === a
            });
            var f = b ? new F.ColorAxis(this, c) : new h(this, c);
            d[a] = Q(d[a] || {});
            d[a].push(c);
            b && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {
              a.series = [];
            }), this.series.forEach(function (a) {
              a.bindAxes();
              a.isDirtyData = !0;
            }));
            M(g, !0) && this.redraw(e);
            return f;
          },
          showLoading: function showLoading(a) {
            var c = this,
                d = c.options,
                b = c.loadingDiv,
                e = d.loading,
                f = function f() {
              b && J(b, {
                left: c.plotLeft + "px",
                top: c.plotTop + "px",
                width: c.plotWidth + "px",
                height: c.plotHeight + "px"
              });
            };

            b || (c.loadingDiv = b = l("div", {
              className: "highcharts-loading highcharts-loading-hidden"
            }, null, c.container), c.loadingSpan = l("span", {
              className: "highcharts-loading-inner"
            }, null, b), n(c, "redraw", f));
            b.className = "highcharts-loading";
            c.loadingSpan.innerHTML = M(a, d.lang.loading, "");
            c.styledMode || (J(b, g(e.style, {
              zIndex: 10
            })), J(c.loadingSpan, e.labelStyle), c.loadingShown || (J(b, {
              opacity: 0,
              display: ""
            }), I(b, {
              opacity: e.style.opacity || .5
            }, {
              duration: e.showDuration || 0
            })));
            c.loadingShown = !0;
            f();
          },
          hideLoading: function hideLoading() {
            var a = this.options,
                c = this.loadingDiv;
            c && (c.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || I(c, {
              opacity: 0
            }, {
              duration: a.loading.hideDuration || 100,
              complete: function complete() {
                J(c, {
                  display: "none"
                });
              }
            }));
            this.loadingShown = !1;
          },
          propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
          propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
          propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" "),
          collectionsWithUpdate: ["xAxis", "yAxis", "zAxis", "series"],
          update: function update(a, d, g, b) {
            var e = this,
                f = {
              credits: "addCredits",
              title: "setTitle",
              subtitle: "setSubtitle",
              caption: "setCaption"
            },
                p,
                h,
                l,
                n = a.isResponsiveOptions,
                u = [];
            c(e, "update", {
              options: a
            });
            n || e.setResponsive(!1, !0);
            a = F.cleanRecursively(a, e.options);
            A(!0, e.userOptions, a);

            if (p = a.chart) {
              A(!0, e.options.chart, p);
              "className" in p && e.setClassName(p.className);
              "reflow" in p && e.setReflow(p.reflow);

              if ("inverted" in p || "polar" in p || "type" in p) {
                e.propFromSeries();
                var m = !0;
              }

              "alignTicks" in p && (m = !0);
              G(p, function (a, b) {
                -1 !== e.propsRequireUpdateSeries.indexOf("chart." + b) && (h = !0);
                -1 !== e.propsRequireDirtyBox.indexOf(b) && (e.isDirtyBox = !0);
                -1 !== e.propsRequireReflow.indexOf(b) && (n ? e.isDirtyBox = !0 : l = !0);
              });
              !e.styledMode && "style" in p && e.renderer.setStyle(p.style);
            }

            !e.styledMode && a.colors && (this.options.colors = a.colors);
            a.time && (this.time === D && (this.time = new y(a.time)), A(!0, e.options.time, a.time));
            G(a, function (b, c) {
              if (e[c] && "function" === typeof e[c].update) e[c].update(b, !1);else if ("function" === typeof e[f[c]]) e[f[c]](b);else "color" !== c && -1 === e.collectionsWithUpdate.indexOf(c) && A(!0, e.options[c], a[c]);
              "chart" !== c && -1 !== e.propsRequireUpdateSeries.indexOf(c) && (h = !0);
            });
            this.collectionsWithUpdate.forEach(function (b) {
              if (a[b]) {
                if ("series" === b) {
                  var c = [];
                  e[b].forEach(function (a, b) {
                    a.options.isInternal || c.push(M(a.options.index, b));
                  });
                }

                Q(a[b]).forEach(function (a, d) {
                  var f = w(a.id),
                      k;
                  f && (k = e.get(a.id));
                  k || (k = e[b][c ? c[d] : d]) && f && w(k.options.id) && (k = void 0);
                  k && k.coll === b && (k.update(a, !1), g && (k.touched = !0));
                  !k && g && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);
                });
                g && e[b].forEach(function (a) {
                  a.touched || a.options.isInternal ? delete a.touched : u.push(a);
                });
              }
            });
            u.forEach(function (a) {
              a.remove && a.remove(!1);
            });
            m && e.axes.forEach(function (a) {
              a.update({}, !1);
            });
            h && e.getSeriesOrderByLinks().forEach(function (a) {
              a.chart && a.update({}, !1);
            }, this);
            m = p && p.width;
            p = p && p.height;
            B(p) && (p = T(p, m || e.chartWidth));
            l || q(m) && m !== e.chartWidth || q(p) && p !== e.chartHeight ? e.setSize(m, p, b) : M(d, !0) && e.redraw(b);
            c(e, "afterUpdate", {
              options: a,
              redraw: d,
              animation: b
            });
          },
          setSubtitle: function setSubtitle(a, c) {
            this.applyDescription("subtitle", a);
            this.layOutTitles(c);
          },
          setCaption: function setCaption(a, c) {
            this.applyDescription("caption", a);
            this.layOutTitles(c);
          }
        });
        z.prototype.collectionsWithInit = {
          xAxis: [z.prototype.addAxis, [!0]],
          yAxis: [z.prototype.addAxis, [!1]],
          series: [z.prototype.addSeries]
        };
        g(C.prototype, {
          update: function update(a, c, d, b) {
            function g() {
              e.applyOptions(a);
              var b = h && e.hasDummyGraphic;
              b = null === e.y ? !b : b;
              h && b && (e.graphic = h.destroy(), delete e.hasDummyGraphic);
              p(a, !0) && (h && h.element && a && a.marker && "undefined" !== typeof a.marker.symbol && (e.graphic = h.destroy()), a && a.dataLabels && e.dataLabel && (e.dataLabel = e.dataLabel.destroy()), e.connector && (e.connector = e.connector.destroy()));
              q = e.index;
              f.updateParallelArrays(e, q);
              n.data[q] = p(n.data[q], !0) || p(a, !0) ? e.options : M(a, n.data[q]);
              f.isDirty = f.isDirtyData = !0;
              !f.fixedBox && f.hasCartesianSeries && (l.isDirtyBox = !0);
              "point" === n.legendType && (l.isDirtyLegend = !0);
              c && l.redraw(d);
            }

            var e = this,
                f = e.series,
                h = e.graphic,
                q,
                l = f.chart,
                n = f.options;
            c = M(c, !0);
            !1 === b ? g() : e.firePointEvent("update", {
              options: a
            }, g);
          },
          remove: function remove(a, c) {
            this.series.removePoint(this.series.data.indexOf(this), a, c);
          }
        });
        g(L.prototype, {
          addPoint: function addPoint(a, d, g, b, e) {
            var f = this.options,
                k = this.data,
                p = this.chart,
                h = this.xAxis;
            h = h && h.hasNames && h.names;
            var q = f.data,
                l = this.xData,
                n;
            d = M(d, !0);
            var u = {
              series: this
            };
            this.pointClass.prototype.applyOptions.apply(u, [a]);
            var m = u.x;
            var r = l.length;
            if (this.requireSorting && m < l[r - 1]) for (n = !0; r && l[r - 1] > m;) r--;
            this.updateParallelArrays(u, "splice", r, 0, 0);
            this.updateParallelArrays(u, r);
            h && u.name && (h[m] = u.name);
            q.splice(r, 0, a);
            n && (this.data.splice(r, 0, null), this.processData());
            "point" === f.legendType && this.generatePoints();
            g && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), this.updateParallelArrays(u, "shift"), q.shift()));
            !1 !== e && c(this, "addPoint", {
              point: u
            });
            this.isDirtyData = this.isDirty = !0;
            d && p.redraw(b);
          },
          removePoint: function removePoint(a, c, d) {
            var b = this,
                g = b.data,
                e = g[a],
                f = b.points,
                p = b.chart,
                h = function h() {
              f && f.length === g.length && f.splice(a, 1);
              g.splice(a, 1);
              b.options.data.splice(a, 1);
              b.updateParallelArrays(e || {
                series: b
              }, "splice", a, 1);
              e && e.destroy();
              b.isDirty = !0;
              b.isDirtyData = !0;
              c && p.redraw();
            };

            v(d, p);
            c = M(c, !0);
            e ? e.firePointEvent("remove", null, h) : h();
          },
          remove: function remove(a, d, g, b) {
            function e() {
              f.destroy(b);
              f.remove = null;
              p.isDirtyLegend = p.isDirtyBox = !0;
              p.linkSeries();
              M(a, !0) && p.redraw(d);
            }

            var f = this,
                p = f.chart;
            !1 !== g ? c(f, "remove", null, e) : e();
          },
          update: function update(a, e) {
            a = F.cleanRecursively(a, this.userOptions);
            c(this, "update", {
              options: a
            });
            var f = this,
                b = f.chart,
                k = f.userOptions,
                p = f.initialType || f.type,
                h = b.options.plotOptions,
                q = a.type || k.type || b.options.chart.type,
                l = !(this.hasDerivedData || q && q !== this.type || "undefined" !== typeof a.pointStart || "undefined" !== typeof a.pointInterval || f.hasOptionChanged("dataGrouping") || f.hasOptionChanged("pointStart") || f.hasOptionChanged("pointInterval") || f.hasOptionChanged("pointIntervalUnit") || f.hasOptionChanged("keys")),
                n = x[p].prototype,
                m,
                r = ["eventOptions", "navigatorSeries", "baseSeries"],
                w = f.finishedAnimating && {
              animation: !1
            },
                v = {};
            l && (r.push("data", "isDirtyData", "points", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), !1 !== a.visible && r.push("area", "graph"), f.parallelArrays.forEach(function (a) {
              r.push(a + "Data");
            }), a.data && (a.dataSorting && g(f.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));
            a = A(k, w, {
              index: "undefined" === typeof k.index ? f.index : k.index,
              pointStart: M(h && h.series && h.series.pointStart, k.pointStart, f.xData[0])
            }, !l && {
              data: f.options.data
            }, a);
            l && a.data && (a.data = f.options.data);
            r = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(r);
            r.forEach(function (a) {
              r[a] = f[a];
              delete f[a];
            });
            f.remove(!1, null, !1, !0);

            for (m in n) f[m] = void 0;

            x[q || p] ? g(f, x[q || p].prototype) : d(17, !0, b, {
              missingModuleFor: q || p
            });
            r.forEach(function (a) {
              f[a] = r[a];
            });
            f.init(b, a);

            if (l && this.points) {
              var B = f.options;
              !1 === B.visible ? (v.graphic = 1, v.dataLabel = 1) : f._hasPointLabels || (a = B.marker, k = B.dataLabels, a && (!1 === a.enabled || "symbol" in a) && (v.graphic = 1), k && !1 === k.enabled && (v.dataLabel = 1));
              this.points.forEach(function (a) {
                a && a.series && (a.resolveColor(), Object.keys(v).length && a.destroyElements(v), !1 === B.showInLegend && a.legendItem && b.legend.destroyItem(a));
              }, this);
            }

            f.initialType = p;
            b.linkSeries();
            c(this, "afterUpdate");
            M(e, !0) && b.redraw(l ? void 0 : !1);
          },
          setName: function setName(a) {
            this.name = this.options.name = this.userOptions.name = a;
            this.chart.isDirtyLegend = !0;
          },
          hasOptionChanged: function hasOptionChanged(a) {
            var c = this.options[a],
                d = this.chart.options.plotOptions,
                b = this.userOptions[a];
            return b ? c !== b : c !== M(d && d[this.type] && d[this.type][a], d && d.series && d.series[a], c);
          }
        });
        g(h.prototype, {
          update: function update(a, c) {
            var d = this.chart,
                b = a && a.events || {};
            a = A(this.userOptions, a);
            d.options[this.coll].indexOf && (d.options[this.coll][d.options[this.coll].indexOf(this.userOptions)] = a);
            G(d.options[this.coll].events, function (a, c) {
              "undefined" === typeof b[c] && (b[c] = void 0);
            });
            this.destroy(!0);
            this.init(d, g(a, {
              events: b
            }));
            d.isDirtyBox = !0;
            M(c, !0) && d.redraw();
          },
          remove: function remove(c) {
            for (var d = this.chart, g = this.coll, b = this.series, e = b.length; e--;) b[e] && b[e].remove(!1);

            r(d.axes, this);
            r(d[g], this);
            a(d.options[g]) ? d.options[g].splice(this.options.index, 1) : delete d.options[g];
            d[g].forEach(function (a, b) {
              a.options.index = a.userOptions.index = b;
            });
            this.destroy();
            d.isDirtyBox = !0;
            M(c, !0) && d.redraw();
          },
          setTitle: function setTitle(a, c) {
            this.update({
              title: a
            }, c);
          },
          setCategories: function setCategories(a, c) {
            this.update({
              categories: a
            }, c);
          }
        });
      });
      N(m, "Series/AreaSeries.js", [m["Core/Series/Series.js"], m["Core/Color/Color.js"], m["Core/Globals.js"], m["Mixins/LegendSymbol.js"], m["Core/Utilities.js"]], function (f, h, m, z, F) {
        var L = h.parse,
            K = F.objectEach,
            C = F.pick,
            y = m.Series;
        f.seriesType("area", "line", {
          threshold: 0
        }, {
          singleStacks: !1,
          getStackPoints: function getStackPoints(e) {
            var f = [],
                h = [],
                m = this.xAxis,
                D = this.yAxis,
                n = D.stacking.stacks[this.stackKey],
                l = {},
                y = this.index,
                w = D.series,
                r = w.length,
                d = C(D.options.reversedStacks, !0) ? 1 : -1,
                g;
            e = e || this.points;

            if (this.options.stacking) {
              for (g = 0; g < e.length; g++) e[g].leftNull = e[g].rightNull = void 0, l[e[g].x] = e[g];

              K(n, function (a, c) {
                null !== a.total && h.push(c);
              });
              h.sort(function (a, c) {
                return a - c;
              });
              var c = w.map(function (a) {
                return a.visible;
              });
              h.forEach(function (a, e) {
                var p = 0,
                    q,
                    w;
                if (l[a] && !l[a].isNull) f.push(l[a]), [-1, 1].forEach(function (f) {
                  var p = 1 === f ? "rightNull" : "leftNull",
                      m = 0,
                      v = n[h[e + f]];
                  if (v) for (g = y; 0 <= g && g < r;) q = v.points[g], q || (g === y ? l[a][p] = !0 : c[g] && (w = n[a].points[g]) && (m -= w[1] - w[0])), g += d;
                  l[a][1 === f ? "rightCliff" : "leftCliff"] = m;
                });else {
                  for (g = y; 0 <= g && g < r;) {
                    if (q = n[a].points[g]) {
                      p = q[1];
                      break;
                    }

                    g += d;
                  }

                  p = D.translate(p, 0, 1, 0, 1);
                  f.push({
                    isNull: !0,
                    plotX: m.translate(a, 0, 0, 0, 1),
                    x: a,
                    plotY: p,
                    yBottom: p
                  });
                }
              });
            }

            return f;
          },
          getGraphPath: function getGraphPath(e) {
            var f = y.prototype.getGraphPath,
                h = this.options,
                m = h.stacking,
                D = this.yAxis,
                n,
                l = [],
                z = [],
                w = this.index,
                r = D.stacking.stacks[this.stackKey],
                d = h.threshold,
                g = Math.round(D.getThreshold(h.threshold));
            h = C(h.connectNulls, "percent" === m);

            var c = function c(a, _c2, f) {
              var p = e[a];
              a = m && r[p.x].points[w];
              var h = p[f + "Null"] || 0;
              f = p[f + "Cliff"] || 0;
              p = !0;

              if (f || h) {
                var n = (h ? a[0] : a[1]) + f;
                var v = a[0] + f;
                p = !!h;
              } else !m && e[_c2] && e[_c2].isNull && (n = v = d);

              "undefined" !== typeof n && (z.push({
                plotX: q,
                plotY: null === n ? g : D.getThreshold(n),
                isNull: p,
                isCliff: !0
              }), l.push({
                plotX: q,
                plotY: null === v ? g : D.getThreshold(v),
                doCurve: !1
              }));
            };

            e = e || this.points;
            m && (e = this.getStackPoints(e));

            for (n = 0; n < e.length; n++) {
              m || (e[n].leftCliff = e[n].rightCliff = e[n].leftNull = e[n].rightNull = void 0);
              var a = e[n].isNull;
              var q = C(e[n].rectPlotX, e[n].plotX);
              var p = m ? e[n].yBottom : g;
              if (!a || h) h || c(n, n - 1, "left"), a && !m && h || (z.push(e[n]), l.push({
                x: n,
                plotX: q,
                plotY: p
              })), h || c(n, n + 1, "right");
            }

            n = f.call(this, z, !0, !0);
            l.reversed = !0;
            a = f.call(this, l, !0, !0);
            (p = a[0]) && "M" === p[0] && (a[0] = ["L", p[1], p[2]]);
            a = n.concat(a);
            f = f.call(this, z, !1, h);
            a.xMap = n.xMap;
            this.areaPath = a;
            return f;
          },
          drawGraph: function drawGraph() {
            this.areaPath = [];
            y.prototype.drawGraph.apply(this);
            var e = this,
                f = this.areaPath,
                h = this.options,
                m = [["area", "highcharts-area", this.color, h.fillColor]];
            this.zones.forEach(function (f, n) {
              m.push(["zone-area-" + n, "highcharts-area highcharts-zone-area-" + n + " " + f.className, f.color || e.color, f.fillColor || h.fillColor]);
            });
            m.forEach(function (m) {
              var n = m[0],
                  l = e[n],
                  v = l ? "animate" : "attr",
                  w = {};
              l ? (l.endX = e.preventGraphAnimation ? null : f.xMap, l.animate({
                d: f
              })) : (w.zIndex = 0, l = e[n] = e.chart.renderer.path(f).addClass(m[1]).add(e.group), l.isArea = !0);
              e.chart.styledMode || (w.fill = C(m[3], L(m[2]).setOpacity(C(h.fillOpacity, .75)).get()));
              l[v](w);
              l.startX = f.xMap;
              l.shiftUnit = h.step ? 2 : 1;
            });
          },
          drawLegendSymbol: z.drawRectangle
        });
        "";
      });
      N(m, "Series/SplineSeries.js", [m["Core/Series/Series.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.pick;
        f.seriesType("spline", "line", {}, {
          getPointSpline: function getPointSpline(f, h, L) {
            var z = h.plotX || 0,
                C = h.plotY || 0,
                y = f[L - 1];
            L = f[L + 1];

            if (y && !y.isNull && !1 !== y.doCurve && !h.isCliff && L && !L.isNull && !1 !== L.doCurve && !h.isCliff) {
              f = y.plotY || 0;
              var e = L.plotX || 0;
              L = L.plotY || 0;
              var F = 0;
              var v = (1.5 * z + (y.plotX || 0)) / 2.5;
              var x = (1.5 * C + f) / 2.5;
              e = (1.5 * z + e) / 2.5;
              var D = (1.5 * C + L) / 2.5;
              e !== v && (F = (D - x) * (e - z) / (e - v) + C - D);
              x += F;
              D += F;
              x > f && x > C ? (x = Math.max(f, C), D = 2 * C - x) : x < f && x < C && (x = Math.min(f, C), D = 2 * C - x);
              D > L && D > C ? (D = Math.max(L, C), x = 2 * C - D) : D < L && D < C && (D = Math.min(L, C), x = 2 * C - D);
              h.rightContX = e;
              h.rightContY = D;
            }

            h = ["C", m(y.rightContX, y.plotX, 0), m(y.rightContY, y.plotY, 0), m(v, z, 0), m(x, C, 0), z, C];
            y.rightContX = y.rightContY = void 0;
            return h;
          }
        });
        "";
      });
      N(m, "Series/AreaSplineSeries.js", [m["Core/Series/Series.js"], m["Mixins/LegendSymbol.js"], m["Core/Options.js"]], function (f, h, m) {
        var z = f.seriesTypes.area.prototype;
        f.seriesType("areaspline", "spline", m.defaultOptions.plotOptions.area, {
          getStackPoints: z.getStackPoints,
          getGraphPath: z.getGraphPath,
          drawGraph: z.drawGraph,
          drawLegendSymbol: h.drawRectangle
        });
        "";
      });
      N(m, "Series/ColumnSeries.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Series/Series.js"], m["Core/Color/Color.js"], m["Core/Globals.js"], m["Mixins/LegendSymbol.js"], m["Series/LineSeries.js"], m["Core/Utilities.js"]], function (f, h, m, z, F, L, K) {
        var C = f.animObject,
            y = m.parse;
        f = z.noop;
        var e = K.clamp,
            I = K.defined,
            v = K.extend,
            x = K.isArray,
            D = K.isNumber,
            n = K.merge,
            l = K.pick,
            J = K.objectEach;
        "";
        h = h.seriesType("column", "line", {
          borderRadius: 0,
          centerInCategory: !1,
          groupPadding: .2,
          marker: null,
          pointPadding: .1,
          minPointLength: 0,
          cropThreshold: 50,
          pointRange: null,
          states: {
            hover: {
              halo: !1,
              brightness: .1
            },
            select: {
              color: "#cccccc",
              borderColor: "#000000"
            }
          },
          dataLabels: {
            align: void 0,
            verticalAlign: void 0,
            y: void 0
          },
          startFromThreshold: !0,
          stickyTracking: !1,
          tooltip: {
            distance: 6
          },
          threshold: 0,
          borderColor: "#ffffff"
        }, {
          cropShoulder: 0,
          directTouch: !0,
          trackerGroups: ["group", "dataLabelsGroup"],
          negStacks: !0,
          init: function init() {
            L.prototype.init.apply(this, arguments);
            var e = this,
                f = e.chart;
            f.hasRendered && f.series.forEach(function (d) {
              d.type === e.type && (d.isDirty = !0);
            });
          },
          getColumnMetrics: function getColumnMetrics() {
            var e = this,
                f = e.options,
                d = e.xAxis,
                g = e.yAxis,
                c = d.options.reversedStacks;
            c = d.reversed && !c || !d.reversed && c;
            var a,
                h = {},
                p = 0;
            !1 === f.grouping ? p = 1 : e.chart.series.forEach(function (c) {
              var d = c.yAxis,
                  f = c.options;

              if (c.type === e.type && (c.visible || !e.chart.options.chart.ignoreHiddenSeries) && g.len === d.len && g.pos === d.pos) {
                if (f.stacking && "group" !== f.stacking) {
                  a = c.stackKey;
                  "undefined" === typeof h[a] && (h[a] = p++);
                  var q = h[a];
                } else !1 !== f.grouping && (q = p++);

                c.columnIndex = q;
              }
            });
            var n = Math.min(Math.abs(d.transA) * (d.ordinal && d.ordinal.slope || f.pointRange || d.closestPointRange || d.tickInterval || 1), d.len),
                m = n * f.groupPadding,
                v = (n - 2 * m) / (p || 1);
            f = Math.min(f.maxPointWidth || d.len, l(f.pointWidth, v * (1 - 2 * f.pointPadding)));
            e.columnMetrics = {
              width: f,
              offset: (v - f) / 2 + (m + ((e.columnIndex || 0) + (c ? 1 : 0)) * v - n / 2) * (c ? -1 : 1),
              paddedWidth: v,
              columnCount: p
            };
            return e.columnMetrics;
          },
          crispCol: function crispCol(e, f, d, g) {
            var c = this.chart,
                a = this.borderWidth,
                h = -(a % 2 ? .5 : 0);
            a = a % 2 ? .5 : 1;
            c.inverted && c.renderer.isVML && (a += 1);
            this.options.crisp && (d = Math.round(e + d) + h, e = Math.round(e) + h, d -= e);
            g = Math.round(f + g) + a;
            h = .5 >= Math.abs(f) && .5 < g;
            f = Math.round(f) + a;
            g -= f;
            h && g && (--f, g += 1);
            return {
              x: e,
              y: f,
              width: d,
              height: g
            };
          },
          adjustForMissingColumns: function adjustForMissingColumns(e, f, d, g) {
            var c = this,
                a = this.options.stacking;

            if (!d.isNull && 1 < g.columnCount) {
              var h = 0,
                  p = 0;
              J(this.yAxis.stacking && this.yAxis.stacking.stacks, function (g) {
                if ("number" === typeof d.x && (g = g[d.x.toString()])) {
                  var e = g.points[c.index],
                      f = g.total;
                  a ? (e && (h = p), g.hasValidPoints && p++) : x(e) && (h = e[1], p = f || 0);
                }
              });
              e = (d.plotX || 0) + ((p - 1) * g.paddedWidth + f) / 2 - f - h * g.paddedWidth;
            }

            return e;
          },
          translate: function translate() {
            var f = this,
                h = f.chart,
                d = f.options,
                g = f.dense = 2 > f.closestPointRange * f.xAxis.transA;
            g = f.borderWidth = l(d.borderWidth, g ? 0 : 1);
            var c = f.xAxis,
                a = f.yAxis,
                q = d.threshold,
                p = f.translatedThreshold = a.getThreshold(q),
                n = l(d.minPointLength, 5),
                m = f.getColumnMetrics(),
                v = m.width,
                x = f.barW = Math.max(v, 1 + 2 * g),
                y = f.pointXOffset = m.offset,
                z = f.dataMin,
                C = f.dataMax;
            h.inverted && (p -= .5);
            d.pointPadding && (x = Math.ceil(x));
            L.prototype.translate.apply(f);
            f.points.forEach(function (g) {
              var u = l(g.yBottom, p),
                  b = 999 + Math.abs(u),
                  k = v,
                  t = g.plotX || 0;
              b = e(g.plotY, -b, a.len + b);
              var r = t + y,
                  w = x,
                  A = Math.min(b, u),
                  B = Math.max(b, u) - A;

              if (n && Math.abs(B) < n) {
                B = n;
                var E = !a.reversed && !g.negative || a.reversed && g.negative;
                D(q) && D(C) && g.y === q && C <= q && (a.min || 0) < q && z !== C && (E = !E);
                A = Math.abs(A - p) > n ? u - n : p - (E ? n : 0);
              }

              I(g.options.pointWidth) && (k = w = Math.ceil(g.options.pointWidth), r -= Math.round((k - v) / 2));
              d.centerInCategory && (r = f.adjustForMissingColumns(r, k, g, m));
              g.barX = r;
              g.pointWidth = k;
              g.tooltipPos = h.inverted ? [a.len + a.pos - h.plotLeft - b, c.len + c.pos - h.plotTop - (t || 0) - y - w / 2, B] : [r + w / 2, b + a.pos - h.plotTop, B];
              g.shapeType = f.pointClass.prototype.shapeType || "rect";
              g.shapeArgs = f.crispCol.apply(f, g.isNull ? [r, p, w, 0] : [r, A, w, B]);
            });
          },
          getSymbol: f,
          drawLegendSymbol: F.drawRectangle,
          drawGraph: function drawGraph() {
            this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
          },
          pointAttribs: function pointAttribs(e, f) {
            var d = this.options,
                g = this.pointAttrToOptions || {};
            var c = g.stroke || "borderColor";
            var a = g["stroke-width"] || "borderWidth",
                h = e && e.color || this.color,
                p = e && e[c] || d[c] || this.color || h,
                m = e && e[a] || d[a] || this[a] || 0;
            g = e && e.options.dashStyle || d.dashStyle;
            var r = l(e && e.opacity, d.opacity, 1);

            if (e && this.zones.length) {
              var v = e.getZone();
              h = e.options.color || v && (v.color || e.nonZonedColor) || this.color;
              v && (p = v.borderColor || p, g = v.dashStyle || g, m = v.borderWidth || m);
            }

            f && e && (e = n(d.states[f], e.options.states && e.options.states[f] || {}), f = e.brightness, h = e.color || "undefined" !== typeof f && y(h).brighten(e.brightness).get() || h, p = e[c] || p, m = e[a] || m, g = e.dashStyle || g, r = l(e.opacity, r));
            c = {
              fill: h,
              stroke: p,
              "stroke-width": m,
              opacity: r
            };
            g && (c.dashstyle = g);
            return c;
          },
          drawPoints: function drawPoints() {
            var e = this,
                f = this.chart,
                d = e.options,
                g = f.renderer,
                c = d.animationLimit || 250,
                a;
            e.points.forEach(function (h) {
              var p = h.graphic,
                  l = !!p,
                  q = p && f.pointCount < c ? "animate" : "attr";

              if (D(h.plotY) && null !== h.y) {
                a = h.shapeArgs;
                p && h.hasNewShapeType() && (p = p.destroy());
                e.enabledDataSorting && (h.startXPos = e.xAxis.reversed ? -(a ? a.width : 0) : e.xAxis.width);
                p || (h.graphic = p = g[h.shapeType](a).add(h.group || e.group)) && e.enabledDataSorting && f.hasRendered && f.pointCount < c && (p.attr({
                  x: h.startXPos
                }), l = !0, q = "animate");
                if (p && l) p[q](n(a));
                if (d.borderRadius) p[q]({
                  r: d.borderRadius
                });
                f.styledMode || p[q](e.pointAttribs(h, h.selected && "select")).shadow(!1 !== h.allowShadow && d.shadow, null, d.stacking && !d.borderRadius);
                p.addClass(h.getClassName(), !0);
              } else p && (h.graphic = p.destroy());
            });
          },
          animate: function animate(f) {
            var h = this,
                d = this.yAxis,
                g = h.options,
                c = this.chart.inverted,
                a = {},
                l = c ? "translateX" : "translateY";
            if (f) a.scaleY = .001, f = e(d.toPixels(g.threshold), d.pos, d.pos + d.len), c ? a.translateX = f - d.len : a.translateY = f, h.clipBox && h.setClip(), h.group.attr(a);else {
              var p = h.group.attr(l);
              h.group.animate({
                scaleY: 1
              }, v(C(h.options.animation), {
                step: function step(c, g) {
                  h.group && (a[l] = p + g.pos * (d.pos - p), h.group.attr(a));
                }
              }));
            }
          },
          remove: function remove() {
            var e = this,
                f = e.chart;
            f.hasRendered && f.series.forEach(function (d) {
              d.type === e.type && (d.isDirty = !0);
            });
            L.prototype.remove.apply(e, arguments);
          }
        });
        "";
        return h;
      });
      N(m, "Series/BarSeries.js", [m["Core/Series/Series.js"]], function (f) {
        f.seriesType("bar", "column", null, {
          inverted: !0
        });
        "";
      });
      N(m, "Series/ScatterSeries.js", [m["Core/Series/Series.js"], m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h, m) {
        m = m.addEvent;
        var z = h.Series;
        f.seriesType("scatter", "line", {
          lineWidth: 0,
          findNearestPointBy: "xy",
          jitter: {
            x: 0,
            y: 0
          },
          marker: {
            enabled: !0
          },
          tooltip: {
            headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>",
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
          }
        }, {
          sorted: !1,
          requireSorting: !1,
          noSharedTooltip: !0,
          trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
          takeOrdinalPosition: !1,
          drawGraph: function drawGraph() {
            (this.options.lineWidth || 0 === this.options.lineWidth && this.graph && this.graph.strokeWidth()) && z.prototype.drawGraph.call(this);
          },
          applyJitter: function applyJitter() {
            var f = this,
                h = this.options.jitter,
                m = this.points.length;
            h && this.points.forEach(function (z, y) {
              ["x", "y"].forEach(function (e, C) {
                var v = "plot" + e.toUpperCase();

                if (h[e] && !z.isNull) {
                  var x = f[e + "Axis"];
                  var D = h[e] * x.transA;

                  if (x && !x.isLog) {
                    var n = Math.max(0, z[v] - D);
                    x = Math.min(x.len, z[v] + D);
                    C = 1E4 * Math.sin(y + C * m);
                    z[v] = n + (x - n) * (C - Math.floor(C));
                    "x" === e && (z.clientX = z.plotX);
                  }
                }
              });
            });
          }
        });
        m(z, "afterTranslate", function () {
          this.applyJitter && this.applyJitter();
        });
        "";
      });
      N(m, "Mixins/CenteredSeries.js", [m["Core/Globals.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.isNumber,
            z = h.pick,
            F = h.relativeLength,
            L = f.deg2rad;
        return f.CenteredSeriesMixin = {
          getCenter: function getCenter() {
            var h = this.options,
                m = this.chart,
                y = 2 * (h.slicedOffset || 0),
                e = m.plotWidth - 2 * y,
                I = m.plotHeight - 2 * y,
                v = h.center,
                x = Math.min(e, I),
                D = h.size,
                n = h.innerSize || 0;
            "string" === typeof D && (D = parseFloat(D));
            "string" === typeof n && (n = parseFloat(n));
            h = [z(v[0], "50%"), z(v[1], "50%"), z(D && 0 > D ? void 0 : h.size, "100%"), z(n && 0 > n ? void 0 : h.innerSize || 0, "0%")];
            !m.angular || this instanceof f.Series || (h[3] = 0);

            for (v = 0; 4 > v; ++v) D = h[v], m = 2 > v || 2 === v && /%$/.test(D), h[v] = F(D, [e, I, x, h[2]][v]) + (m ? y : 0);

            h[3] > h[2] && (h[3] = h[2]);
            return h;
          },
          getStartAndEndRadians: function getStartAndEndRadians(f, h) {
            f = m(f) ? f : 0;
            h = m(h) && h > f && 360 > h - f ? h : f + 360;
            return {
              start: L * (f + -90),
              end: L * (h + -90)
            };
          }
        };
      });
      N(m, "Series/PieSeries.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Series/Series.js"], m["Mixins/CenteredSeries.js"], m["Core/Globals.js"], m["Mixins/LegendSymbol.js"], m["Series/LineSeries.js"], m["Core/Series/Point.js"], m["Core/Renderer/SVG/SVGRenderer.js"], m["Core/Utilities.js"]], function (f, h, m, z, F, L, K, C, y) {
        var e = f.setAnimation,
            I = m.getStartAndEndRadians;
        f = z.noop;
        var v = y.addEvent,
            x = y.clamp,
            D = y.defined,
            n = y.fireEvent,
            l = y.isNumber,
            J = y.merge,
            w = y.pick,
            r = y.relativeLength;
        h.seriesType("pie", "line", {
          center: [null, null],
          clip: !1,
          colorByPoint: !0,
          dataLabels: {
            allowOverlap: !0,
            connectorPadding: 5,
            connectorShape: "fixedOffset",
            crookDistance: "70%",
            distance: 30,
            enabled: !0,
            formatter: function formatter() {
              return this.point.isNull ? void 0 : this.point.name;
            },
            softConnector: !0,
            x: 0
          },
          fillColor: void 0,
          ignoreHiddenPoint: !0,
          inactiveOtherPoints: !0,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: !1,
          slicedOffset: 10,
          stickyTracking: !1,
          tooltip: {
            followPointer: !0
          },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: {
            hover: {
              brightness: .1
            }
          }
        }, {
          isCartesian: !1,
          requireSorting: !1,
          directTouch: !0,
          noSharedTooltip: !0,
          trackerGroups: ["group", "dataLabelsGroup"],
          axisTypes: [],
          pointAttribs: h.seriesTypes.column.prototype.pointAttribs,
          animate: function animate(d) {
            var g = this,
                c = g.points,
                a = g.startAngleRad;
            d || c.forEach(function (c) {
              var d = c.graphic,
                  e = c.shapeArgs;
              d && e && (d.attr({
                r: w(c.startR, g.center && g.center[3] / 2),
                start: a,
                end: a
              }), d.animate({
                r: e.r,
                start: e.start,
                end: e.end
              }, g.options.animation));
            });
          },
          hasData: function hasData() {
            return !!this.processedXData.length;
          },
          updateTotals: function updateTotals() {
            var d,
                g = 0,
                c = this.points,
                a = c.length,
                e = this.options.ignoreHiddenPoint;

            for (d = 0; d < a; d++) {
              var f = c[d];
              g += e && !f.visible ? 0 : f.isNull ? 0 : f.y;
            }

            this.total = g;

            for (d = 0; d < a; d++) f = c[d], f.percentage = 0 < g && (f.visible || !e) ? f.y / g * 100 : 0, f.total = g;
          },
          generatePoints: function generatePoints() {
            L.prototype.generatePoints.call(this);
            this.updateTotals();
          },
          getX: function getX(d, g, c) {
            var a = this.center,
                e = this.radii ? this.radii[c.index] : a[2] / 2;
            d = Math.asin(x((d - a[1]) / (e + c.labelDistance), -1, 1));
            return a[0] + (g ? -1 : 1) * Math.cos(d) * (e + c.labelDistance) + (0 < c.labelDistance ? (g ? -1 : 1) * this.options.dataLabels.padding : 0);
          },
          translate: function translate(d) {
            this.generatePoints();
            var g = 0,
                c = this.options,
                a = c.slicedOffset,
                e = a + (c.borderWidth || 0),
                f = I(c.startAngle, c.endAngle),
                h = this.startAngleRad = f.start;
            f = (this.endAngleRad = f.end) - h;
            var l = this.points,
                m = c.dataLabels.distance;
            c = c.ignoreHiddenPoint;
            var v,
                x = l.length;
            d || (this.center = d = this.getCenter());

            for (v = 0; v < x; v++) {
              var y = l[v];
              var z = h + g * f;
              if (!c || y.visible) g += y.percentage / 100;
              var E = h + g * f;
              y.shapeType = "arc";
              y.shapeArgs = {
                x: d[0],
                y: d[1],
                r: d[2] / 2,
                innerR: d[3] / 2,
                start: Math.round(1E3 * z) / 1E3,
                end: Math.round(1E3 * E) / 1E3
              };
              y.labelDistance = w(y.options.dataLabels && y.options.dataLabels.distance, m);
              y.labelDistance = r(y.labelDistance, y.shapeArgs.r);
              this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, y.labelDistance);
              E = (E + z) / 2;
              E > 1.5 * Math.PI ? E -= 2 * Math.PI : E < -Math.PI / 2 && (E += 2 * Math.PI);
              y.slicedTranslation = {
                translateX: Math.round(Math.cos(E) * a),
                translateY: Math.round(Math.sin(E) * a)
              };
              var u = Math.cos(E) * d[2] / 2;
              var b = Math.sin(E) * d[2] / 2;
              y.tooltipPos = [d[0] + .7 * u, d[1] + .7 * b];
              y.half = E < -Math.PI / 2 || E > Math.PI / 2 ? 1 : 0;
              y.angle = E;
              z = Math.min(e, y.labelDistance / 5);
              y.labelPosition = {
                natural: {
                  x: d[0] + u + Math.cos(E) * y.labelDistance,
                  y: d[1] + b + Math.sin(E) * y.labelDistance
                },
                "final": {},
                alignment: 0 > y.labelDistance ? "center" : y.half ? "right" : "left",
                connectorPosition: {
                  breakAt: {
                    x: d[0] + u + Math.cos(E) * z,
                    y: d[1] + b + Math.sin(E) * z
                  },
                  touchingSliceAt: {
                    x: d[0] + u,
                    y: d[1] + b
                  }
                }
              };
            }

            n(this, "afterTranslate");
          },
          drawEmpty: function drawEmpty() {
            var d = this.startAngleRad,
                g = this.endAngleRad,
                c = this.options;

            if (0 === this.total && this.center) {
              var a = this.center[0];
              var e = this.center[1];
              this.graph || (this.graph = this.chart.renderer.arc(a, e, this.center[1] / 2, 0, d, g).addClass("highcharts-empty-series").add(this.group));
              this.graph.attr({
                d: C.prototype.symbols.arc(a, e, this.center[2] / 2, 0, {
                  start: d,
                  end: g,
                  innerR: this.center[3] / 2
                })
              });
              this.chart.styledMode || this.graph.attr({
                "stroke-width": c.borderWidth,
                fill: c.fillColor || "none",
                stroke: c.color || "#cccccc"
              });
            } else this.graph && (this.graph = this.graph.destroy());
          },
          redrawPoints: function redrawPoints() {
            var d = this,
                e = d.chart,
                c = e.renderer,
                a,
                f,
                h,
                l,
                n = d.options.shadow;
            this.drawEmpty();
            !n || d.shadowGroup || e.styledMode || (d.shadowGroup = c.g("shadow").attr({
              zIndex: -1
            }).add(d.group));
            d.points.forEach(function (g) {
              var p = {};
              f = g.graphic;

              if (!g.isNull && f) {
                l = g.shapeArgs;
                a = g.getTranslate();

                if (!e.styledMode) {
                  var q = g.shadowGroup;
                  n && !q && (q = g.shadowGroup = c.g("shadow").add(d.shadowGroup));
                  q && q.attr(a);
                  h = d.pointAttribs(g, g.selected && "select");
                }

                g.delayedRendering ? (f.setRadialReference(d.center).attr(l).attr(a), e.styledMode || f.attr(h).attr({
                  "stroke-linejoin": "round"
                }).shadow(n, q), g.delayedRendering = !1) : (f.setRadialReference(d.center), e.styledMode || J(!0, p, h), J(!0, p, l, a), f.animate(p));
                f.attr({
                  visibility: g.visible ? "inherit" : "hidden"
                });
                f.addClass(g.getClassName());
              } else f && (g.graphic = f.destroy());
            });
          },
          drawPoints: function drawPoints() {
            var d = this.chart.renderer;
            this.points.forEach(function (e) {
              e.graphic && e.hasNewShapeType() && (e.graphic = e.graphic.destroy());
              e.graphic || (e.graphic = d[e.shapeType](e.shapeArgs).add(e.series.group), e.delayedRendering = !0);
            });
          },
          searchPoint: f,
          sortByAngle: function sortByAngle(d, e) {
            d.sort(function (c, a) {
              return "undefined" !== typeof c.angle && (a.angle - c.angle) * e;
            });
          },
          drawLegendSymbol: F.drawRectangle,
          getCenter: m.getCenter,
          getSymbol: f,
          drawGraph: null
        }, {
          init: function init() {
            K.prototype.init.apply(this, arguments);
            var d = this;
            d.name = w(d.name, "Slice");

            var e = function e(c) {
              d.slice("select" === c.type);
            };

            v(d, "select", e);
            v(d, "unselect", e);
            return d;
          },
          isValid: function isValid() {
            return l(this.y) && 0 <= this.y;
          },
          setVisible: function setVisible(d, e) {
            var c = this,
                a = c.series,
                g = a.chart,
                f = a.options.ignoreHiddenPoint;
            e = w(e, f);
            d !== c.visible && (c.visible = c.options.visible = d = "undefined" === typeof d ? !c.visible : d, a.options.data[a.data.indexOf(c)] = c.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function (a) {
              if (c[a]) c[a][d ? "show" : "hide"](!0);
            }), c.legendItem && g.legend.colorizeItem(c, d), d || "hover" !== c.state || c.setState(""), f && (a.isDirty = !0), e && g.redraw());
          },
          slice: function slice(d, g, c) {
            var a = this.series;
            e(c, a.chart);
            w(g, !0);
            this.sliced = this.options.sliced = D(d) ? d : !this.sliced;
            a.options.data[a.data.indexOf(this)] = this.options;
            this.graphic && this.graphic.animate(this.getTranslate());
            this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
          },
          getTranslate: function getTranslate() {
            return this.sliced ? this.slicedTranslation : {
              translateX: 0,
              translateY: 0
            };
          },
          haloPath: function haloPath(d) {
            var e = this.shapeArgs;
            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(e.x, e.y, e.r + d, e.r + d, {
              innerR: e.r - 1,
              start: e.start,
              end: e.end
            });
          },
          connectorShapes: {
            fixedOffset: function fixedOffset(d, e, c) {
              var a = e.breakAt;
              e = e.touchingSliceAt;
              return [["M", d.x, d.y], c.softConnector ? ["C", d.x + ("left" === d.alignment ? -5 : 5), d.y, 2 * a.x - e.x, 2 * a.y - e.y, a.x, a.y] : ["L", a.x, a.y], ["L", e.x, e.y]];
            },
            straight: function straight(d, e) {
              e = e.touchingSliceAt;
              return [["M", d.x, d.y], ["L", e.x, e.y]];
            },
            crookedLine: function crookedLine(d, e, c) {
              e = e.touchingSliceAt;
              var a = this.series,
                  g = a.center[0],
                  f = a.chart.plotWidth,
                  h = a.chart.plotLeft;
              a = d.alignment;
              var l = this.shapeArgs.r;
              c = r(c.crookDistance, 1);
              f = "left" === a ? g + l + (f + h - g - l) * (1 - c) : h + (g - l) * c;
              c = ["L", f, d.y];
              g = !0;
              if ("left" === a ? f > d.x || f < e.x : f < d.x || f > e.x) g = !1;
              d = [["M", d.x, d.y]];
              g && d.push(c);
              d.push(["L", e.x, e.y]);
              return d;
            }
          },
          getConnectorPath: function getConnectorPath() {
            var d = this.labelPosition,
                e = this.series.options.dataLabels,
                c = e.connectorShape,
                a = this.connectorShapes;
            a[c] && (c = a[c]);
            return c.call(this, {
              x: d["final"].x,
              y: d["final"].y,
              alignment: d.alignment
            }, d.connectorPosition, e);
          }
        });
        "";
      });
      N(m, "Core/Series/DataLabels.js", [m["Core/Animation/AnimationUtilities.js"], m["Core/Globals.js"], m["Core/Series/CartesianSeries.js"], m["Core/Utilities.js"]], function (f, h, m, z) {
        var F = f.getDeferredAnimation;
        f = h.noop;
        var L = h.seriesTypes,
            K = z.arrayMax,
            C = z.clamp,
            y = z.defined,
            e = z.extend,
            I = z.fireEvent,
            v = z.format,
            x = z.isArray,
            D = z.merge,
            n = z.objectEach,
            l = z.pick,
            J = z.relativeLength,
            w = z.splat,
            r = z.stableSort;
        "";

        h.distribute = function (d, e, c) {
          function a(a, c) {
            return a.target - c.target;
          }

          var f,
              g = !0,
              n = d,
              m = [];
          var v = 0;
          var w = n.reducedLen || e;

          for (f = d.length; f--;) v += d[f].size;

          if (v > w) {
            r(d, function (a, c) {
              return (c.rank || 0) - (a.rank || 0);
            });

            for (v = f = 0; v <= w;) v += d[f].size, f++;

            m = d.splice(f - 1, d.length);
          }

          r(d, a);

          for (d = d.map(function (a) {
            return {
              size: a.size,
              targets: [a.target],
              align: l(a.align, .5)
            };
          }); g;) {
            for (f = d.length; f--;) g = d[f], v = (Math.min.apply(0, g.targets) + Math.max.apply(0, g.targets)) / 2, g.pos = C(v - g.size * g.align, 0, e - g.size);

            f = d.length;

            for (g = !1; f--;) 0 < f && d[f - 1].pos + d[f - 1].size > d[f].pos && (d[f - 1].size += d[f].size, d[f - 1].targets = d[f - 1].targets.concat(d[f].targets), d[f - 1].align = .5, d[f - 1].pos + d[f - 1].size > e && (d[f - 1].pos = e - d[f - 1].size), d.splice(f, 1), g = !0);
          }

          n.push.apply(n, m);
          f = 0;
          d.some(function (a) {
            var d = 0;
            if (a.targets.some(function () {
              n[f].pos = a.pos + d;
              if ("undefined" !== typeof c && Math.abs(n[f].pos - n[f].target) > c) return n.slice(0, f + 1).forEach(function (a) {
                delete a.pos;
              }), n.reducedLen = (n.reducedLen || e) - .1 * e, n.reducedLen > .1 * e && h.distribute(n, e, c), !0;
              d += n[f].size;
              f++;
            })) return !0;
          });
          r(n, a);
        };

        m.prototype.drawDataLabels = function () {
          function d(a, c) {
            var d = c.filter;
            return d ? (c = d.operator, a = a[d.property], d = d.value, ">" === c && a > d || "<" === c && a < d || ">=" === c && a >= d || "<=" === c && a <= d || "==" === c && a == d || "===" === c && a === d ? !0 : !1) : !0;
          }

          function e(a, c) {
            var d = [],
                b;
            if (x(a) && !x(c)) d = a.map(function (a) {
              return D(a, c);
            });else if (x(c) && !x(a)) d = c.map(function (b) {
              return D(a, b);
            });else if (x(a) || x(c)) for (b = Math.max(a.length, c.length); b--;) d[b] = D(a[b], c[b]);else d = D(a, c);
            return d;
          }

          var c = this,
              a = c.chart,
              f = c.options,
              h = f.dataLabels,
              m = c.points,
              r,
              G = c.hasRendered || 0,
              z = h.animation;
          z = h.defer ? F(a, z, c) : {
            defer: 0,
            duration: 0
          };
          var C = a.renderer;
          h = e(e(a.options.plotOptions && a.options.plotOptions.series && a.options.plotOptions.series.dataLabels, a.options.plotOptions && a.options.plotOptions[c.type] && a.options.plotOptions[c.type].dataLabels), h);
          I(this, "drawDataLabels");

          if (x(h) || h.enabled || c._hasPointLabels) {
            var J = c.plotGroup("dataLabelsGroup", "data-labels", G ? "inherit" : "hidden", h.zIndex || 6);
            J.attr({
              opacity: +G
            });
            !G && (G = c.dataLabelsGroup) && (c.visible && J.show(!0), G[f.animation ? "animate" : "attr"]({
              opacity: 1
            }, z));
            m.forEach(function (g) {
              r = w(e(h, g.dlOptions || g.options && g.options.dataLabels));
              r.forEach(function (e, h) {
                var b = e.enabled && (!g.isNull || g.dataLabelOnNull) && d(g, e),
                    k = g.dataLabels ? g.dataLabels[h] : g.dataLabel,
                    p = g.connectors ? g.connectors[h] : g.connector,
                    m = l(e.distance, g.labelDistance),
                    q = !k;

                if (b) {
                  var u = g.getLabelConfig();
                  var r = l(e[g.formatPrefix + "Format"], e.format);
                  u = y(r) ? v(r, u, a) : (e[g.formatPrefix + "Formatter"] || e.formatter).call(u, e);
                  r = e.style;
                  var A = e.rotation;
                  a.styledMode || (r.color = l(e.color, r.color, c.color, "#000000"), "contrast" === r.color ? (g.contrastColor = C.getContrast(g.color || c.color), r.color = !y(m) && e.inside || 0 > m || f.stacking ? g.contrastColor : "#000000") : delete g.contrastColor, f.cursor && (r.cursor = f.cursor));
                  var w = {
                    r: e.borderRadius || 0,
                    rotation: A,
                    padding: e.padding,
                    zIndex: 1
                  };
                  a.styledMode || (w.fill = e.backgroundColor, w.stroke = e.borderColor, w["stroke-width"] = e.borderWidth);
                  n(w, function (a, b) {
                    "undefined" === typeof a && delete w[b];
                  });
                }

                !k || b && y(u) ? b && y(u) && (k ? w.text = u : (g.dataLabels = g.dataLabels || [], k = g.dataLabels[h] = A ? C.text(u, 0, -9999, e.useHTML).addClass("highcharts-data-label") : C.label(u, 0, -9999, e.shape, null, null, e.useHTML, null, "data-label"), h || (g.dataLabel = k), k.addClass(" highcharts-data-label-color-" + g.colorIndex + " " + (e.className || "") + (e.useHTML ? " highcharts-tracker" : ""))), k.options = e, k.attr(w), a.styledMode || k.css(r).shadow(e.shadow), k.added || k.add(J), e.textPath && !e.useHTML && (k.setTextPath(g.getDataLabelPath && g.getDataLabelPath(k) || g.graphic, e.textPath), g.dataLabelPath && !e.textPath.enabled && (g.dataLabelPath = g.dataLabelPath.destroy())), c.alignDataLabel(g, k, e, null, q)) : (g.dataLabel = g.dataLabel && g.dataLabel.destroy(), g.dataLabels && (1 === g.dataLabels.length ? delete g.dataLabels : delete g.dataLabels[h]), h || delete g.dataLabel, p && (g.connector = g.connector.destroy(), g.connectors && (1 === g.connectors.length ? delete g.connectors : delete g.connectors[h])));
              });
            });
          }

          I(this, "afterDrawDataLabels");
        };

        m.prototype.alignDataLabel = function (d, g, c, a, f) {
          var h = this,
              n = this.chart,
              m = this.isCartesian && n.inverted,
              q = this.enabledDataSorting,
              r = l(d.dlBox && d.dlBox.centerX, d.plotX, -9999),
              v = l(d.plotY, -9999),
              w = g.getBBox(),
              x = c.rotation,
              y = c.align,
              u = n.isInsidePlot(r, Math.round(v), m),
              b = "justify" === l(c.overflow, q ? "none" : "justify"),
              k = this.visible && !1 !== d.visible && (d.series.forceDL || q && !b || u || c.inside && a && n.isInsidePlot(r, m ? a.x + 1 : a.y + a.height - 1, m));

          var t = function t(a) {
            q && h.xAxis && !b && h.setDataLabelStartPos(d, g, f, u, a);
          };

          if (k) {
            var z = n.renderer.fontMetrics(n.styledMode ? void 0 : c.style.fontSize, g).b;
            a = e({
              x: m ? this.yAxis.len - v : r,
              y: Math.round(m ? this.xAxis.len - r : v),
              width: 0,
              height: 0
            }, a);
            e(c, {
              width: w.width,
              height: w.height
            });
            x ? (b = !1, r = n.renderer.rotCorr(z, x), r = {
              x: a.x + (c.x || 0) + a.width / 2 + r.x,
              y: a.y + (c.y || 0) + {
                top: 0,
                middle: .5,
                bottom: 1
              }[c.verticalAlign] * a.height
            }, t(r), g[f ? "attr" : "animate"](r).attr({
              align: y
            }), t = (x + 720) % 360, t = 180 < t && 360 > t, "left" === y ? r.y -= t ? w.height : 0 : "center" === y ? (r.x -= w.width / 2, r.y -= w.height / 2) : "right" === y && (r.x -= w.width, r.y -= t ? 0 : w.height), g.placed = !0, g.alignAttr = r) : (t(a), g.align(c, null, a), r = g.alignAttr);
            b && 0 <= a.height ? this.justifyDataLabel(g, c, r, w, a, f) : l(c.crop, !0) && (k = n.isInsidePlot(r.x, r.y) && n.isInsidePlot(r.x + w.width, r.y + w.height));
            if (c.shape && !x) g[f ? "attr" : "animate"]({
              anchorX: m ? n.plotWidth - d.plotY : d.plotX,
              anchorY: m ? n.plotHeight - d.plotX : d.plotY
            });
          }

          f && q && (g.placed = !1);
          k || q && !b || (g.hide(!0), g.placed = !1);
        };

        m.prototype.setDataLabelStartPos = function (d, e, c, a, f) {
          var g = this.chart,
              h = g.inverted,
              l = this.xAxis,
              n = l.reversed,
              m = h ? e.height / 2 : e.width / 2;
          d = (d = d.pointWidth) ? d / 2 : 0;
          l = h ? f.x : n ? -m - d : l.width - m + d;
          f = h ? n ? this.yAxis.height - m + d : -m - d : f.y;
          e.startXPos = l;
          e.startYPos = f;
          a ? "hidden" === e.visibility && (e.show(), e.attr({
            opacity: 0
          }).animate({
            opacity: 1
          })) : e.attr({
            opacity: 1
          }).animate({
            opacity: 0
          }, void 0, e.hide);
          g.hasRendered && (c && e.attr({
            x: e.startXPos,
            y: e.startYPos
          }), e.placed = !0);
        };

        m.prototype.justifyDataLabel = function (d, e, c, a, f, h) {
          var g = this.chart,
              p = e.align,
              l = e.verticalAlign,
              n = d.box ? 0 : d.padding || 0,
              m = e.x;
          m = void 0 === m ? 0 : m;
          var q = e.y;
          var r = void 0 === q ? 0 : q;
          q = c.x + n;

          if (0 > q) {
            "right" === p && 0 <= m ? (e.align = "left", e.inside = !0) : m -= q;
            var v = !0;
          }

          q = c.x + a.width - n;
          q > g.plotWidth && ("left" === p && 0 >= m ? (e.align = "right", e.inside = !0) : m += g.plotWidth - q, v = !0);
          q = c.y + n;
          0 > q && ("bottom" === l && 0 <= r ? (e.verticalAlign = "top", e.inside = !0) : r -= q, v = !0);
          q = c.y + a.height - n;
          q > g.plotHeight && ("top" === l && 0 >= r ? (e.verticalAlign = "bottom", e.inside = !0) : r += g.plotHeight - q, v = !0);
          v && (e.x = m, e.y = r, d.placed = !h, d.align(e, void 0, f));
          return v;
        };

        L.pie && (L.pie.prototype.dataLabelPositioners = {
          radialDistributionY: function radialDistributionY(d) {
            return d.top + d.distributeBox.pos;
          },
          radialDistributionX: function radialDistributionX(d, e, c, a) {
            return d.getX(c < e.top + 2 || c > e.bottom - 2 ? a : c, e.half, e);
          },
          justify: function justify(d, e, c) {
            return c[0] + (d.half ? -1 : 1) * (e + d.labelDistance);
          },
          alignToPlotEdges: function alignToPlotEdges(d, e, c, a) {
            d = d.getBBox().width;
            return e ? d + a : c - d - a;
          },
          alignToConnectors: function alignToConnectors(d, e, c, a) {
            var f = 0,
                g;
            d.forEach(function (a) {
              g = a.dataLabel.getBBox().width;
              g > f && (f = g);
            });
            return e ? f + a : c - f - a;
          }
        }, L.pie.prototype.drawDataLabels = function () {
          var d = this,
              e = d.data,
              c,
              a = d.chart,
              f = d.options.dataLabels || {},
              p = f.connectorPadding,
              n,
              r = a.plotWidth,
              v = a.plotHeight,
              w = a.plotLeft,
              x = Math.round(a.chartWidth / 3),
              z,
              C = d.center,
              E = C[2] / 2,
              u = C[1],
              b,
              k,
              t,
              F,
              I = [[], []],
              J,
              L,
              N,
              P,
              S = [0, 0, 0, 0],
              Y = d.dataLabelPositioners,
              W;
          d.visible && (f.enabled || d._hasPointLabels) && (e.forEach(function (a) {
            a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({
              width: "auto"
            }).css({
              width: "auto",
              textOverflow: "clip"
            }), a.dataLabel.shortened = !1);
          }), m.prototype.drawDataLabels.apply(d), e.forEach(function (a) {
            a.dataLabel && (a.visible ? (I[a.half].push(a), a.dataLabel._pos = null, !y(f.style.width) && !y(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > x && (a.dataLabel.css({
              width: Math.round(.7 * x) + "px"
            }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));
          }), I.forEach(function (e, g) {
            var n = e.length,
                m = [],
                q;

            if (n) {
              d.sortByAngle(e, g - .5);

              if (0 < d.maxLabelDistance) {
                var A = Math.max(0, u - E - d.maxLabelDistance);
                var B = Math.min(u + E + d.maxLabelDistance, a.plotHeight);
                e.forEach(function (b) {
                  0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, u - E - b.labelDistance), b.bottom = Math.min(u + E + b.labelDistance, a.plotHeight), q = b.dataLabel.getBBox().height || 21, b.distributeBox = {
                    target: b.labelPosition.natural.y - b.top + q / 2,
                    size: q,
                    rank: b.y
                  }, m.push(b.distributeBox));
                });
                A = B + q - A;
                h.distribute(m, A, A / 5);
              }

              for (P = 0; P < n; P++) {
                c = e[P];
                t = c.labelPosition;
                b = c.dataLabel;
                N = !1 === c.visible ? "hidden" : "inherit";
                L = A = t.natural.y;
                m && y(c.distributeBox) && ("undefined" === typeof c.distributeBox.pos ? N = "hidden" : (F = c.distributeBox.size, L = Y.radialDistributionY(c)));
                delete c.positionIndex;
                if (f.justify) J = Y.justify(c, E, C);else switch (f.alignTo) {
                  case "connectors":
                    J = Y.alignToConnectors(e, g, r, w);
                    break;

                  case "plotEdges":
                    J = Y.alignToPlotEdges(b, g, r, w);
                    break;

                  default:
                    J = Y.radialDistributionX(d, c, L, A);
                }
                b._attr = {
                  visibility: N,
                  align: t.alignment
                };
                W = c.options.dataLabels || {};
                b._pos = {
                  x: J + l(W.x, f.x) + ({
                    left: p,
                    right: -p
                  }[t.alignment] || 0),
                  y: L + l(W.y, f.y) - 10
                };
                t["final"].x = J;
                t["final"].y = L;
                l(f.crop, !0) && (k = b.getBBox().width, A = null, J - k < p && 1 === g ? (A = Math.round(k - J + p), S[3] = Math.max(A, S[3])) : J + k > r - p && 0 === g && (A = Math.round(J + k - r + p), S[1] = Math.max(A, S[1])), 0 > L - F / 2 ? S[0] = Math.max(Math.round(-L + F / 2), S[0]) : L + F / 2 > v && (S[2] = Math.max(Math.round(L + F / 2 - v), S[2])), b.sideOverflow = A);
              }
            }
          }), 0 === K(S) || this.verifyDataLabelOverflow(S)) && (this.placeDataLabels(), this.points.forEach(function (c) {
            W = D(f, c.options.dataLabels);

            if (n = l(W.connectorWidth, 1)) {
              var e;
              z = c.connector;

              if ((b = c.dataLabel) && b._pos && c.visible && 0 < c.labelDistance) {
                N = b._attr.visibility;
                if (e = !z) c.connector = z = a.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + c.colorIndex + (c.className ? " " + c.className : "")).add(d.dataLabelsGroup), a.styledMode || z.attr({
                  "stroke-width": n,
                  stroke: W.connectorColor || c.color || "#666666"
                });
                z[e ? "attr" : "animate"]({
                  d: c.getConnectorPath()
                });
                z.attr("visibility", N);
              } else z && (c.connector = z.destroy());
            }
          }));
        }, L.pie.prototype.placeDataLabels = function () {
          this.points.forEach(function (d) {
            var e = d.dataLabel,
                c;
            e && d.visible && ((c = e._pos) ? (e.sideOverflow && (e._attr.width = Math.max(e.getBBox().width - e.sideOverflow, 0), e.css({
              width: e._attr.width + "px",
              textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
            }), e.shortened = !0), e.attr(e._attr), e[e.moved ? "animate" : "attr"](c), e.moved = !0) : e && e.attr({
              y: -9999
            }));
            delete d.distributeBox;
          }, this);
        }, L.pie.prototype.alignDataLabel = f, L.pie.prototype.verifyDataLabelOverflow = function (d) {
          var e = this.center,
              c = this.options,
              a = c.center,
              f = c.minSize || 80,
              h = null !== c.size;

          if (!h) {
            if (null !== a[0]) var l = Math.max(e[2] - Math.max(d[1], d[3]), f);else l = Math.max(e[2] - d[1] - d[3], f), e[0] += (d[3] - d[1]) / 2;
            null !== a[1] ? l = C(l, f, e[2] - Math.max(d[0], d[2])) : (l = C(l, f, e[2] - d[0] - d[2]), e[1] += (d[0] - d[2]) / 2);
            l < e[2] ? (e[2] = l, e[3] = Math.min(J(c.innerSize || 0, l), l), this.translate(e), this.drawDataLabels && this.drawDataLabels()) : h = !0;
          }

          return h;
        });
        L.column && (L.column.prototype.alignDataLabel = function (d, e, c, a, f) {
          var g = this.chart.inverted,
              h = d.series,
              n = d.dlBox || d.shapeArgs,
              q = l(d.below, d.plotY > l(this.translatedThreshold, h.yAxis.len)),
              r = l(c.inside, !!this.options.stacking);
          n && (a = D(n), 0 > a.y && (a.height += a.y, a.y = 0), n = a.y + a.height - h.yAxis.len, 0 < n && n < a.height && (a.height -= n), g && (a = {
            x: h.yAxis.len - a.y - a.height,
            y: h.xAxis.len - a.x - a.width,
            width: a.height,
            height: a.width
          }), r || (g ? (a.x += q ? 0 : a.width, a.width = 0) : (a.y += q ? a.height : 0, a.height = 0)));
          c.align = l(c.align, !g || r ? "center" : q ? "right" : "left");
          c.verticalAlign = l(c.verticalAlign, g || r ? "middle" : q ? "top" : "bottom");
          m.prototype.alignDataLabel.call(this, d, e, c, a, f);
          c.inside && d.contrastColor && e.css({
            color: d.contrastColor
          });
        });
      });
      N(m, "Extensions/OverlappingDataLabels.js", [m["Core/Chart/Chart.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.addEvent,
            z = h.fireEvent,
            F = h.isArray,
            L = h.isNumber,
            K = h.objectEach,
            C = h.pick;
        m(f, "render", function () {
          var f = [];
          (this.labelCollectors || []).forEach(function (e) {
            f = f.concat(e());
          });
          (this.yAxis || []).forEach(function (e) {
            e.stacking && e.options.stackLabels && !e.options.stackLabels.allowOverlap && K(e.stacking.stacks, function (e) {
              K(e, function (e) {
                f.push(e.label);
              });
            });
          });
          (this.series || []).forEach(function (e) {
            var h = e.options.dataLabels;
            e.visible && (!1 !== h.enabled || e._hasPointLabels) && (e.nodes || e.points).forEach(function (e) {
              e.visible && (F(e.dataLabels) ? e.dataLabels : e.dataLabel ? [e.dataLabel] : []).forEach(function (h) {
                var m = h.options;
                h.labelrank = C(m.labelrank, e.labelrank, e.shapeArgs && e.shapeArgs.height);
                m.allowOverlap || f.push(h);
              });
            });
          });
          this.hideOverlappingLabels(f);
        });

        f.prototype.hideOverlappingLabels = function (f) {
          var e = this,
              h = f.length,
              m = e.renderer,
              x,
              y,
              n,
              l = !1;

          var C = function C(d) {
            var e,
                c = d.box ? 0 : d.padding || 0,
                a = e = 0,
                f;

            if (d && (!d.alignAttr || d.placed)) {
              var h = d.alignAttr || {
                x: d.attr("x"),
                y: d.attr("y")
              };
              var l = d.parentGroup;
              d.width || (e = d.getBBox(), d.width = e.width, d.height = e.height, e = m.fontMetrics(null, d.element).h);
              var n = d.width - 2 * c;
              (f = {
                left: "0",
                center: "0.5",
                right: "1"
              }[d.alignValue]) ? a = +f * n : L(d.x) && Math.round(d.x) !== d.translateX && (a = d.x - d.translateX);
              return {
                x: h.x + (l.translateX || 0) + c - (a || 0),
                y: h.y + (l.translateY || 0) + c - e,
                width: d.width - 2 * c,
                height: d.height - 2 * c
              };
            }
          };

          for (y = 0; y < h; y++) if (x = f[y]) x.oldOpacity = x.opacity, x.newOpacity = 1, x.absoluteBox = C(x);

          f.sort(function (d, e) {
            return (e.labelrank || 0) - (d.labelrank || 0);
          });

          for (y = 0; y < h; y++) {
            var w = (C = f[y]) && C.absoluteBox;

            for (x = y + 1; x < h; ++x) {
              var r = (n = f[x]) && n.absoluteBox;
              !w || !r || C === n || 0 === C.newOpacity || 0 === n.newOpacity || r.x >= w.x + w.width || r.x + r.width <= w.x || r.y >= w.y + w.height || r.y + r.height <= w.y || ((C.labelrank < n.labelrank ? C : n).newOpacity = 0);
            }
          }

          f.forEach(function (d) {
            if (d) {
              var f = d.newOpacity;
              d.oldOpacity !== f && (d.alignAttr && d.placed ? (d[f ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), l = !0, d.alignAttr.opacity = f, d[d.isOld ? "animate" : "attr"](d.alignAttr, null, function () {
                e.styledMode || d.css({
                  pointerEvents: f ? "auto" : "none"
                });
                d.visibility = f ? "inherit" : "hidden";
              }), z(e, "afterHideOverlappingLabel")) : d.attr({
                opacity: f
              }));
              d.isOld = !0;
            }
          });
          l && z(e, "afterHideAllOverlappingLabels");
        };
      });
      N(m, "Core/Interaction.js", [m["Core/Series/Series.js"], m["Core/Chart/Chart.js"], m["Core/Globals.js"], m["Core/Legend.js"], m["Series/LineSeries.js"], m["Core/Options.js"], m["Core/Series/Point.js"], m["Core/Utilities.js"]], function (f, h, m, z, F, L, K, C) {
        f = f.seriesTypes;
        var y = m.hasTouch,
            e = m.svg,
            I = L.defaultOptions,
            v = C.addEvent,
            x = C.createElement,
            D = C.css,
            n = C.defined,
            l = C.extend,
            J = C.fireEvent,
            w = C.isArray,
            r = C.isFunction,
            d = C.isNumber,
            g = C.isObject,
            c = C.merge,
            a = C.objectEach,
            q = C.pick;
        "";
        m = m.TrackerMixin = {
          drawTrackerPoint: function drawTrackerPoint() {
            var a = this,
                c = a.chart,
                d = c.pointer,
                e = function e(a) {
              var c = d.getPointFromEvent(a);
              "undefined" !== typeof c && (d.isDirectTouch = !0, c.onMouseOver(a));
            },
                f;

            a.points.forEach(function (a) {
              f = w(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];
              a.graphic && (a.graphic.element.point = a);
              f.forEach(function (c) {
                c.div ? c.div.point = a : c.element.point = a;
              });
            });
            a._hasTracking || (a.trackerGroups.forEach(function (f) {
              if (a[f]) {
                a[f].addClass("highcharts-tracker").on("mouseover", e).on("mouseout", function (a) {
                  d.onTrackerMouseOut(a);
                });
                if (y) a[f].on("touchstart", e);
                !c.styledMode && a.options.cursor && a[f].css(D).css({
                  cursor: a.options.cursor
                });
              }
            }), a._hasTracking = !0);
            J(this, "afterDrawTracker");
          },
          drawTrackerGraph: function drawTrackerGraph() {
            var a = this,
                c = a.options,
                d = c.trackByArea,
                f = [].concat(d ? a.areaPath : a.graphPath),
                g = a.chart,
                h = g.pointer,
                l = g.renderer,
                n = g.options.tooltip.snap,
                m = a.tracker,
                q = function q(b) {
              if (g.hoverSeries !== a) a.onMouseOver();
            },
                b = "rgba(192,192,192," + (e ? .0001 : .002) + ")";

            m ? m.attr({
              d: f
            }) : a.graph && (a.tracker = l.path(f).attr({
              visibility: a.visible ? "visible" : "hidden",
              zIndex: 2
            }).addClass(d ? "highcharts-tracker-area" : "highcharts-tracker-line").add(a.group), g.styledMode || a.tracker.attr({
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              stroke: b,
              fill: d ? b : "none",
              "stroke-width": a.graph.strokeWidth() + (d ? 0 : 2 * n)
            }), [a.tracker, a.markerGroup].forEach(function (a) {
              a.addClass("highcharts-tracker").on("mouseover", q).on("mouseout", function (a) {
                h.onTrackerMouseOut(a);
              });
              c.cursor && !g.styledMode && a.css({
                cursor: c.cursor
              });
              if (y) a.on("touchstart", q);
            }));
            J(this, "afterDrawTracker");
          }
        };
        f.column && (f.column.prototype.drawTracker = m.drawTrackerPoint);
        f.pie && (f.pie.prototype.drawTracker = m.drawTrackerPoint);
        f.scatter && (f.scatter.prototype.drawTracker = m.drawTrackerPoint);
        l(z.prototype, {
          setItemEvents: function setItemEvents(a, d, e) {
            var f = this,
                g = f.chart.renderer.boxWrapper,
                h = a instanceof K,
                p = "highcharts-legend-" + (h ? "point" : "series") + "-active",
                l = f.chart.styledMode;
            (e ? [d, a.legendSymbol] : [a.legendGroup]).forEach(function (e) {
              if (e) e.on("mouseover", function () {
                a.visible && f.allItems.forEach(function (c) {
                  a !== c && c.setState("inactive", !h);
                });
                a.setState("hover");
                a.visible && g.addClass(p);
                l || d.css(f.options.itemHoverStyle);
              }).on("mouseout", function () {
                f.chart.styledMode || d.css(c(a.visible ? f.itemStyle : f.itemHiddenStyle));
                f.allItems.forEach(function (c) {
                  a !== c && c.setState("", !h);
                });
                g.removeClass(p);
                a.setState();
              }).on("click", function (c) {
                var b = function b() {
                  a.setVisible && a.setVisible();
                  f.allItems.forEach(function (b) {
                    a !== b && b.setState(a.visible ? "inactive" : "", !h);
                  });
                };

                g.removeClass(p);
                c = {
                  browserEvent: c
                };
                a.firePointEvent ? a.firePointEvent("legendItemClick", c, b) : J(a, "legendItemClick", c, b);
              });
            });
          },
          createCheckboxForItem: function createCheckboxForItem(a) {
            a.checkbox = x("input", {
              type: "checkbox",
              className: "highcharts-legend-checkbox",
              checked: a.selected,
              defaultChecked: a.selected
            }, this.options.itemCheckboxStyle, this.chart.container);
            v(a.checkbox, "click", function (c) {
              J(a.series || a, "checkboxClick", {
                checked: c.target.checked,
                item: a
              }, function () {
                a.select();
              });
            });
          }
        });
        l(h.prototype, {
          showResetZoom: function showResetZoom() {
            function a() {
              c.zoomOut();
            }

            var c = this,
                d = I.lang,
                e = c.options.chart.resetZoomButton,
                f = e.theme,
                g = f.states,
                h = "chart" === e.relativeTo || "spaceBox" === e.relativeTo ? null : "plotBox";
            J(this, "beforeShowResetZoom", null, function () {
              c.resetZoomButton = c.renderer.button(d.resetZoom, null, null, a, f, g && g.hover).attr({
                align: e.position.align,
                title: d.resetZoomTitle
              }).addClass("highcharts-reset-zoom").add().align(e.position, !1, h);
            });
            J(this, "afterShowResetZoom");
          },
          zoomOut: function zoomOut() {
            J(this, "selection", {
              resetSelection: !0
            }, this.zoom);
          },
          zoom: function zoom(a) {
            var c = this,
                d,
                e = c.pointer,
                f = !1,
                h = c.inverted ? e.mouseDownX : e.mouseDownY;
            !a || a.resetSelection ? (c.axes.forEach(function (a) {
              d = a.zoom();
            }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {
              var g = a.axis,
                  p = c.inverted ? g.left : g.top,
                  b = c.inverted ? p + g.width : p + g.height,
                  k = g.isXAxis,
                  l = !1;
              if (!k && h >= p && h <= b || k || !n(h)) l = !0;
              e[k ? "zoomX" : "zoomY"] && l && (d = g.zoom(a.min, a.max), g.displayBtn && (f = !0));
            });
            var p = c.resetZoomButton;
            f && !p ? c.showResetZoom() : !f && g(p) && (c.resetZoomButton = p.destroy());
            d && c.redraw(q(c.options.chart.animation, a && a.animation, 100 > c.pointCount));
          },
          pan: function pan(a, c) {
            var e = this,
                f = e.hoverPoints,
                g = e.options.chart,
                h = e.options.mapNavigation && e.options.mapNavigation.enabled,
                p;
            c = "object" === typeof c ? c : {
              enabled: c,
              type: "x"
            };
            g && g.panning && (g.panning = c);
            var l = c.type;
            J(this, "pan", {
              originalEvent: a
            }, function () {
              f && f.forEach(function (a) {
                a.setState();
              });
              var c = [1];
              "xy" === l ? c = [1, 0] : "y" === l && (c = [0]);
              c.forEach(function (c) {
                var b = e[c ? "xAxis" : "yAxis"][0],
                    f = b.horiz,
                    g = a[f ? "chartX" : "chartY"];
                f = f ? "mouseDownX" : "mouseDownY";
                var n = e[f],
                    m = (b.pointRange || 0) / 2,
                    r = b.reversed && !e.inverted || !b.reversed && e.inverted ? -1 : 1,
                    u = b.getExtremes(),
                    v = b.toValue(n - g, !0) + m * r;
                r = b.toValue(n + b.len - g, !0) - m * r;
                var w = r < v;
                n = w ? r : v;
                v = w ? v : r;
                var A = b.hasVerticalPanning(),
                    x = b.panningState;
                b.series.forEach(function (a) {
                  if (A && !c && (!x || x.isDirty)) {
                    var b = a.getProcessedData(!0);
                    a = a.getExtremes(b.yData, !0);
                    x || (x = {
                      startMin: Number.MAX_VALUE,
                      startMax: -Number.MAX_VALUE
                    });
                    d(a.dataMin) && d(a.dataMax) && (x.startMin = Math.min(a.dataMin, x.startMin), x.startMax = Math.max(a.dataMax, x.startMax));
                  }
                });
                r = Math.min(q(null === x || void 0 === x ? void 0 : x.startMin, u.dataMin), m ? u.min : b.toValue(b.toPixels(u.min) - b.minPixelPadding));
                m = Math.max(q(null === x || void 0 === x ? void 0 : x.startMax, u.dataMax), m ? u.max : b.toValue(b.toPixels(u.max) + b.minPixelPadding));
                b.panningState = x;
                b.isOrdinal || (w = r - n, 0 < w && (v += w, n = r), w = v - m, 0 < w && (v = m, n -= w), b.series.length && n !== u.min && v !== u.max && n >= r && v <= m && (b.setExtremes(n, v, !1, !1, {
                  trigger: "pan"
                }), e.resetZoomButton || h || n === r || v === m || !l.match("y") || (e.showResetZoom(), b.displayBtn = !1), p = !0), e[f] = g);
              });
              p && e.redraw(!1);
              D(e.container, {
                cursor: "move"
              });
            });
          }
        });
        l(K.prototype, {
          select: function select(a, c) {
            var d = this,
                e = d.series,
                f = e.chart;
            this.selectedStaging = a = q(a, !d.selected);
            d.firePointEvent(a ? "select" : "unselect", {
              accumulate: c
            }, function () {
              d.selected = d.options.selected = a;
              e.options.data[e.data.indexOf(d)] = d.options;
              d.setState(a && "select");
              c || f.getSelectedPoints().forEach(function (a) {
                var c = a.series;
                a.selected && a !== d && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(f.hoverPoints && c.options.inactiveOtherPoints ? "inactive" : ""), a.firePointEvent("unselect"));
              });
            });
            delete this.selectedStaging;
          },
          onMouseOver: function onMouseOver(a) {
            var c = this.series.chart,
                d = c.pointer;
            a = a ? d.normalize(a) : d.getChartCoordinatesFromPoint(this, c.inverted);
            d.runPointActions(a, this);
          },
          onMouseOut: function onMouseOut() {
            var a = this.series.chart;
            this.firePointEvent("mouseOut");
            this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {
              a.setState();
            });
            a.hoverPoints = a.hoverPoint = null;
          },
          importEvents: function importEvents() {
            if (!this.hasImportedEvents) {
              var d = this,
                  e = c(d.series.options.point, d.options).events;
              d.events = e;
              a(e, function (a, c) {
                r(a) && v(d, c, a);
              });
              this.hasImportedEvents = !0;
            }
          },
          setState: function setState(a, c) {
            var d = this.series,
                e = this.state,
                f = d.options.states[a || "normal"] || {},
                g = I.plotOptions[d.type].marker && d.options.marker,
                h = g && !1 === g.enabled,
                p = g && g.states && g.states[a || "normal"] || {},
                n = !1 === p.enabled,
                m = d.stateMarkerGraphic,
                b = this.marker || {},
                k = d.chart,
                r = d.halo,
                v,
                w = g && d.markerAttribs;
            a = a || "";

            if (!(a === this.state && !c || this.selected && "select" !== a || !1 === f.enabled || a && (n || h && !1 === p.enabled) || a && b.states && b.states[a] && !1 === b.states[a].enabled)) {
              this.state = a;
              w && (v = d.markerAttribs(this, a));

              if (this.graphic) {
                e && this.graphic.removeClass("highcharts-point-" + e);
                a && this.graphic.addClass("highcharts-point-" + a);

                if (!k.styledMode) {
                  var x = d.pointAttribs(this, a);
                  var y = q(k.options.chart.animation, f.animation);
                  d.options.inactiveOtherPoints && x.opacity && ((this.dataLabels || []).forEach(function (a) {
                    a && a.animate({
                      opacity: x.opacity
                    }, y);
                  }), this.connector && this.connector.animate({
                    opacity: x.opacity
                  }, y));
                  this.graphic.animate(x, y);
                }

                v && this.graphic.animate(v, q(k.options.chart.animation, p.animation, g.animation));
                m && m.hide();
              } else {
                if (a && p) {
                  e = b.symbol || d.symbol;
                  m && m.currentSymbol !== e && (m = m.destroy());
                  if (v) if (m) m[c ? "animate" : "attr"]({
                    x: v.x,
                    y: v.y
                  });else e && (d.stateMarkerGraphic = m = k.renderer.symbol(e, v.x, v.y, v.width, v.height).add(d.markerGroup), m.currentSymbol = e);
                  !k.styledMode && m && m.attr(d.pointAttribs(this, a));
                }

                m && (m[a && this.isInside ? "show" : "hide"](), m.element.point = this);
              }

              a = f.halo;
              f = (m = this.graphic || m) && m.visibility || "inherit";
              a && a.size && m && "hidden" !== f && !this.isCluster ? (r || (d.halo = r = k.renderer.path().add(m.parentGroup)), r.show()[c ? "animate" : "attr"]({
                d: this.haloPath(a.size)
              }), r.attr({
                "class": "highcharts-halo highcharts-color-" + q(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""),
                visibility: f,
                zIndex: -1
              }), r.point = this, k.styledMode || r.attr(l({
                fill: this.color || d.color,
                "fill-opacity": a.opacity
              }, a.attributes))) : r && r.point && r.point.haloPath && r.animate({
                d: r.point.haloPath(0)
              }, null, r.hide);
              J(this, "afterSetState");
            }
          },
          haloPath: function haloPath(a) {
            return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
          }
        });
        l(F.prototype, {
          onMouseOver: function onMouseOver() {
            var a = this.chart,
                c = a.hoverSeries;
            a.pointer.setHoverChartIndex();
            if (c && c !== this) c.onMouseOut();
            this.options.events.mouseOver && J(this, "mouseOver");
            this.setState("hover");
            a.hoverSeries = this;
          },
          onMouseOut: function onMouseOut() {
            var a = this.options,
                c = this.chart,
                d = c.tooltip,
                e = c.hoverPoint;
            c.hoverSeries = null;
            if (e) e.onMouseOut();
            this && a.events.mouseOut && J(this, "mouseOut");
            !d || this.stickyTracking || d.shared && !this.noSharedTooltip || d.hide();
            c.series.forEach(function (a) {
              a.setState("", !0);
            });
          },
          setState: function setState(a, c) {
            var d = this,
                e = d.options,
                f = d.graph,
                g = e.inactiveOtherPoints,
                h = e.states,
                l = e.lineWidth,
                m = e.opacity,
                n = q(h[a || "normal"] && h[a || "normal"].animation, d.chart.options.chart.animation);
            e = 0;
            a = a || "";

            if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (b) {
              b && (d.state && b.removeClass("highcharts-series-" + d.state), a && b.addClass("highcharts-series-" + a));
            }), d.state = a, !d.chart.styledMode)) {
              if (h[a] && !1 === h[a].enabled) return;
              a && (l = h[a].lineWidth || l + (h[a].lineWidthPlus || 0), m = q(h[a].opacity, m));
              if (f && !f.dashstyle) for (h = {
                "stroke-width": l
              }, f.animate(h, n); d["zone-graph-" + e];) d["zone-graph-" + e].attr(h), e += 1;
              g || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {
                a && a.animate({
                  opacity: m
                }, n);
              });
            }

            c && g && d.points && d.setAllPointsToState(a);
          },
          setAllPointsToState: function setAllPointsToState(a) {
            this.points.forEach(function (c) {
              c.setState && c.setState(a);
            });
          },
          setVisible: function setVisible(a, c) {
            var d = this,
                e = d.chart,
                f = d.legendItem,
                g = e.options.chart.ignoreHiddenSeries,
                h = d.visible;
            var l = (d.visible = a = d.options.visible = d.userOptions.visible = "undefined" === typeof a ? !h : a) ? "show" : "hide";
            ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function (a) {
              if (d[a]) d[a][l]();
            });
            if (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) d.onMouseOut();
            f && e.legend.colorizeItem(d, a);
            d.isDirty = !0;
            d.options.stacking && e.series.forEach(function (a) {
              a.options.stacking && a.visible && (a.isDirty = !0);
            });
            d.linkedSeries.forEach(function (c) {
              c.setVisible(a, !1);
            });
            g && (e.isDirtyBox = !0);
            J(d, l);
            !1 !== c && e.redraw();
          },
          show: function show() {
            this.setVisible(!0);
          },
          hide: function hide() {
            this.setVisible(!1);
          },
          select: function select(a) {
            this.selected = a = this.options.selected = "undefined" === typeof a ? !this.selected : a;
            this.checkbox && (this.checkbox.checked = a);
            J(this, a ? "select" : "unselect");
          },
          drawTracker: m.drawTrackerGraph
        });
      });
      N(m, "Core/Responsive.js", [m["Core/Chart/Chart.js"], m["Core/Utilities.js"]], function (f, h) {
        var m = h.find,
            z = h.isArray,
            F = h.isObject,
            L = h.merge,
            K = h.objectEach,
            C = h.pick,
            y = h.splat,
            e = h.uniqueKey;

        f.prototype.setResponsive = function (f, h) {
          var v = this.options.responsive,
              y = [],
              n = this.currentResponsive;
          !h && v && v.rules && v.rules.forEach(function (f) {
            "undefined" === typeof f._id && (f._id = e());
            this.matchResponsiveRule(f, y);
          }, this);
          h = L.apply(0, y.map(function (e) {
            return m(v.rules, function (f) {
              return f._id === e;
            }).chartOptions;
          }));
          h.isResponsiveOptions = !0;
          y = y.toString() || void 0;
          y !== (n && n.ruleIds) && (n && this.update(n.undoOptions, f, !0), y ? (n = this.currentOptions(h), n.isResponsiveOptions = !0, this.currentResponsive = {
            ruleIds: y,
            mergedOptions: h,
            undoOptions: n
          }, this.update(h, f, !0)) : this.currentResponsive = void 0);
        };

        f.prototype.matchResponsiveRule = function (e, f) {
          var h = e.condition;
          (h.callback || function () {
            return this.chartWidth <= C(h.maxWidth, Number.MAX_VALUE) && this.chartHeight <= C(h.maxHeight, Number.MAX_VALUE) && this.chartWidth >= C(h.minWidth, 0) && this.chartHeight >= C(h.minHeight, 0);
          }).call(this) && f.push(e._id);
        };

        f.prototype.currentOptions = function (e) {
          function f(e, l, m, v) {
            var n;
            K(e, function (d, e) {
              if (!v && -1 < h.collectionsWithUpdate.indexOf(e)) for (d = y(d), m[e] = [], n = 0; n < Math.max(d.length, l[e].length); n++) l[e][n] && (void 0 === d[n] ? m[e][n] = l[e][n] : (m[e][n] = {}, f(d[n], l[e][n], m[e][n], v + 1)));else F(d) ? (m[e] = z(d) ? [] : {}, f(d, l[e] || {}, m[e], v + 1)) : m[e] = "undefined" === typeof l[e] ? null : l[e];
            });
          }

          var h = this,
              m = {};
          f(e, this.options, m, 0);
          return m;
        };
      });
      N(m, "masters/highcharts.src.js", [m["Core/Globals.js"]], function (f) {
        return f;
      });
      m["masters/highcharts.src.js"]._modules = m;
      return m["masters/highcharts.src.js"];
    }); //# sourceMappingURL=highcharts.js.map

    /***/

  },

  /***/
  "./node_modules/jquery/dist/jquery.js":
  /*!********************************************!*\
    !*** ./node_modules/jquery/dist/jquery.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesJqueryDistJqueryJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
    * jQuery JavaScript Library v3.7.0
    * https://jquery.com/
    *
    * Copyright OpenJS Foundation and other contributors
    * Released under the MIT license
    * https://jquery.org/license
    *
    * Date: 2023-05-11T18:29Z
    */


    (function (global, factory) {
      "use strict";

      if (true && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket trac-14549 for more info.
        module.exports = global.document ? factory(global, true) : function (w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }

          return factory(w);
        };
      } else {
        factory(global);
      } // Pass this if window is not defined yet

    })(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
      // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
      // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
      // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
      // enough that all such attempts are guarded in a try block.
      "use strict";

      var arr = [];
      var getProto = Object.getPrototypeOf;
      var _slice = arr.slice;
      var flat = arr.flat ? function (array) {
        return arr.flat.call(array);
      } : function (array) {
        return arr.concat.apply([], array);
      };
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};

      var isFunction = function isFunction(obj) {
        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
        // Plus for old WebKit, typeof returns "function" for HTML collections
        // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };

      var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
      };

      var document = window.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };

      function DOMEval(code, node, doc) {
        doc = doc || document;
        var i,
            val,
            script = doc.createElement("script");
        script.text = code;

        if (node) {
          for (i in preservedScriptAttributes) {
            // Support: Firefox 64+, Edge 18+
            // Some browsers don't support the "nonce" property on scripts.
            // On the other hand, just using `getAttribute` is not enough as
            // the `nonce` attribute is reset to an empty string whenever it
            // becomes browsing-context connected.
            // See https://github.com/whatwg/html/issues/2369
            // See https://html.spec.whatwg.org/#nonce-attributes
            // The `node.getAttribute` check was added for the sake of
            // `jQuery.globalEval` so that it can fake a nonce-containing node
            // via an object.
            val = node[i] || node.getAttribute && node.getAttribute(i);

            if (val) {
              script.setAttribute(i, val);
            }
          }
        }

        doc.head.appendChild(script).parentNode.removeChild(script);
      }

      function toType(obj) {
        if (obj == null) {
          return obj + "";
        } // Support: Android <=2.3 only (functionish RegExp)


        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      /* global Symbol */
      // Defining this global in .eslintrc.json would create a danger of using the global
      // unguarded in another place, it seems safer to define global only for this module


      var version = "3.7.0",
          rhtmlSuffix = /HTML$/i,
          // Define a local copy of jQuery
      jQuery = function jQuery(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
      };

      jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function toArray() {
          return _slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function get(num) {
          // Return all the elements in a clean array
          if (num == null) {
            return _slice.call(this);
          } // Return just the one element from the set


          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function pushStack(elems) {
          // Build a new jQuery matched element set
          var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

          ret.prevObject = this; // Return the newly-formed element set

          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function each(callback) {
          return jQuery.each(this, callback);
        },
        map: function map(callback) {
          return this.pushStack(jQuery.map(this, function (elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function slice() {
          return this.pushStack(_slice.apply(this, arguments));
        },
        first: function first() {
          return this.eq(0);
        },
        last: function last() {
          return this.eq(-1);
        },
        even: function even() {
          return this.pushStack(jQuery.grep(this, function (_elem, i) {
            return (i + 1) % 2;
          }));
        },
        odd: function odd() {
          return this.pushStack(jQuery.grep(this, function (_elem, i) {
            return i % 2;
          }));
        },
        eq: function eq(i) {
          var len = this.length,
              j = +i + (i < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function end() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
      };

      jQuery.extend = jQuery.fn.extend = function () {
        var options,
            name,
            src,
            copy,
            copyIsArray,
            clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false; // Handle a deep copy situation

        if (typeof target === "boolean") {
          deep = target; // Skip the boolean and the target

          target = arguments[i] || {};
          i++;
        } // Handle case when target is a string or something (possible in deep copy)


        if (typeof target !== "object" && !isFunction(target)) {
          target = {};
        } // Extend jQuery itself if only one argument is passed


        if (i === length) {
          target = this;
          i--;
        }

        for (; i < length; i++) {
          // Only deal with non-null/undefined values
          if ((options = arguments[i]) != null) {
            // Extend the base object
            for (name in options) {
              copy = options[name]; // Prevent Object.prototype pollution
              // Prevent never-ending loop

              if (name === "__proto__" || target === copy) {
                continue;
              } // Recurse if we're merging plain objects or arrays


              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name]; // Ensure proper type for the source value

                if (copyIsArray && !Array.isArray(src)) {
                  clone = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone = {};
                } else {
                  clone = src;
                }

                copyIsArray = false; // Never move original objects, clone them

                target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
              } else if (copy !== undefined) {
                target[name] = copy;
              }
            }
          }
        } // Return the modified object


        return target;
      };

      jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function error(msg) {
          throw new Error(msg);
        },
        noop: function noop() {},
        isPlainObject: function isPlainObject(obj) {
          var proto, Ctor; // Detect obvious negatives
          // Use toString instead of jQuery.type to catch host objects

          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }

          proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

          if (!proto) {
            return true;
          } // Objects with prototype are plain iff they were constructed by a global Object function


          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function isEmptyObject(obj) {
          var name;

          for (name in obj) {
            return false;
          }

          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function globalEval(code, options, doc) {
          DOMEval(code, {
            nonce: options && options.nonce
          }, doc);
        },
        each: function each(obj, callback) {
          var length,
              i = 0;

          if (isArrayLike(obj)) {
            length = obj.length;

            for (; i < length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          } else {
            for (i in obj) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          }

          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function text(elem) {
          var node,
              ret = "",
              i = 0,
              nodeType = elem.nodeType;

          if (!nodeType) {
            // If no nodeType, this is expected to be an array
            while (node = elem[i++]) {
              // Do not traverse comment nodes
              ret += jQuery.text(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            return elem.textContent;
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          } // Do not include comment or processing instruction nodes


          return ret;
        },
        // results is for internal usage only
        makeArray: function makeArray(arr, results) {
          var ret = results || [];

          if (arr != null) {
            if (isArrayLike(Object(arr))) {
              jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            } else {
              push.call(ret, arr);
            }
          }

          return ret;
        },
        inArray: function inArray(elem, arr, i) {
          return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        isXMLDoc: function isXMLDoc(elem) {
          var namespace = elem && elem.namespaceURI,
              docElem = elem && (elem.ownerDocument || elem).documentElement; // Assume HTML when documentElement doesn't yet exist, such as inside
          // document fragments.

          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function merge(first, second) {
          var len = +second.length,
              j = 0,
              i = first.length;

          for (; j < len; j++) {
            first[i++] = second[j];
          }

          first.length = i;
          return first;
        },
        grep: function grep(elems, callback, invert) {
          var callbackInverse,
              matches = [],
              i = 0,
              length = elems.length,
              callbackExpect = !invert; // Go through the array, only saving the items
          // that pass the validator function

          for (; i < length; i++) {
            callbackInverse = !callback(elems[i], i);

            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }

          return matches;
        },
        // arg is for internal usage only
        map: function map(elems, callback, arg) {
          var length,
              value,
              i = 0,
              ret = []; // Go through the array, translating each of the items to their new values

          if (isArrayLike(elems)) {
            length = elems.length;

            for (; i < length; i++) {
              value = callback(elems[i], i, arg);

              if (value != null) {
                ret.push(value);
              }
            } // Go through every key on the object,

          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg);

              if (value != null) {
                ret.push(value);
              }
            }
          } // Flatten any nested arrays


          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
      });

      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      } // Populate the class2type map


      jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      });

      function isArrayLike(obj) {
        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType(obj);

        if (isFunction(obj) || isWindow(obj)) {
          return false;
        }

        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }

      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }

      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"); // Note: an element does not contain itself

      jQuery.contains = function (a, b) {
        var bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && ( // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        a.contains ? a.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      }; // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms


      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          } // Control characters and (dependent upon position) numbers get escaped as code points


          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        } // Other potentially-special ASCII characters get backslash-escaped


        return "\\" + ch;
      }

      jQuery.escapeSelector = function (sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };

      var preferredDoc = document,
          pushNative = push;

      (function () {
        var i,
            Expr,
            outermostContext,
            sortInput,
            hasDuplicate,
            push = pushNative,
            // Local document vars
        document,
            documentElement,
            documentIsHTML,
            rbuggyQSA,
            matches,
            // Instance-specific data
        expando = jQuery.expando,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            nonnativeSelectorCache = createCache(),
            sortOrder = function sortOrder(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }

          return 0;
        },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" + "loop|multiple|open|readonly|required|scoped",
            // Regular expressions
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
        identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
            // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)",
            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rdescend = new RegExp(whitespace + "|>"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,
            // CSS escapes
        // https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
            funescape = function funescape(escape, nonHex) {
          var high = "0x" + escape.slice(1) - 0x10000;

          if (nonHex) {
            // Strip the backslash prefix from a non-hex escape sequence
            return nonHex;
          } // Replace a hexadecimal escape sequence with the encoded Unicode code point
          // Support: IE <=11+
          // For values outside the Basic Multilingual Plane (BMP), manually construct a
          // surrogate pair


          return high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
            // Used for iframes; see `setDocument`.
        // Support: IE 9 - 11+, Edge 12 - 18+
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE/Edge.
        unloadHandler = function unloadHandler() {
          setDocument();
        },
            inDisabledFieldset = addCombinator(function (elem) {
          return elem.disabled === true && nodeName(elem, "fieldset");
        }, {
          dir: "parentNode",
          next: "legend"
        }); // Support: IE <=9 only
        // Accessing document.activeElement can throw unexpectedly
        // https://bugs.jquery.com/ticket/13393


        function safeActiveElement() {
          try {
            return document.activeElement;
          } catch (err) {}
        } // Optimize for push.apply( _, NodeList )


        try {
          push.apply(arr = _slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android <=4.0
          // Detect silently failing push.apply
          // eslint-disable-next-line no-unused-expressions

          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push = {
            apply: function apply(target, els) {
              pushNative.apply(target, _slice.call(els));
            },
            call: function call(target) {
              pushNative.apply(target, _slice.call(arguments, 1));
            }
          };
        }

        function find(selector, context, results, seed) {
          var m,
              i,
              elem,
              nid,
              match,
              groups,
              newSelector,
              newContext = context && context.ownerDocument,
              // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;
          results = results || []; // Return early from calls with invalid selector or context

          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          } // Try to shortcut find operations (as opposed to filters) in HTML documents


          if (!seed) {
            setDocument(context);
            context = context || document;

            if (documentIsHTML) {
              // If the selector is sufficiently simple, try using a "get*By*" DOM method
              // (excepting DocumentFragment context, where the methods don't exist)
              if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                // ID selector
                if (m = match[1]) {
                  // Document context
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      // Support: IE 9 only
                      // getElementById can match elements by name instead of ID
                      if (elem.id === m) {
                        push.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    } // Element context

                  } else {
                    // Support: IE 9 only
                    // getElementById can match elements by name instead of ID
                    if (newContext && (elem = newContext.getElementById(m)) && find.contains(context, elem) && elem.id === m) {
                      push.call(results, elem);
                      return results;
                    }
                  } // Type selector

                } else if (match[2]) {
                  push.apply(results, context.getElementsByTagName(selector));
                  return results; // Class selector
                } else if ((m = match[3]) && context.getElementsByClassName) {
                  push.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              } // Take advantage of querySelectorAll


              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context; // qSA considers elements outside a scoping root when evaluating child or
                // descendant combinators, which is not what we want.
                // In such cases, we work around the behavior by prefixing every selector in the
                // list with an ID selector referencing the scope context.
                // The technique has to be used as well when a leading combinator is used
                // as such selectors are not recognized by querySelectorAll.
                // Thanks to Andrew Dupont for this technique.

                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  // Expand context for sibling selectors
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
                  // supports it & if we're not changing the context.
                  // Support: IE 11+, Edge 17 - 18+
                  // IE/Edge sometimes throw a "Permission denied" error when
                  // strict-comparing two documents; shallow comparisons work.
                  // eslint-disable-next-line eqeqeq

                  if (newContext != context || !support.scope) {
                    // Capture the context ID, setting it first if necessary
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  } // Prefix every selector in the list


                  groups = tokenize(selector);
                  i = groups.length;

                  while (i--) {
                    groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                  }

                  newSelector = groups.join(",");
                }

                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          } // All others


          return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        /**
         * Create key-value caches of limited size
         * @returns {function(string, object)} Returns the Object data after storing it on itself with
         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
         *	deleting the oldest entry
         */


        function createCache() {
          var keys = [];

          function cache(key, value) {
            // Use (key + " ") to avoid collision with native prototype properties
            // (see https://github.com/jquery/sizzle/issues/157)
            if (keys.push(key + " ") > Expr.cacheLength) {
              // Only keep the most recent entries
              delete cache[keys.shift()];
            }

            return cache[key + " "] = value;
          }

          return cache;
        }
        /**
         * Mark a function for special use by jQuery selector module
         * @param {Function} fn The function to mark
         */


        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        /**
         * Support testing using an element
         * @param {Function} fn Passed the created element and returns a boolean result
         */


        function assert(fn) {
          var el = document.createElement("fieldset");

          try {
            return !!fn(el);
          } catch (e) {
            return false;
          } finally {
            // Remove from its parent by default
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            } // release memory in IE


            el = null;
          }
        }
        /**
         * Returns a function to use in pseudos for input types
         * @param {String} type
         */


        function createInputPseudo(type) {
          return function (elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        /**
         * Returns a function to use in pseudos for buttons
         * @param {String} type
         */


        function createButtonPseudo(type) {
          return function (elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        /**
         * Returns a function to use in pseudos for :enabled/:disabled
         * @param {Boolean} disabled true for :disabled; false for :enabled
         */


        function createDisabledPseudo(disabled) {
          // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
          return function (elem) {
            // Only certain elements can match :enabled or :disabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
            if ("form" in elem) {
              // Check for inherited disabledness on relevant non-disabled elements:
              // * listed form-associated elements in a disabled fieldset
              //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
              //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
              // * option elements in a disabled optgroup
              //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
              // All such elements have a "form" property.
              if (elem.parentNode && elem.disabled === false) {
                // Option elements defer to a parent optgroup if present
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                } // Support: IE 6 - 11+
                // Use the isDisabled shortcut property to check for disabled fieldset ancestors


                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }

              return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
              // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
              // even exist on them, let alone have a boolean value.
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            } // Remaining elements are neither :enabled nor :disabled


            return false;
          };
        }
        /**
         * Returns a function to use in pseudos for positionals
         * @param {Function} fn
         */


        function createPositionalPseudo(fn) {
          return markFunction(function (argument) {
            argument = +argument;
            return markFunction(function (seed, matches) {
              var j,
                  matchIndexes = fn([], seed.length, argument),
                  i = matchIndexes.length; // Match elements found at the specified indexes

              while (i--) {
                if (seed[j = matchIndexes[i]]) {
                  seed[j] = !(matches[j] = seed[j]);
                }
              }
            });
          });
        }
        /**
         * Checks a node for validity as a jQuery selector context
         * @param {Element|Object=} context
         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
         */


        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        /**
         * Sets document-related variables once based on the current document
         * @param {Element|Object} [node] An element or document object to use to set the document
         * @returns {Object} Returns the current document
         */


        function setDocument(node) {
          var subWindow,
              doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq

          if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
            return document;
          } // Update global variables


          document = doc;
          documentElement = document.documentElement;
          documentIsHTML = !jQuery.isXMLDoc(document); // Support: iOS 7 only, IE 9 - 11+
          // Older browsers didn't support unprefixed `matches`.

          matches = documentElement.matches || documentElement.webkitMatchesSelector || documentElement.msMatchesSelector; // Support: IE 9 - 11+, Edge 12 - 18+
          // Accessing iframe documents after unload throws "permission denied" errors (see trac-13936)
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq

          if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
            // Support: IE 9 - 11+, Edge 12 - 18+
            subWindow.addEventListener("unload", unloadHandler);
          } // Support: IE <10
          // Check if getElementById returns elements by name
          // The broken getElementById methods don't pick up programmatically-set names,
          // so use a roundabout getElementsByName test


          support.getById = assert(function (el) {
            documentElement.appendChild(el).id = jQuery.expando;
            return !document.getElementsByName || !document.getElementsByName(jQuery.expando).length;
          }); // Support: IE 9 only
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node.

          support.disconnectedMatch = assert(function (el) {
            return matches.call(el, "*");
          }); // Support: IE 9 - 11+, Edge 12 - 18+
          // IE/Edge don't support the :scope pseudo-class.

          support.scope = assert(function () {
            return document.querySelectorAll(":scope");
          }); // Support: Chrome 105 - 111 only, Safari 15.4 - 16.3 only
          // Make sure the `:has()` argument is parsed unforgivingly.
          // We include `*` in the test to detect buggy implementations that are
          // _selectively_ forgiving (specifically when the list includes at least
          // one valid selector).
          // Note that we treat complete lack of support for `:has()` as if it were
          // spec-compliant support, which is fine because use of `:has()` in such
          // environments will fail in the qSA path and fall back to jQuery traversal
          // anyway.

          support.cssHas = assert(function () {
            try {
              document.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e) {
              return true;
            }
          }); // ID filter and find

          if (support.getById) {
            Expr.filter.ID = function (id) {
              var attrId = id.replace(runescape, funescape);
              return function (elem) {
                return elem.getAttribute("id") === attrId;
              };
            };

            Expr.find.ID = function (id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function (id) {
              var attrId = id.replace(runescape, funescape);
              return function (elem) {
                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node && node.value === attrId;
              };
            }; // Support: IE 6 - 7 only
            // getElementById is not reliable as a find shortcut


            Expr.find.ID = function (id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node,
                    i,
                    elems,
                    elem = context.getElementById(id);

                if (elem) {
                  // Verify the id attribute
                  node = elem.getAttributeNode("id");

                  if (node && node.value === id) {
                    return [elem];
                  } // Fall back on getElementsByName


                  elems = context.getElementsByName(id);
                  i = 0;

                  while (elem = elems[i++]) {
                    node = elem.getAttributeNode("id");

                    if (node && node.value === id) {
                      return [elem];
                    }
                  }
                }

                return [];
              }
            };
          } // Tag


          Expr.find.TAG = function (tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
            } else {
              return context.querySelectorAll(tag);
            }
          }; // Class


          Expr.find.CLASS = function (className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          /* QSA/matchesSelector
          ---------------------------------------------------------------------- */
          // QSA and matchesSelector support


          rbuggyQSA = []; // Build QSA regex
          // Regex strategy adopted from Diego Perini

          assert(function (el) {
            var input;
            documentElement.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a>" + "<select id='" + expando + "-\r\\' disabled='disabled'>" + "<option selected=''></option></select>"; // Support: iOS <=7 - 8 only
            // Boolean attributes and "value" are not treated correctly in some XML documents

            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            } // Support: iOS <=7 - 8 only


            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            } // Support: iOS 8 only
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails


            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            } // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
            // In some of the document kinds, these selectors wouldn't work natively.
            // This is probably OK but for backwards compatibility we want to maintain
            // handling them through jQuery traversal in jQuery 3.x.


            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            } // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment


            input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D"); // Support: IE 9 - 11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets
            // Support: Chrome <=105+, Firefox <=104+, Safari <=15.4+
            // In some of the document kinds, these selectors wouldn't work natively.
            // This is probably OK but for backwards compatibility we want to maintain
            // handling them through jQuery traversal in jQuery 3.x.

            documentElement.appendChild(el).disabled = true;

            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Support: IE 11+, Edge 15 - 18+
            // IE 11/Edge don't find elements on a `[name='']` query in some cases.
            // Adding a temporary attribute to the document before the selection works
            // around the issue.
            // Interestingly, IE 10 & older don't seem to have the issue.


            input = document.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);

            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
            }
          });

          if (!support.cssHas) {
            // Support: Chrome 105 - 110+, Safari 15.4 - 16.3+
            // Our regular `try-catch` mechanism fails to detect natively-unsupported
            // pseudo-classes inside `:has()` (such as `:has(:contains("Foo"))`)
            // in browsers that parse the `:has()` argument as a forgiving selector list.
            // https://drafts.csswg.org/selectors/#relational now requires the argument
            // to be parsed unforgivingly, but browsers have not yet fully adjusted.
            rbuggyQSA.push(":has");
          }

          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          /* Sorting
          ---------------------------------------------------------------------- */
          // Document order sorting

          sortOrder = function sortOrder(a, b) {
            // Flag for duplicate removal
            if (a === b) {
              hasDuplicate = true;
              return 0;
            } // Sort on method existence if only one input has compareDocumentPosition


            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

            if (compare) {
              return compare;
            } // Calculate position if both inputs belong to the same document
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq


            compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
            1; // Disconnected nodes

            if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
              // Choose the first element that is related to our preferred document
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              if (a === document || a.ownerDocument == preferredDoc && find.contains(preferredDoc, a)) {
                return -1;
              } // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq


              if (b === document || b.ownerDocument == preferredDoc && find.contains(preferredDoc, b)) {
                return 1;
              } // Maintain original order


              return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
            }

            return compare & 4 ? -1 : 1;
          };

          return document;
        }

        find.matches = function (expr, elements) {
          return find(expr, null, null, elements);
        };

        find.matchesSelector = function (elem, expr) {
          setDocument(elem);

          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }

          return find(expr, document, null, [elem]).length > 0;
        };

        find.contains = function (context, elem) {
          // Set document vars if needed
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if ((context.ownerDocument || context) != document) {
            setDocument(context);
          }

          return jQuery.contains(context, elem);
        };

        find.attr = function (elem, name) {
          // Set document vars if needed
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if ((elem.ownerDocument || elem) != document) {
            setDocument(elem);
          }

          var fn = Expr.attrHandle[name.toLowerCase()],
              // Don't get fooled by Object.prototype properties (see trac-13807)
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

          if (val !== undefined) {
            return val;
          }

          return elem.getAttribute(name);
        };

        find.error = function (msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
         * Document sorting and removing duplicates
         * @param {ArrayLike} results
         */


        jQuery.uniqueSort = function (results) {
          var elem,
              duplicates = [],
              j = 0,
              i = 0; // Unless we *know* we can detect duplicates, assume their presence
          //
          // Support: Android <=4.0+
          // Testing for detecting duplicates is unpredictable so instead assume we can't
          // depend on duplicate detection in all browsers without a stable sort.

          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && _slice.call(results, 0);
          sort.call(results, sortOrder);

          if (hasDuplicate) {
            while (elem = results[i++]) {
              if (elem === results[i]) {
                j = duplicates.push(i);
              }
            }

            while (j--) {
              splice.call(results, duplicates[j], 1);
            }
          } // Clear input after sorting to release objects
          // See https://github.com/jquery/sizzle/pull/225


          sortInput = null;
          return results;
        };

        jQuery.fn.uniqueSort = function () {
          return this.pushStack(jQuery.uniqueSort(_slice.apply(this)));
        };

        Expr = jQuery.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": {
              dir: "parentNode"
            },
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": {
              dir: "previousSibling"
            }
          },
          preFilter: {
            ATTR: function ATTR(match) {
              match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }

              return match.slice(0, 4);
            },
            CHILD: function CHILD(match) {
              /* matches from matchExpr["CHILD"]
              	1 type (only|nth|...)
              	2 what (child|of-type)
              	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              	4 xn-component of xn+y argument ([+-]?\d*n|)
              	5 sign of xn-component
              	6 x of xn-component
              	7 sign of y-component
              	8 y of y-component
              */
              match[1] = match[1].toLowerCase();

              if (match[1].slice(0, 3) === "nth") {
                // nth-* requires argument
                if (!match[3]) {
                  find.error(match[0]);
                } // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1


                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
              } else if (match[3]) {
                find.error(match[0]);
              }

              return match;
            },
            PSEUDO: function PSEUDO(match) {
              var excess,
                  unquoted = !match[6] && match[2];

              if (matchExpr.CHILD.test(match[0])) {
                return null;
              } // Accept quoted arguments as-is


              if (match[3]) {
                match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
              } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
              excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
              excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                // excess is a negative index
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              } // Return only captures needed by the pseudo filter method (type and argument)


              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function TAG(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function () {
                return true;
              } : function (elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function CLASS(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
            },
            ATTR: function ATTR(name, operator, check) {
              return function (elem) {
                var result = find.attr(elem, name);

                if (result == null) {
                  return operator === "!=";
                }

                if (!operator) {
                  return true;
                }

                result += "";

                if (operator === "=") {
                  return result === check;
                }

                if (operator === "!=") {
                  return result !== check;
                }

                if (operator === "^=") {
                  return check && result.indexOf(check) === 0;
                }

                if (operator === "*=") {
                  return check && result.indexOf(check) > -1;
                }

                if (operator === "$=") {
                  return check && result.slice(-check.length) === check;
                }

                if (operator === "~=") {
                  return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }

                if (operator === "|=") {
                  return result === check || result.slice(0, check.length + 1) === check + "-";
                }

                return false;
              };
            },
            CHILD: function CHILD(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth",
                  forward = type.slice(-4) !== "last",
                  ofType = what === "of-type";
              return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
              function (elem) {
                return !!elem.parentNode;
              } : function (elem, _context, xml) {
                var cache,
                    outerCache,
                    node,
                    nodeIndex,
                    start,
                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = false;

                if (parent) {
                  // :(first|last|only)-(child|of-type)
                  if (simple) {
                    while (dir) {
                      node = elem;

                      while (node = node[dir]) {
                        if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                          return false;
                        }
                      } // Reverse direction for :only-* (if we haven't yet done so)


                      start = dir = type === "only" && !start && "nextSibling";
                    }

                    return true;
                  }

                  start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

                  if (forward && useCache) {
                    // Seek `elem` from a previously-cached index
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];

                    while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                    diff = nodeIndex = 0) || start.pop()) {
                      // When found, cache indexes on `parent` and break
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    // Use previously-cached element index if available
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    } // xml :nth-child(...)
                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                    if (diff === false) {
                      // Use the same loop as above to seek `elem` from the start
                      while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                          // Cache the index of each encountered element
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }

                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  } // Incorporate the offset, then check against cycle size


                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            PSEUDO: function PSEUDO(pseudo, argument) {
              // pseudo-class names are case-insensitive
              // https://www.w3.org/TR/selectors/#pseudo-classes
              // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
              // Remember that setFilters inherits from pseudos
              var args,
                  fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
              // arguments are needed to create the filter function
              // just as jQuery does

              if (fn[expando]) {
                return fn(argument);
              } // But maintain support for old signatures


              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                  var idx,
                      matched = fn(seed, argument),
                      i = matched.length;

                  while (i--) {
                    idx = indexOf.call(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) : function (elem) {
                  return fn(elem, 0, args);
                };
              }

              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function (selector) {
              // Trim the selector passed to compile
              // to avoid treating leading and trailing
              // spaces as combinators
              var input = [],
                  results = [],
                  matcher = compile(selector.replace(rtrimCSS, "$1"));
              return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
                var elem,
                    unmatched = matcher(seed, null, xml, []),
                    i = seed.length; // Match elements unmatched by `matcher`

                while (i--) {
                  if (elem = unmatched[i]) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) : function (elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results); // Don't keep the element
                // (see https://github.com/jquery/sizzle/issues/299)

                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function (selector) {
              return function (elem) {
                return find(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function (text) {
              text = text.replace(runescape, funescape);
              return function (elem) {
                return (elem.textContent || jQuery.text(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function (lang) {
              // lang value must be a valid identifier
              if (!ridentifier.test(lang || "")) {
                find.error("unsupported lang: " + lang);
              }

              lang = lang.replace(runescape, funescape).toLowerCase();
              return function (elem) {
                var elemLang;

                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);

                return false;
              };
            }),
            // Miscellaneous
            target: function target(elem) {
              var hash = window.location && window.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            root: function root(elem) {
              return elem === documentElement;
            },
            focus: function focus(elem) {
              return elem === safeActiveElement() && document.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function checked(elem) {
              // In CSS3, :checked should return both checked and selected elements
              // https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function selected(elem) {
              // Support: IE <=11+
              // Accessing the selectedIndex property
              // forces the browser to treat the default option as
              // selected when in an optgroup.
              if (elem.parentNode) {
                // eslint-disable-next-line no-unused-expressions
                elem.parentNode.selectedIndex;
              }

              return elem.selected === true;
            },
            // Contents
            empty: function empty(elem) {
              // https://www.w3.org/TR/selectors/#empty-pseudo
              // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
              //   but not by others (comment: 8; processing instruction: 7; etc.)
              // nodeType < 6 works because attributes (2) do not appear as children
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }

              return true;
            },
            parent: function parent(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function header(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function input(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function button(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function text(elem) {
              var attr;
              return nodeName(elem, "input") && elem.type === "text" && ( // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function () {
              return [0];
            }),
            last: createPositionalPseudo(function (_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function (_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function (matchIndexes, length) {
              var i = 0;

              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            }),
            odd: createPositionalPseudo(function (matchIndexes, length) {
              var i = 1;

              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            }),
            lt: createPositionalPseudo(function (matchIndexes, length, argument) {
              var i;

              if (argument < 0) {
                i = argument + length;
              } else if (argument > length) {
                i = length;
              } else {
                i = argument;
              }

              for (; --i >= 0;) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            }),
            gt: createPositionalPseudo(function (matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument;

              for (; ++i < length;) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq; // Add button/input type pseudos

        for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }

        for (i in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        } // Easy API for creating new setFilters


        function setFilters() {}

        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();

        function tokenize(selector, parseOnly) {
          var matched,
              match,
              tokens,
              type,
              soFar,
              groups,
              preFilters,
              cached = tokenCache[selector + " "];

          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }

          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;

          while (soFar) {
            // Comma and first run
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                // Don't consume trailing commas as valid
                soFar = soFar.slice(match[0].length) || soFar;
              }

              groups.push(tokens = []);
            }

            matched = false; // Combinators

            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            } // Filters


            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }

            if (!matched) {
              break;
            }
          } // Return the length of the invalid excess
          // if we're just parsing
          // Otherwise, throw an error or return tokens


          if (parseOnly) {
            return soFar.length;
          }

          return soFar ? find.error(selector) : // Cache the tokens
          tokenCache(selector, groups).slice(0);
        }

        function toSelector(tokens) {
          var i = 0,
              len = tokens.length,
              selector = "";

          for (; i < len; i++) {
            selector += tokens[i].value;
          }

          return selector;
        }

        function addCombinator(matcher, combinator, base) {
          var dir = combinator.dir,
              skip = combinator.next,
              key = skip || dir,
              checkNonElements = base && key === "parentNode",
              doneName = done++;
          return combinator.first ? // Check against closest ancestor/preceding element
          function (elem, context, xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }

            return false;
          } : // Check against all ancestor/preceding elements
          function (elem, context, xml) {
            var oldCache,
                outerCache,
                newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

            if (xml) {
              while (elem = elem[dir]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while (elem = elem[dir]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});

                  if (skip && nodeName(elem, skip)) {
                    elem = elem[dir] || elem;
                  } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    // Assign to newCache so results back-propagate to previous elements
                    return newCache[2] = oldCache[2];
                  } else {
                    // Reuse newcache so results back-propagate to previous elements
                    outerCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                    if (newCache[2] = matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              }
            }

            return false;
          };
        }

        function elementMatcher(matchers) {
          return matchers.length > 1 ? function (elem, context, xml) {
            var i = matchers.length;

            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }

            return true;
          } : matchers[0];
        }

        function multipleContexts(selector, contexts, results) {
          var i = 0,
              len = contexts.length;

          for (; i < len; i++) {
            find(selector, contexts[i], results);
          }

          return results;
        }

        function condense(unmatched, map, filter, context, xml) {
          var elem,
              newUnmatched = [],
              i = 0,
              len = unmatched.length,
              mapped = map != null;

          for (; i < len; i++) {
            if (elem = unmatched[i]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);

                if (mapped) {
                  map.push(i);
                }
              }
            }
          }

          return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }

          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }

          return markFunction(function (seed, results, context, xml) {
            var temp,
                i,
                elem,
                matcherOut,
                preMap = [],
                postMap = [],
                preexisting = results.length,
                // Get initial elements from seed or context
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;

            if (matcher) {
              // If we have a postFinder, or filtered seed, or non-seed postFilter
              // or preexisting results,
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
              [] : // ...otherwise use results directly
              results; // Find primary matches

              matcher(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            } // Apply postFilter


            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

              i = temp.length;

              while (i--) {
                if (elem = temp[i]) {
                  matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
              }
            }

            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  // Get the final matcherOut by condensing this intermediate into postFinder contexts
                  temp = [];
                  i = matcherOut.length;

                  while (i--) {
                    if (elem = matcherOut[i]) {
                      // Restore matcherIn since elem is not yet a final match
                      temp.push(matcherIn[i] = elem);
                    }
                  }

                  postFinder(null, matcherOut = [], temp, xml);
                } // Move matched elements from seed to results to keep them synchronized


                i = matcherOut.length;

                while (i--) {
                  if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              } // Add elements to results, through postFinder if defined

            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push.apply(results, matcherOut);
              }
            }
          });
        }

        function matcherFromTokens(tokens) {
          var checkContext,
              matcher,
              j,
              len = tokens.length,
              leadingRelative = Expr.relative[tokens[0].type],
              implicitRelative = leadingRelative || Expr.relative[" "],
              i = leadingRelative ? 1 : 0,
              // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(function (elem) {
            return elem === checkContext;
          }, implicitRelative, true),
              matchAnyContext = addCombinator(function (elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true),
              matchers = [function (elem, context, xml) {
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element
            // (see https://github.com/jquery/sizzle/issues/299)

            checkContext = null;
            return ret;
          }];

          for (; i < len; i++) {
            if (matcher = Expr.relative[tokens[i].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

              if (matcher[expando]) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;

                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }

                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                tokens.slice(0, i - 1).concat({
                  value: tokens[i - 2].type === " " ? "*" : ""
                })).replace(rtrimCSS, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
              }

              matchers.push(matcher);
            }
          }

          return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0,
              byElement = elementMatchers.length > 0,
              superMatcher = function superMatcher(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                // We must always have either seed elements or outermost context
            elems = seed || byElement && Expr.find.TAG("*", outermost),
                // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
                len = elems.length;

            if (outermost) {
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq
              outermostContext = context == document || context || outermost;
            } // Add elements passing elementMatchers directly to results
            // Support: iOS <=7 - 9 only
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching
            // elements by id. (see trac-14142)


            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0; // Support: IE 11+, Edge 17 - 18+
                // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
                // two documents; shallow comparisons work.
                // eslint-disable-next-line eqeqeq

                if (!context && elem.ownerDocument != document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }

                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document, xml)) {
                    push.call(results, elem);
                    break;
                  }
                }

                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              } // Track unmatched elements for set filters


              if (bySet) {
                // They will have gone through all possible matchers
                if (elem = !matcher && elem) {
                  matchedCount--;
                } // Lengthen the array for every element, matched or not


                if (seed) {
                  unmatched.push(elem);
                }
              }
            } // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.


            matchedCount += i; // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.

            if (bySet && i !== matchedCount) {
              j = 0;

              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }

              if (seed) {
                // Reintegrate element matches to eliminate the need for sorting
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                } // Discard index placeholder values to get only actual matches


                setMatched = condense(setMatched);
              } // Add matches to results


              push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery.uniqueSort(results);
              }
            } // Override manipulation of globals by nested matchers


            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

          return bySet ? markFunction(superMatcher) : superMatcher;
        }

        function compile(selector, match
        /* Internal Use Only */
        ) {
          var i,
              setMatchers = [],
              elementMatchers = [],
              cached = compilerCache[selector + " "];

          if (!cached) {
            // Generate a function of recursive functions that can be used to check each element
            if (!match) {
              match = tokenize(selector);
            }

            i = match.length;

            while (i--) {
              cached = matcherFromTokens(match[i]);

              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            } // Cache the compiled function


            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

            cached.selector = selector;
          }

          return cached;
        }
        /**
         * A low-level selection function that works with jQuery's compiled
         *  selector functions
         * @param {String|Function} selector A selector or a pre-compiled
         *  selector function built with jQuery selector compile
         * @param {Element} context
         * @param {Array} [results]
         * @param {Array} [seed] A set of elements to match against
         */


        function select(selector, context, results, seed) {
          var i,
              tokens,
              token,
              type,
              find,
              compiled = typeof selector === "function" && selector,
              match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
          // (the latter of which guarantees us context)

          if (match.length === 1) {
            // Reduce context if the leading compound selector is an ID
            tokens = match[0] = match[0].slice(0);

            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0];

              if (!context) {
                return results; // Precompiled matchers will still verify ancestry, so step up a level
              } else if (compiled) {
                context = context.parentNode;
              }

              selector = selector.slice(tokens.shift().value.length);
            } // Fetch a seed set for right-to-left matching


            i = matchExpr.needsContext.test(selector) ? 0 : tokens.length;

            while (i--) {
              token = tokens[i]; // Abort if we hit a combinator

              if (Expr.relative[type = token.type]) {
                break;
              }

              if (find = Expr.find[type]) {
                // Search, expanding context for leading sibling combinators
                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                  // If seed is empty or no tokens remain, we can return early
                  tokens.splice(i, 1);
                  selector = seed.length && toSelector(tokens);

                  if (!selector) {
                    push.apply(results, seed);
                    return results;
                  }

                  break;
                }
              }
            }
          } // Compile and execute a filtering function if one is not provided
          // Provide `match` to avoid retokenization if we modified the selector above


          (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
          return results;
        } // One-time assignments
        // Support: Android <=4.0 - 4.1+
        // Sort stability


        support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Initialize against the default document

        setDocument(); // Support: Android <=4.0 - 4.1+
        // Detached nodes confoundingly follow *each other*

        support.sortDetached = assert(function (el) {
          // Should return 1, but returns 4 (following)
          return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        });
        jQuery.find = find; // Deprecated

        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = jQuery.uniqueSort; // These have always been private, but they used to be documented
        // as part of Sizzle so let's maintain them in the 3.x line
        // for backwards compatibility purposes.

        find.compile = compile;
        find.select = select;
        find.setDocument = setDocument;
        find.escape = jQuery.escapeSelector;
        find.getText = jQuery.text;
        find.isXML = jQuery.isXMLDoc;
        find.selectors = jQuery.expr;
        find.support = jQuery.support;
        find.uniqueSort = jQuery.uniqueSort;
        /* eslint-enable */
      })();

      var dir = function dir(elem, _dir, until) {
        var matched = [],
            truncate = until !== undefined;

        while ((elem = elem[_dir]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }

            matched.push(elem);
          }
        }

        return matched;
      };

      var _siblings = function siblings(n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
          if (n.nodeType === 1 && n !== elem) {
            matched.push(n);
          }
        }

        return matched;
      };

      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

      function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
          return jQuery.grep(elements, function (elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        } // Single element


        if (qualifier.nodeType) {
          return jQuery.grep(elements, function (elem) {
            return elem === qualifier !== not;
          });
        } // Arraylike of elements (jQuery, arguments, Array)


        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        } // Filtered directly for both simple and complex selectors


        return jQuery.filter(qualifier, elements, not);
      }

      jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
          expr = ":not(" + expr + ")";
        }

        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }

        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
          return elem.nodeType === 1;
        }));
      };

      jQuery.fn.extend({
        find: function find(selector) {
          var i,
              ret,
              len = this.length,
              self = this;

          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function () {
              for (i = 0; i < len; i++) {
                if (jQuery.contains(self[i], this)) {
                  return true;
                }
              }
            }));
          }

          ret = this.pushStack([]);

          for (i = 0; i < len; i++) {
            jQuery.find(selector, self[i], ret);
          }

          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function filter(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function not(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function is(selector) {
          return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
      }); // Initialize a jQuery object
      // A central reference to the root jQuery(document)

      var rootjQuery,
          // A simple way to check for HTML strings
      // Prioritize #id over <tag> to avoid XSS via location.hash (trac-9521)
      // Strict HTML recognition (trac-11290: must start with <)
      // Shortcut simple #id case for speed
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
          init = jQuery.fn.init = function (selector, context, root) {
        var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

        if (!selector) {
          return this;
        } // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)


        root = root || rootjQuery; // Handle HTML strings

        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          } // Match html or make sure no context is specified for #id


          if (match && (match[1] || !context)) {
            // HANDLE: $(html) -> $(array)
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
              // Intentionally let the error be thrown if parseHTML is not present

              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  // Properties of context are called as methods if possible
                  if (isFunction(this[match])) {
                    this[match](context[match]); // ...and otherwise set as attributes
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }

              return this; // HANDLE: $(#id)
            } else {
              elem = document.getElementById(match[2]);

              if (elem) {
                // Inject the element directly into the jQuery object
                this[0] = elem;
                this.length = 1;
              }

              return this;
            } // HANDLE: $(expr, $(...))

          } else if (!context || context.jquery) {
            return (context || root).find(selector); // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
          } else {
            return this.constructor(context).find(selector);
          } // HANDLE: $(DOMElement)

        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this; // HANDLE: $(function)
          // Shortcut for document ready
        } else if (isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
          selector(jQuery);
        }

        return jQuery.makeArray(selector, this);
      }; // Give the init function the jQuery prototype for later instantiation


      init.prototype = jQuery.fn; // Initialize central reference

      rootjQuery = jQuery(document);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/,
          // Methods guaranteed to produce a unique set when starting from a unique set
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function has(target) {
          var targets = jQuery(target, this),
              l = targets.length;
          return this.filter(function () {
            var i = 0;

            for (; i < l; i++) {
              if (jQuery.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function closest(selectors, context) {
          var cur,
              i = 0,
              l = this.length,
              matched = [],
              targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

          if (!rneedsContext.test(selectors)) {
            for (; i < l; i++) {
              for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                // Always skip document fragments
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to jQuery#find
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }

          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function index(elem) {
          // No argument, return index in parent
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          } // Index in selector


          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          } // Locate the position of the desired element


          return indexOf.call(this, // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem);
        },
        add: function add(selector, context) {
          return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function addBack(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
      });

      function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}

        return cur;
      }

      jQuery.each({
        parent: function parent(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function parents(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function parentsUntil(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function next(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function prev(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function nextAll(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function prevAll(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function nextUntil(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function prevUntil(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function siblings(elem) {
          return _siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function children(elem) {
          return _siblings(elem.firstChild);
        },
        contents: function contents(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
          // Treat the template element as a regular one in browsers that
          // don't support it.


          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }

          return jQuery.merge([], elem.childNodes);
        }
      }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
          var matched = jQuery.map(this, fn, until);

          if (name.slice(-5) !== "Until") {
            selector = until;
          }

          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }

          if (this.length > 1) {
            // Remove duplicates
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            } // Reverse order for parents* and prev-derivatives


            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }

          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

      function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
          object[flag] = true;
        });
        return object;
      }
      /*
       * Create a callback list using the following parameters:
       *
       *	options: an optional list of space-separated options that will change how
       *			the callback list behaves or a more traditional option object
       *
       * By default a callback list will act like an event callback list and can be
       * "fired" multiple times.
       *
       * Possible options:
       *
       *	once:			will ensure the callback list can only be fired once (like a Deferred)
       *
       *	memory:			will keep track of previous values and will call any callback added
       *					after the list has been fired right away with the latest "memorized"
       *					values (like a Deferred)
       *
       *	unique:			will ensure a callback can only be added once (no duplicate in the list)
       *
       *	stopOnFalse:	interrupt callings when a callback returns false
       *
       */


      jQuery.Callbacks = function (options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

        var // Flag to know if list is currently firing
        firing,
            // Last fire value for non-forgettable lists
        memory,
            // Flag to know if list was already fired
        _fired,
            // Flag to prevent firing
        _locked,
            // Actual callback list
        list = [],
            // Queue of execution data for repeatable lists
        queue = [],
            // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1,
            // Fire callbacks
        fire = function fire() {
          // Enforce single-firing
          _locked = _locked || options.once; // Execute callbacks for all pending executions,
          // respecting firingIndex overrides and runtime changes

          _fired = firing = true;

          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();

            while (++firingIndex < list.length) {
              // Run callback and check for early termination
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                // Jump to end and forget the data so .add doesn't re-fire
                firingIndex = list.length;
                memory = false;
              }
            }
          } // Forget the data if we're done with it


          if (!options.memory) {
            memory = false;
          }

          firing = false; // Clean up if we're done firing for good

          if (_locked) {
            // Keep an empty list if we have data for future add calls
            if (memory) {
              list = []; // Otherwise, this object is spent
            } else {
              list = "";
            }
          }
        },
            // Actual Callbacks object
        self = {
          // Add a callback or a collection of callbacks to the list
          add: function add() {
            if (list) {
              // If we have memory from a past run, we should fire after adding
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }

              (function add(args) {
                jQuery.each(args, function (_, arg) {
                  if (isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    // Inspect recursively
                    add(arg);
                  }
                });
              })(arguments);

              if (memory && !firing) {
                fire();
              }
            }

            return this;
          },
          // Remove a callback from the list
          remove: function remove() {
            jQuery.each(arguments, function (_, arg) {
              var index;

              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1); // Handle firing indexes

                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function has(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function empty() {
            if (list) {
              list = [];
            }

            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function disable() {
            _locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function disabled() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function lock() {
            _locked = queue = [];

            if (!memory && !firing) {
              list = memory = "";
            }

            return this;
          },
          locked: function locked() {
            return !!_locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function fireWith(context, args) {
            if (!_locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);

              if (!firing) {
                fire();
              }
            }

            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function fire() {
            self.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function fired() {
            return !!_fired;
          }
        };

        return self;
      };

      function Identity(v) {
        return v;
      }

      function Thrower(ex) {
        throw ex;
      }

      function adoptValue(value, resolve, reject, noValue) {
        var method;

        try {
          // Check for promise aspect first to privilege synchronous behavior
          if (value && isFunction(method = value.promise)) {
            method.call(value).done(resolve).fail(reject); // Other thenables
          } else if (value && isFunction(method = value.then)) {
            method.call(value, resolve, reject); // Other non-thenables
          } else {
            // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply(undefined, [value].slice(noValue));
          } // For Promises/A+, convert exceptions into rejections
          // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
          // Deferred#then to conditionally suppress rejection.

        } catch (value) {
          // Support: Android 4.0 only
          // Strict mode functions invoked without .call/.apply get global-object context
          reject.apply(undefined, [value]);
        }
      }

      jQuery.extend({
        Deferred: function Deferred(func) {
          var tuples = [// action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
              _state = "pending",
              _promise = {
            state: function state() {
              return _state;
            },
            always: function always() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function _catch(fn) {
              return _promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function pipe() {
              var fns = arguments;
              return jQuery.Deferred(function (newDefer) {
                jQuery.each(tuples, function (_i, tuple) {
                  // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
                  // deferred.done(function() { bind to newDefer or newDefer.resolve })
                  // deferred.fail(function() { bind to newDefer or newDefer.reject })

                  deferred[tuple[1]](function () {
                    var returned = fn && fn.apply(this, arguments);

                    if (returned && isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function then(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;

              function resolve(depth, deferred, handler, special) {
                return function () {
                  var that = this,
                      args = arguments,
                      mightThrow = function mightThrow() {
                    var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                    // https://promisesaplus.com/#point-59
                    // Ignore double-resolution attempts

                    if (depth < maxDepth) {
                      return;
                    }

                    returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                    // https://promisesaplus.com/#point-48

                    if (returned === deferred.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    } // Support: Promises/A+ sections 2.3.3.1, 3.5
                    // https://promisesaplus.com/#point-54
                    // https://promisesaplus.com/#point-75
                    // Retrieve `then` only once


                    then = returned && ( // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                    if (isFunction(then)) {
                      // Special processors (notify) just wait for resolution
                      if (special) {
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                      } else {
                        // ...and disregard older resolution values
                        maxDepth++;
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                      } // Handle all other returned values

                    } else {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Identity) {
                        that = undefined;
                        args = [returned];
                      } // Process the value(s)
                      // Default process is resolve


                      (special || deferred.resolveWith)(that, args);
                    }
                  },
                      // Only normal processors (resolve) catch and reject exceptions
                  process = special ? mightThrow : function () {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(e, process.error);
                      } // Support: Promises/A+ section 2.3.3.3.4.1
                      // https://promisesaplus.com/#point-61
                      // Ignore post-resolution exceptions


                      if (depth + 1 >= maxDepth) {
                        // Only substitute handlers pass on context
                        // and multiple values (non-spec behavior)
                        if (handler !== Thrower) {
                          that = undefined;
                          args = [e];
                        }

                        deferred.rejectWith(that, args);
                      }
                    }
                  }; // Support: Promises/A+ section 2.3.3.3.1
                  // https://promisesaplus.com/#point-57
                  // Re-resolve promises immediately to dodge false rejection from
                  // subsequent errors


                  if (depth) {
                    process();
                  } else {
                    // Call an optional hook to record the error, in case of exception
                    // since it's otherwise lost when execution goes async
                    if (jQuery.Deferred.getErrorHook) {
                      process.error = jQuery.Deferred.getErrorHook(); // The deprecated alias of the above. While the name suggests
                      // returning the stack, not an error instance, jQuery just passes
                      // it directly to `console.warn` so both will work; an instance
                      // just better cooperates with source maps.
                    } else if (jQuery.Deferred.getStackHook) {
                      process.error = jQuery.Deferred.getStackHook();
                    }

                    window.setTimeout(process);
                  }
                };
              }

              return jQuery.Deferred(function (newDefer) {
                // progress_handlers.add( ... )
                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function promise(obj) {
              return obj != null ? jQuery.extend(obj, _promise) : _promise;
            }
          },
              deferred = {}; // Add list-specific methods

          jQuery.each(tuples, function (i, tuple) {
            var list = tuple[2],
                stateString = tuple[5]; // promise.progress = list.add
            // promise.done = list.add
            // promise.fail = list.add

            _promise[tuple[1]] = list.add; // Handle state

            if (stateString) {
              list.add(function () {
                // state = "resolved" (i.e., fulfilled)
                // state = "rejected"
                _state = stateString;
              }, // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable, // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable, // progress_callbacks.lock
              tuples[0][2].lock, // progress_handlers.lock
              tuples[0][3].lock);
            } // progress_handlers.fire
            // fulfilled_handlers.fire
            // rejected_handlers.fire


            list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
            // deferred.resolve = function() { deferred.resolveWith(...) }
            // deferred.reject = function() { deferred.rejectWith(...) }

            deferred[tuple[0]] = function () {
              deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
              return this;
            }; // deferred.notifyWith = list.fireWith
            // deferred.resolveWith = list.fireWith
            // deferred.rejectWith = list.fireWith


            deferred[tuple[0] + "With"] = list.fireWith;
          }); // Make the deferred a promise

          _promise.promise(deferred); // Call given func if any


          if (func) {
            func.call(deferred, deferred);
          } // All done!


          return deferred;
        },
        // Deferred helper
        when: function when(singleValue) {
          var // count of uncompleted subordinates
          remaining = arguments.length,
              // count of unprocessed arguments
          i = remaining,
              // subordinate fulfillment data
          resolveContexts = Array(i),
              resolveValues = _slice.call(arguments),
              // the primary Deferred
          primary = jQuery.Deferred(),
              // subordinate callback factory
          updateFunc = function updateFunc(i) {
            return function (value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

              if (! --remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          }; // Single- and empty arguments are adopted like Promise.resolve


          if (remaining <= 1) {
            adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

            if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
              return primary.then();
            }
          } // Multiple arguments are aggregated like Promise.all array elements


          while (i--) {
            adoptValue(resolveValues[i], updateFunc(i), primary.reject);
          }

          return primary.promise();
        }
      }); // These usually indicate a programmer mistake during development,
      // warn about them ASAP rather than swallowing them by default.

      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; // If `jQuery.Deferred.getErrorHook` is defined, `asyncError` is an error
      // captured before the async barrier to get the original error cause
      // which may otherwise be hidden.

      jQuery.Deferred.exceptionHook = function (error, asyncError) {
        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
          window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, asyncError);
        }
      };

      jQuery.readyException = function (error) {
        window.setTimeout(function () {
          throw error;
        });
      }; // The deferred used on DOM ready


      var readyList = jQuery.Deferred();

      jQuery.fn.ready = function (fn) {
        readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        ["catch"](function (error) {
          jQuery.readyException(error);
        });
        return this;
      };

      jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function ready(wait) {
          // Abort if there are pending holds or we're already ready
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          } // Remember that the DOM is ready


          jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          } // If there are functions bound, to execute


          readyList.resolveWith(document, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

      function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
      } // Catch cases where $(document).ready() is called
      // after the browser event has already occurred.
      // Support: IE <=9 - 10 only
      // Older IE sometimes signals "interactive" too soon


      if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);
      } else {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

        window.addEventListener("load", completed);
      } // Multifunctional method to get and set values of a collection
      // The value/s can optionally be executed if it's a function


      var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null; // Sets many values

        if (toType(key) === "object") {
          chainable = true;

          for (i in key) {
            access(elems, fn, i, key[i], true, emptyGet, raw);
          } // Sets one value

        } else if (value !== undefined) {
          chainable = true;

          if (!isFunction(value)) {
            raw = true;
          }

          if (bulk) {
            // Bulk operations run against the entire set
            if (raw) {
              fn.call(elems, value);
              fn = null; // ...except when executing function values
            } else {
              bulk = fn;

              fn = function fn(elem, _key, value) {
                return bulk.call(jQuery(elem), value);
              };
            }
          }

          if (fn) {
            for (; i < len; i++) {
              fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            }
          }
        }

        if (chainable) {
          return elems;
        } // Gets


        if (bulk) {
          return fn.call(elems);
        }

        return len ? fn(elems[0], key) : emptyGet;
      }; // Matches dashed string for camelizing


      var rmsPrefix = /^-ms-/,
          rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      } // Convert dashed to camelCase; used by the css and data modules
      // Support: IE <=9 - 11, Edge 12 - 15
      // Microsoft forgot to hump their vendor prefix (trac-9572)


      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }

      var acceptData = function acceptData(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };

      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }

      Data.uid = 1;
      Data.prototype = {
        cache: function cache(owner) {
          // Check if the owner object already has a cache
          var value = owner[this.expando]; // If not, create one

          if (!value) {
            value = {}; // We can accept data for non-element nodes in modern browsers,
            // but we should not, see trac-8335.
            // Always return an empty object.

            if (acceptData(owner)) {
              // If it is a node unlikely to be stringify-ed or looped over
              // use plain assignment
              if (owner.nodeType) {
                owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
                // configurable must be true to allow the property to be
                // deleted when data is removed
              } else {
                Object.defineProperty(owner, this.expando, {
                  value: value,
                  configurable: true
                });
              }
            }
          }

          return value;
        },
        set: function set(owner, data, value) {
          var prop,
              cache = this.cache(owner); // Handle: [ owner, key, value ] args
          // Always use camelCase key (gh-2257)

          if (typeof data === "string") {
            cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
          } else {
            // Copy the properties one-by-one to the cache object
            for (prop in data) {
              cache[camelCase(prop)] = data[prop];
            }
          }

          return cache;
        },
        get: function get(owner, key) {
          return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function access(owner, key, value) {
          // In cases where either:
          //
          //   1. No key was specified
          //   2. A string key was specified, but no value provided
          //
          // Take the "read" path and allow the get method to determine
          // which value to return, respectively either:
          //
          //   1. The entire cache object
          //   2. The data stored at the key
          //
          if (key === undefined || key && typeof key === "string" && value === undefined) {
            return this.get(owner, key);
          } // When the key is not a string, or both a key and value
          // are specified, set or extend (existing objects) with either:
          //
          //   1. An object of properties
          //   2. A key and value
          //


          this.set(owner, key, value); // Since the "set" path can have two possible entry points
          // return the expected data based on which path was taken[*]

          return value !== undefined ? value : key;
        },
        remove: function remove(owner, key) {
          var i,
              cache = owner[this.expando];

          if (cache === undefined) {
            return;
          }

          if (key !== undefined) {
            // Support array or space separated string of keys
            if (Array.isArray(key)) {
              // If key is an array of keys...
              // We always set camelCase keys, so remove that.
              key = key.map(camelCase);
            } else {
              key = camelCase(key); // If a key with the spaces exists, use it.
              // Otherwise, create an array by matching non-whitespace

              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }

            i = key.length;

            while (i--) {
              delete cache[key[i]];
            }
          } // Remove the expando if there's no more data


          if (key === undefined || jQuery.isEmptyObject(cache)) {
            // Support: Chrome <=35 - 45
            // Webkit & Blink performance suffers when deleting properties
            // from DOM nodes, so set to undefined instead
            // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
            if (owner.nodeType) {
              owner[this.expando] = undefined;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function hasData(owner) {
          var cache = owner[this.expando];
          return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data(); //	Implementation Summary
      //
      //	1. Enforce API surface and semantic compatibility with 1.9.x branch
      //	2. Improve the module's maintainability by reducing the storage
      //		paths to a single mechanism.
      //	3. Use the same single mechanism to support "private" and "user" data.
      //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
      //	5. Avoid exposing implementation details on user objects (eg. expando properties)
      //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
          rmultiDash = /[A-Z]/g;

      function getData(data) {
        if (data === "true") {
          return true;
        }

        if (data === "false") {
          return false;
        }

        if (data === "null") {
          return null;
        } // Only convert to a number if it doesn't change the string


        if (data === +data + "") {
          return +data;
        }

        if (rbrace.test(data)) {
          return JSON.parse(data);
        }

        return data;
      }

      function dataAttr(elem, key, data) {
        var name; // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute

        if (data === undefined && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);

          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e) {} // Make sure we set the data so it isn't changed later


            dataUser.set(elem, key, data);
          } else {
            data = undefined;
          }
        }

        return data;
      }

      jQuery.extend({
        hasData: function hasData(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function data(elem, name, _data) {
          return dataUser.access(elem, name, _data);
        },
        removeData: function removeData(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function _data(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function _removeData(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function data(key, value) {
          var i,
              name,
              data,
              elem = this[0],
              attrs = elem && elem.attributes; // Gets all values

          if (key === undefined) {
            if (this.length) {
              data = dataUser.get(elem);

              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i = attrs.length;

                while (i--) {
                  // Support: IE 11 only
                  // The attrs elements can be null (trac-14894)
                  if (attrs[i]) {
                    name = attrs[i].name;

                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }

                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }

            return data;
          } // Sets multiple values


          if (typeof key === "object") {
            return this.each(function () {
              dataUser.set(this, key);
            });
          }

          return access(this, function (value) {
            var data; // The calling jQuery object (element matches) is not empty
            // (and therefore has an element appears at this[ 0 ]) and the
            // `value` parameter was not undefined. An empty jQuery object
            // will result in `undefined` for elem = this[ 0 ] which will
            // throw an exception if an attempt to read a data cache is made.

            if (elem && value === undefined) {
              // Attempt to get data from the cache
              // The key will always be camelCased in Data
              data = dataUser.get(elem, key);

              if (data !== undefined) {
                return data;
              } // Attempt to "discover" the data in
              // HTML5 custom data-* attrs


              data = dataAttr(elem, key);

              if (data !== undefined) {
                return data;
              } // We tried really hard, but the data doesn't exist.


              return;
            } // Set the data...


            this.each(function () {
              // We always store the camelCased key
              dataUser.set(this, key, value);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function removeData(key) {
          return this.each(function () {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function queue(elem, type, data) {
          var queue;

          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }

            return queue || [];
          }
        },
        dequeue: function dequeue(elem, type) {
          type = type || "fx";

          var queue = jQuery.queue(elem, type),
              startLength = queue.length,
              fn = queue.shift(),
              hooks = jQuery._queueHooks(elem, type),
              next = function next() {
            jQuery.dequeue(elem, type);
          }; // If the fx queue is dequeued, always remove the progress sentinel


          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }

          if (fn) {
            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if (type === "fx") {
              queue.unshift("inprogress");
            } // Clear up the last queue stop function


            delete hooks.stop;
            fn.call(elem, next, hooks);
          }

          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function _queueHooks(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function () {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function queue(type, data) {
          var setter = 2;

          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }

          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }

          return data === undefined ? this : this.each(function () {
            var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

            jQuery._queueHooks(this, type);

            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function dequeue(type) {
          return this.each(function () {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function clearQueue(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function promise(type, obj) {
          var tmp,
              count = 1,
              defer = jQuery.Deferred(),
              elements = this,
              i = this.length,
              resolve = function resolve() {
            if (! --count) {
              defer.resolveWith(elements, [elements]);
            }
          };

          if (typeof type !== "string") {
            obj = type;
            type = undefined;
          }

          type = type || "fx";

          while (i--) {
            tmp = dataPriv.get(elements[i], type + "queueHooks");

            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }

          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document.documentElement;

      var isAttached = function isAttached(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      },
          composed = {
        composed: true
      }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
      // Check attachment across shadow DOM boundaries when possible (gh-3504)
      // Support: iOS 10.0-10.2 only
      // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
      // leading to errors. We need to check for `getRootNode`.


      if (documentElement.getRootNode) {
        isAttached = function isAttached(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }

      var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem; // Inline style trumps all

        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
      };

      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted,
            scale,
            maxIterations = 20,
            currentValue = tween ? function () {
          return tween.cur();
        } : function () {
          return jQuery.css(elem, prop, "");
        },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
            // Starting value computation is required for potential unit mismatches
        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {
          // Support: Firefox <=54
          // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
          initial = initial / 2; // Trust units reported by jQuery.css

          unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

          initialInUnit = +initial || 1;

          while (maxIterations--) {
            // Evaluate and update our best guess (doubling guesses that zero out).
            // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
            jQuery.style(elem, prop, initialInUnit + unit);

            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }

            initialInUnit = initialInUnit / scale;
          }

          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

          valueParts = valueParts || [];
        }

        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }

        return adjusted;
      }

      var defaultDisplayMap = {};

      function getDefaultDisplay(elem) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[nodeName];

        if (display) {
          return display;
        }

        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);

        if (display === "none") {
          display = "block";
        }

        defaultDisplayMap[nodeName] = display;
        return display;
      }

      function showHide(elements, show) {
        var display,
            elem,
            values = [],
            index = 0,
            length = elements.length; // Determine new display value for elements that need to change

        for (; index < length; index++) {
          elem = elements[index];

          if (!elem.style) {
            continue;
          }

          display = elem.style.display;

          if (show) {
            // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
            // check is required in this first loop unless we have a nonempty display value (either
            // inline or about-to-be-restored)
            if (display === "none") {
              values[index] = dataPriv.get(elem, "display") || null;

              if (!values[index]) {
                elem.style.display = "";
              }
            }

            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values[index] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values[index] = "none"; // Remember what we're overwriting

              dataPriv.set(elem, "display", display);
            }
          }
        } // Set the display of the elements in a second loop to avoid constant reflow


        for (index = 0; index < length; index++) {
          if (values[index] != null) {
            elements[index].style.display = values[index];
          }
        }

        return elements;
      }

      jQuery.fn.extend({
        show: function show() {
          return showHide(this, true);
        },
        hide: function hide() {
          return showHide(this);
        },
        toggle: function toggle(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }

          return this.each(function () {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

      (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (trac-11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (trac-14901)

        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input); // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments

        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned

        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
        // IE <=9 replaces <option> tags with their contents when inserted outside of
        // the select element.

        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })(); // We have to close these tags to support XHTML (trac-13200)


      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td; // Support: IE <=9 only

      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }

      function getAll(context, tag) {
        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (trac-15151)
        var ret;

        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }

        if (tag === undefined || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }

        return ret;
      } // Mark scripts as having already been evaluated


      function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
          dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
      }

      var rhtml = /<|&#?\w+;/;

      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem,
            tmp,
            tag,
            wrap,
            attached,
            j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for (; i < l; i++) {
          elem = elems[i];

          if (elem || elem === 0) {
            // Add nodes directly
            if (toType(elem) === "object") {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

              j = wrap[0];

              while (j--) {
                tmp = tmp.lastChild;
              } // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit


              jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

              tmp = fragment.firstChild; // Ensure the created nodes are orphaned (trac-12392)

              tmp.textContent = "";
            }
          }
        } // Remove wrapper from fragment


        fragment.textContent = "";
        i = 0;

        while (elem = nodes[i++]) {
          // Skip elements already in the context collection (trac-4087)
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }

            continue;
          }

          attached = isAttached(elem); // Append to fragment

          tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

          if (attached) {
            setGlobalEval(tmp);
          } // Capture executables


          if (scripts) {
            j = 0;

            while (elem = tmp[j++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }

        return fragment;
      }

      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

      function returnTrue() {
        return true;
      }

      function returnFalse() {
        return false;
      }

      function _on(elem, types, selector, data, fn, one) {
        var origFn, type; // Types can be a map of types/handlers

        if (typeof types === "object") {
          // ( types-Object, selector, data )
          if (typeof selector !== "string") {
            // ( types-Object, data )
            data = data || selector;
            selector = undefined;
          }

          for (type in types) {
            _on(elem, type, selector, data, types[type], one);
          }

          return elem;
        }

        if (data == null && fn == null) {
          // ( types, fn )
          fn = selector;
          data = selector = undefined;
        } else if (fn == null) {
          if (typeof selector === "string") {
            // ( types, selector, fn )
            fn = data;
            data = undefined;
          } else {
            // ( types, data, fn )
            fn = data;
            data = selector;
            selector = undefined;
          }
        }

        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }

        if (one === 1) {
          origFn = fn;

          fn = function fn(event) {
            // Can use an empty set, since event contains the info
            jQuery().off(event);
            return origFn.apply(this, arguments);
          }; // Use same guid so caller can remove using origFn


          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }

        return elem.each(function () {
          jQuery.event.add(this, types, fn, data, selector);
        });
      }
      /*
       * Helper functions for managing events -- not part of the public interface.
       * Props to Dean Edwards' addEvent library for many of the ideas.
       */


      jQuery.event = {
        global: {},
        add: function add(elem, types, handler, data, selector) {
          var handleObjIn,
              eventHandle,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = dataPriv.get(elem); // Only attach events to objects that accept data

          if (!acceptData(elem)) {
            return;
          } // Caller can pass in an object of custom data in lieu of the handler


          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          } // Ensure that invalid selectors throw exceptions at attach time
          // Evaluate against documentElement in case elem is a non-element node (e.g., document)


          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          } // Make sure that the handler has a unique ID, used to find/remove it later


          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          } // Init the element's event structure and main handler, if this is the first


          if (!(events = elemData.events)) {
            events = elemData.events = Object.create(null);
          }

          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function (e) {
              // Discard the second event of a jQuery.event.trigger() and
              // when an event is called after a page has unloaded
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
          } // Handle multiple events separated by a space


          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;

          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

            if (!type) {
              continue;
            } // If event changes its type, use the special event handlers for the changed type


            special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

            type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

            special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

            handleObj = jQuery.extend({
              type: type,
              origType: origType,
              data: data,
              handler: handler,
              guid: handler.guid,
              selector: selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn); // Init the event handler queue if we're the first

            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }

            if (special.add) {
              special.add.call(elem, handleObj);

              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            } // Add to the element's handler list, delegates in front


            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            } // Keep track of which events have ever been used, for event optimization


            jQuery.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function remove(elem, types, handler, selector, mappedTypes) {
          var j,
              origCount,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

          if (!elemData || !(events = elemData.events)) {
            return;
          } // Once for each type.namespace in types; type may be omitted


          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;

          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t], handler, selector, true);
              }

              continue;
            }

            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

            origCount = j = handlers.length;

            while (j--) {
              handleObj = handlers[j];

              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);

                if (handleObj.selector) {
                  handlers.delegateCount--;
                }

                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            } // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)


            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }

              delete events[type];
            }
          } // Remove data and the expando if it's no longer used


          if (jQuery.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function dispatch(nativeEvent) {
          var i,
              j,
              ret,
              matched,
              handleObj,
              handlerQueue,
              args = new Array(arguments.length),
              // Make a writable jQuery.Event from the native event object
          event = jQuery.event.fix(nativeEvent),
              handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
              special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

          args[0] = event;

          for (i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }

          event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          } // Determine handlers


          handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

          i = 0;

          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j = 0;

            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
              // If the event is namespaced, then each handler is only invoked if it is
              // specially universal or its namespaces are a superset of the event's.
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

                if (ret !== undefined) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          } // Call the postDispatch hook for the mapped type


          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }

          return event.result;
        },
        handlers: function handlers(event, _handlers) {
          var i,
              handleObj,
              sel,
              matchedHandlers,
              matchedSelectors,
              handlerQueue = [],
              delegateCount = _handlers.delegateCount,
              cur = event.target; // Find delegate handlers

          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              // Don't check non-elements (trac-13208)
              // Don't process clicks on disabled elements (trac-6911, trac-8165, trac-11382, trac-11764)
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};

                for (i = 0; i < delegateCount; i++) {
                  handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (trac-13203)

                  sel = handleObj.selector + " ";

                  if (matchedSelectors[sel] === undefined) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }

                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }

                if (matchedHandlers.length) {
                  handlerQueue.push({
                    elem: cur,
                    handlers: matchedHandlers
                  });
                }
              }
            }
          } // Add the remaining (directly-bound) handlers


          cur = this;

          if (delegateCount < _handlers.length) {
            handlerQueue.push({
              elem: cur,
              handlers: _handlers.slice(delegateCount)
            });
          }

          return handlerQueue;
        },
        addProp: function addProp(name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction(hook) ? function () {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function () {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function set(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value
              });
            }
          });
        },
        fix: function fix(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function setup(data) {
              // For mutual compressibility with _default, replace `this` access with a local var.
              // `|| data` is dead code meant only to preserve the variable through minification.
              var el = this || data; // Claim the first handler

              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                // dataPriv.set( el, "click", ... )
                leverageNative(el, "click", true);
              } // Return false to allow normal processing in the caller


              return false;
            },
            trigger: function trigger(data) {
              // For mutual compressibility with _default, replace `this` access with a local var.
              // `|| data` is dead code meant only to preserve the variable through minification.
              var el = this || data; // Force setup before triggering a click

              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              } // Return non-false to allow normal event-path propagation


              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function _default(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function postDispatch(event) {
              // Support: Firefox 20+
              // Firefox doesn't alert if the returnValue field is not set.
              if (event.result !== undefined && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      }; // Ensure the presence of an event listener that handles manually-triggered
      // synthetic events by interrupting progress until reinvoked in response to
      // *native* events that it fires directly, ensuring that state changes have
      // already occurred before other listeners are invoked.

      function leverageNative(el, type, isSetup) {
        // Missing `isSetup` indicates a trigger call, which must force setup through jQuery.event.add
        if (!isSetup) {
          if (dataPriv.get(el, type) === undefined) {
            jQuery.event.add(el, type, returnTrue);
          }

          return;
        } // Register the controller as a special universal handler for all event namespaces


        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
          namespace: false,
          handler: function handler(event) {
            var result,
                saved = dataPriv.get(this, type);

            if (event.isTrigger & 1 && this[type]) {
              // Interrupt processing of the outer synthetic .trigger()ed event
              if (!saved) {
                // Store arguments for use when handling the inner native event
                // There will always be at least one argument (an event object), so this array
                // will not be confused with a leftover capture object.
                saved = _slice.call(arguments);
                dataPriv.set(this, type, saved); // Trigger the native event and capture its result

                this[type]();
                result = dataPriv.get(this, type);
                dataPriv.set(this, type, false);

                if (saved !== result) {
                  // Cancel the outer synthetic event
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result;
                } // If this is an inner synthetic event for an event with a bubbling surrogate
                // (focus or blur), assume that the surrogate already propagated from triggering
                // the native event and prevent that from happening again here.
                // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                // less bad than duplication.

              } else if ((jQuery.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              } // If this is a native event triggered above, everything is now in order
              // Fire an inner synthetic event with the original arguments

            } else if (saved) {
              // ...and capture the result
              dataPriv.set(this, type, jQuery.event.trigger(saved[0], saved.slice(1), this)); // Abort handling of the native event by all jQuery handlers while allowing
              // native handlers on the same element to run. On target, this is achieved
              // by stopping immediate propagation just on the jQuery event. However,
              // the native event is re-wrapped by a jQuery one on each level of the
              // propagation so the only way to stop it for jQuery is to stop it for
              // everyone via native `stopPropagation()`. This is not a problem for
              // focus/blur which don't bubble, but it does also stop click on checkboxes
              // and radios. We accept this limitation.

              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }

      jQuery.removeEvent = function (elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };

      jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        } // Event object


        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type; // Events bubbling up the document may have been marked as prevented
          // by a handler lower down the tree; reflect the correct value.

          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse; // Create target properties
          // Support: Safari <=6 - 7 only
          // Target should not be a text node (trac-504, trac-13143)

          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget; // Event type
        } else {
          this.type = src;
        } // Put explicitly provided properties onto the event object


        if (props) {
          jQuery.extend(this, props);
        } // Create a timestamp if incoming event doesn't have one


        this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

        this[jQuery.expando] = true;
      }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
      // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function preventDefault() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;

          if (e && !this.isSimulated) {
            e.preventDefault();
          }
        },
        stopPropagation: function stopPropagation() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;

          if (e && !this.isSimulated) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function stopImmediatePropagation() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;

          if (e && !this.isSimulated) {
            e.stopImmediatePropagation();
          }

          this.stopPropagation();
        }
      }; // Includes all common event props including KeyEvent and MouseEvent specific props

      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery.event.addProp);
      jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function (type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document.documentMode) {
            // Support: IE 11+
            // Attach a single focusin/focusout handler on the document while someone wants
            // focus/blur. This is because the former are synchronous in IE while the latter
            // are async. In other browsers, all those handlers are invoked synchronously.
            // `handle` from private data would already wrap the event, but we need
            // to change the `type` here.
            var handle = dataPriv.get(this, "handle"),
                event = jQuery.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true; // First, handle focusin/focusout

            handle(nativeEvent); // ...then, handle focus/blur
            //
            // focus/blur don't bubble while focusin/focusout do; simulate the former by only
            // invoking the handler at the lower level.

            if (event.target === event.currentTarget) {
              // The setup part calls `leverageNative`, which, in turn, calls
              // `jQuery.event.add`, so event handle will already have been set
              // by this point.
              handle(event);
            }
          } else {
            // For non-IE browsers, attach a single capturing handler on the document
            // while someone wants focusin/focusout.
            jQuery.event.simulate(delegateType, nativeEvent.target, jQuery.event.fix(nativeEvent));
          }
        }

        jQuery.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function setup() {
            var attaches; // Claim the first handler
            // dataPriv.set( this, "focus", ... )
            // dataPriv.set( this, "blur", ... )

            leverageNative(this, type, true);

            if (document.documentMode) {
              // Support: IE 9 - 11+
              // We use the same native handler for focusin & focus (and focusout & blur)
              // so we need to coordinate setup & teardown parts between those events.
              // Use `delegateType` as the key as `type` is already used by `leverageNative`.
              attaches = dataPriv.get(this, delegateType);

              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }

              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              // Return false to allow normal processing in the caller
              return false;
            }
          },
          trigger: function trigger() {
            // Force setup before trigger
            leverageNative(this, type); // Return non-false to allow normal event-path propagation

            return true;
          },
          teardown: function teardown() {
            var attaches;

            if (document.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;

              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              // Return false to indicate standard teardown should be applied
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function _default(event) {
            return dataPriv.get(event.target, type);
          },
          delegateType: delegateType
        }; // Support: Firefox <=44
        // Firefox doesn't have focus(in | out) events
        // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
        //
        // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
        // focus(in | out) events fire after focus & blur events,
        // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
        // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
        //
        // Support: IE 9 - 11+
        // To preserve relative focusin/focus & focusout/blur event order guaranteed on the 3.x branch,
        // attach a single handler for both events in IE.

        jQuery.event.special[delegateType] = {
          setup: function setup() {
            // Handle: regular nodes (via `this.ownerDocument`), window
            // (via `this.document`) & document (via `this`).
            var doc = this.ownerDocument || this.document || this,
                dataHolder = document.documentMode ? this : doc,
                attaches = dataPriv.get(dataHolder, delegateType); // Support: IE 9 - 11+
            // We use the same native handler for focusin & focus (and focusout & blur)
            // so we need to coordinate setup & teardown parts between those events.
            // Use `delegateType` as the key as `type` is already used by `leverageNative`.

            if (!attaches) {
              if (document.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }

            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function teardown() {
            var doc = this.ownerDocument || this.document || this,
                dataHolder = document.documentMode ? this : doc,
                attaches = dataPriv.get(dataHolder, delegateType) - 1;

            if (!attaches) {
              if (document.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }

              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      }); // Create mouseenter/leave events using mouseover/out and event-time checks
      // so that event delegation works in jQuery.
      // Do the same for pointerenter/pointerleave and pointerover/pointerout
      //
      // Support: Safari 7 only
      // Safari sends mouseenter too often; see:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
      // for the description of the bug (it existed in older Chrome versions as well).

      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function (orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function handle(event) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window

            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }

            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function on(types, selector, data, fn) {
          return _on(this, types, selector, data, fn);
        },
        one: function one(types, selector, data, fn) {
          return _on(this, types, selector, data, fn, 1);
        },
        off: function off(types, selector, fn) {
          var handleObj, type;

          if (types && types.preventDefault && types.handleObj) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
            return this;
          }

          if (typeof types === "object") {
            // ( types-object [, selector] )
            for (type in types) {
              this.off(type, selector, types[type]);
            }

            return this;
          }

          if (selector === false || typeof selector === "function") {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
          }

          if (fn === false) {
            fn = returnFalse;
          }

          return this.each(function () {
            jQuery.event.remove(this, types, fn, selector);
          });
        }
      });
      var // Support: IE <=10 - 11, Edge 12 - 13 only
      // In IE/Edge using regex groups here causes severe slowdowns.
      // See https://connect.microsoft.com/IE/feedback/details/1736512/
      rnoInnerhtml = /<script|<style|<link/i,
          // checked="checked" or checked
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
          rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g; // Prefer a tbody over its parent table for containing new rows

      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }

        return elem;
      } // Replace/restore the type attribute of script elements for safe DOM manipulation


      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }

      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }

        return elem;
      }

      function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
          return;
        } // 1. Copy private data: events, handlers, etc.


        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;

          if (events) {
            dataPriv.remove(dest, "handle events");

            for (type in events) {
              for (i = 0, l = events[type].length; i < l; i++) {
                jQuery.event.add(dest, type, events[type][i]);
              }
            }
          }
        } // 2. Copy user data


        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      } // Fix IE bugs, see support tests


      function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

        if (nodeName === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }

      function domManip(collection, args, callback, ignored) {
        // Flatten any nested arrays
        args = flat(args);
        var fragment,
            first,
            scripts,
            hasScripts,
            node,
            doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function (index) {
            var self = collection.eq(index);

            if (valueIsFunction) {
              args[0] = value.call(this, index, self.html());
            }

            domManip(self, args, callback, ignored);
          });
        }

        if (l) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;

          if (fragment.childNodes.length === 1) {
            fragment = first;
          } // Require either new content or an interest in ignored elements to invoke the callback


          if (first || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length; // Use the original fragment for the last item
            // instead of the first because it can end up
            // being emptied incorrectly in certain situations (trac-8070).

            for (; i < l; i++) {
              node = fragment;

              if (i !== iNoClone) {
                node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

                if (hasScripts) {
                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }

              callback.call(collection[i], node, i);
            }

            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

              jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

              for (i = 0; i < hasScripts; i++) {
                node = scripts[i];

                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    // Optional AJAX dependency, but won't run scripts if not present
                    if (jQuery._evalUrl && !node.noModule) {
                      jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    // Unwrap a CDATA section containing script contents. This shouldn't be
                    // needed as in XML documents they're already not visible when
                    // inspecting element contents and in HTML documents they have no
                    // meaning but we're preserving that logic for backwards compatibility.
                    // This will be removed completely in 4.0. See gh-4904.
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }

        return collection;
      }

      function _remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;

        for (; (node = nodes[i]) != null; i++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }

          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }

            node.parentNode.removeChild(node);
          }
        }

        return elem;
      }

      jQuery.extend({
        htmlPrefilter: function htmlPrefilter(html) {
          return html;
        },
        clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
          var i,
              l,
              srcElements,
              destElements,
              clone = elem.cloneNode(true),
              inPage = isAttached(elem); // Fix IE cloning issues

          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            // We eschew jQuery#find here for performance reasons:
            // https://jsperf.com/getall-vs-sizzle/2
            destElements = getAll(clone);
            srcElements = getAll(elem);

            for (i = 0, l = srcElements.length; i < l; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          } // Copy the events from the original to the clone


          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);

              for (i = 0, l = srcElements.length; i < l; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          } // Preserve script evaluation history


          destElements = getAll(clone, "script");

          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          } // Return the cloned set


          return clone;
        },
        cleanData: function cleanData(elems) {
          var data,
              elem,
              type,
              special = jQuery.event.special,
              i = 0;

          for (; (elem = elems[i]) !== undefined; i++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                } // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove


                elem[dataPriv.expando] = undefined;
              }

              if (elem[dataUser.expando]) {
                // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[dataUser.expando] = undefined;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function detach(selector) {
          return _remove(this, selector, true);
        },
        remove: function remove(selector) {
          return _remove(this, selector);
        },
        text: function text(value) {
          return access(this, function (value) {
            return value === undefined ? jQuery.text(this) : this.empty().each(function () {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value;
              }
            });
          }, null, value, arguments.length);
        },
        append: function append() {
          return domManip(this, arguments, function (elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function prepend() {
          return domManip(this, arguments, function (elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function before() {
          return domManip(this, arguments, function (elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function after() {
          return domManip(this, arguments, function (elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function empty() {
          var elem,
              i = 0;

          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              // Prevent memory leaks
              jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

              elem.textContent = "";
            }
          }

          return this;
        },
        clone: function clone(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function () {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function html(value) {
          return access(this, function (value) {
            var elem = this[0] || {},
                i = 0,
                l = this.length;

            if (value === undefined && elem.nodeType === 1) {
              return elem.innerHTML;
            } // See if we can take a shortcut and just use innerHTML


            if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
              value = jQuery.htmlPrefilter(value);

              try {
                for (; i < l; i++) {
                  elem = this[i] || {}; // Remove element nodes and prevent memory leaks

                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value;
                  }
                }

                elem = 0; // If using innerHTML throws an exception, use the fallback method
              } catch (e) {}
            }

            if (elem) {
              this.empty().append(value);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function replaceWith() {
          var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

          return domManip(this, arguments, function (elem) {
            var parent = this.parentNode;

            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));

              if (parent) {
                parent.replaceChild(elem, this);
              }
            } // Force callback invocation

          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function (name, original) {
        jQuery.fn[name] = function (selector) {
          var elems,
              ret = [],
              insert = jQuery(selector),
              last = insert.length - 1,
              i = 0;

          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
            // .get() because push.apply(_, arraylike) throws on ancient WebKit

            push.apply(ret, elems.get());
          }

          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;

      var getStyles = function getStyles(elem) {
        // Support: IE <=11 only, Firefox <=30 (trac-15098, trac-14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
          view = window;
        }

        return view.getComputedStyle(elem);
      };

      var swap = function swap(elem, options, callback) {
        var ret,
            name,
            old = {}; // Remember the old values, and insert the new ones

        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }

        ret = callback.call(elem); // Revert the old values

        for (name in options) {
          elem.style[name] = old[name];
        }

        return ret;
      };

      var rboxStyle = new RegExp(cssExpand.join("|"), "i");

      (function () {
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
          // This is a singleton, we need to execute it only once
          if (!div) {
            return;
          }

          container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
          // Some styles come back with percentage values, even though they shouldn't

          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
          // Detect misreporting of content dimensions for box-sizing:border-box elements

          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
          // Detect overflow:scroll screwiness (gh-3699)
          // Support: Chrome <=64
          // Don't get tricked when zoom affects offsetWidth (gh-4029)

          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
          // it will also be a sign that checks already performed

          div = null;
        }

        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }

        var pixelPositionVal,
            boxSizingReliableVal,
            scrollboxSizeVal,
            pixelBoxStylesVal,
            reliableTrDimensionsVal,
            reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div"); // Finish early in limited (non-browser) environments

        if (!div.style) {
          return;
        } // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (trac-8908)


        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function boxSizingReliable() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function pixelBoxStyles() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function pixelPosition() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function reliableMarginLeft() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function scrollboxSize() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function reliableTrDimensions() {
            var table, tr, trChild, trStyle;

            if (reliableTrDimensionsVal == null) {
              table = document.createElement("table");
              tr = document.createElement("tr");
              trChild = document.createElement("div");
              table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
              // Height set through cssText does not get applied.
              // Computed height then comes back as 0.

              tr.style.height = "1px";
              trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
              // In our bodyBackground.html iframe,
              // display for all div elements is set to "inline",
              // which causes a problem only in Android 8 Chrome 86.
              // Ensuring the div is display: block
              // gets around this issue.

              trChild.style.display = "block";
              documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
              trStyle = window.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table);
            }

            return reliableTrDimensionsVal;
          }
        });
      })();

      function curCSS(elem, name, computed) {
        var width,
            minWidth,
            maxWidth,
            ret,
            isCustomProp = rcustomProp.test(name),
            // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;
        computed = computed || getStyles(elem); // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, trac-12537)
        //   .css('--customProperty) (gh-3144)

        if (computed) {
          // Support: IE <=9 - 11+
          // IE only supports `"float"` in `getPropertyValue`; in computed styles
          // it's only available as `"cssFloat"`. We no longer modify properties
          // sent to `.css()` apart from camelCasing, so we need to check both.
          // Normally, this would create difference in behavior: if
          // `getPropertyValue` returns an empty string, the value returned
          // by `.css()` would be `undefined`. This is usually the case for
          // disconnected elements. However, in IE even disconnected elements
          // with no styles return `"none"` for `getPropertyValue( "float" )`
          ret = computed.getPropertyValue(name) || computed[name];

          if (isCustomProp && ret) {
            // Support: Firefox 105+, Chrome <=105+
            // Spec requires trimming whitespace for custom properties (gh-4926).
            // Firefox only trims leading whitespace. Chrome just collapses
            // both leading & trailing whitespace to a single space.
            //
            // Fall back to `undefined` if empty string returned.
            // This collapses a missing definition with property defined
            // and set to an empty string but there's no standard API
            // allowing us to differentiate them without a performance penalty
            // and returning `undefined` aligns with older jQuery.
            //
            // rtrimCSS treats U+000D CARRIAGE RETURN and U+000C FORM FEED
            // as whitespace while CSS does not, but this is not a problem
            // because CSS preprocessing replaces them with U+000A LINE FEED
            // (which *is* CSS whitespace)
            // https://www.w3.org/TR/css-syntax-3/#input-preprocessing
            ret = ret.replace(rtrimCSS, "$1") || undefined;
          }

          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name);
          } // A tribute to the "awesome hack by Dean Edwards"
          // Android Browser returns percentage for some values,
          // but width seems to be reliably pixels.
          // This is against the CSSOM draft spec:
          // https://drafts.csswg.org/cssom/#resolved-values


          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            // Remember the original values
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth; // Put in the new values to get a computed value out

            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width; // Revert the changed values

            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }

        return ret !== undefined ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
      }

      function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
          get: function get() {
            if (conditionFn()) {
              // Hook not needed (or it's not possible to use it due
              // to missing dependency), remove it.
              delete this.get;
              return;
            } // Hook needed; redefine it so that the support test is not executed again.


            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }

      var cssPrefixes = ["Webkit", "Moz", "ms"],
          emptyStyle = document.createElement("div").style,
          vendorProps = {}; // Return a vendor-prefixed property or undefined

      function vendorPropName(name) {
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;

        while (i--) {
          name = cssPrefixes[i] + capName;

          if (name in emptyStyle) {
            return name;
          }
        }
      } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


      function finalPropName(name) {
        var _final = jQuery.cssProps[name] || vendorProps[name];

        if (_final) {
          return _final;
        }

        if (name in emptyStyle) {
          return name;
        }

        return vendorProps[name] = vendorPropName(name) || name;
      }

      var // Swappable if display is none or starts with table
      // except "table", "table-cell", or "table-caption"
      // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
      rdisplayswap = /^(none|table(?!-c[ea]).+)/,
          cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
          cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };

      function setPositiveNumber(_elem, value, subtract) {
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
      }

      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0,
            marginDelta = 0; // Adjustment may not be necessary

        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }

        for (; i < 4; i += 2) {
          // Both box models exclude margin
          // Count margin delta separately to only add it after scroll gutter adjustment.
          // This is needed to make negative margins work with `outerHeight( true )` (gh-3982).
          if (box === "margin") {
            marginDelta += jQuery.css(elem, box + cssExpand[i], true, styles);
          } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


          if (!isBorderBox) {
            // Add padding
            delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            } // If we get here with a border-box (content + padding + border), we're seeking "content" or
            // "padding" or "margin"

          } else {
            // For "content", subtract padding
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            } // For "content" or "padding", subtract border


            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          }
        } // Account for positive content-box scroll gutter when requested by providing computedVal


        if (!isBorderBox && computedVal >= 0) {
          // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
          // Assuming integer scroll gutter, subtract the rest and round down
          delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }

        return delta + marginDelta;
      }

      function getWidthOrHeight(elem, dimension, extra) {
        // Start with computed style
        var styles = getStyles(elem),
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
        // Fake content-box until we know it's needed to know the true value.
        boxSizingNeeded = !support.boxSizingReliable() || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            valueIsBorderBox = isBorderBox,
            val = curCSS(elem, dimension, styles),
            offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.

        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }

          val = "auto";
        } // Support: IE 9 - 11 only
        // Use offsetWidth/offsetHeight for when box sizing is unreliable.
        // In those cases, the computed value can be trusted to be border-box.


        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
          // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
          // retrieved value as a content box dimension.

          valueIsBorderBox = offsetProp in elem;

          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        } // Normalize "" and auto


        val = parseFloat(val) || 0; // Adjust for the element's box model

        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val) + "px";
      }

      jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function get(elem, computed) {
              if (computed) {
                // We should always get a number back from opacity
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function style(elem, name, value, extra) {
          // Don't set styles on text and comment nodes
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          } // Make sure that we're working with the right name


          var ret,
              type,
              hooks,
              origName = camelCase(name),
              isCustomProp = rcustomProp.test(name),
              style = elem.style; // Make sure that we're working with the right name. We don't
          // want to query the value if it is a CSS custom property
          // since they are user-defined.

          if (!isCustomProp) {
            name = finalPropName(origName);
          } // Gets hook for the prefixed version, then unprefixed version


          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

          if (value !== undefined) {
            type = typeof value; // Convert "+=" or "-=" to relative numbers (trac-7345)

            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret); // Fixes bug trac-9237

              type = "number";
            } // Make sure that null and NaN values aren't set (trac-7116)


            if (value == null || value !== value) {
              return;
            } // If a number was passed in, add the unit (except for certain CSS properties)
            // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
            // "px" to a few hardcoded values.


            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            } // background-* props affect original clone's values


            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            } // If a hook was provided, use that value, otherwise just set the specified value


            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
              if (isCustomProp) {
                style.setProperty(name, value);
              } else {
                style[name] = value;
              }
            }
          } else {
            // If a hook was provided get the non-computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
              return ret;
            } // Otherwise just get the value from the style object


            return style[name];
          }
        },
        css: function css(elem, name, extra, styles) {
          var val,
              num,
              hooks,
              origName = camelCase(name),
              isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
          // want to modify the value if it is a CSS custom property
          // since they are user-defined.

          if (!isCustomProp) {
            name = finalPropName(origName);
          } // Try prefixed name followed by the unprefixed name


          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          } // Otherwise, if a way to get the computed value exists, use that


          if (val === undefined) {
            val = curCSS(elem, name, styles);
          } // Convert "normal" to computed value


          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          } // Make numeric if forced or a qualifier was provided and val looks numeric


          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }

          return val;
        }
      });
      jQuery.each(["height", "width"], function (_i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function get(elem, computed, extra) {
            if (computed) {
              // Certain elements can have dimension info if we invisibly show them
              // but it must have a current display style that would benefit
              return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function set(elem, value, extra) {
            var matches,
                styles = getStyles(elem),
                // Only read styles.position if the test has a chance to fail
            // to avoid forcing a reflow.
            scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
                // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
            boxSizingNeeded = scrollboxSizeBuggy || extra,
                isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
            // faking a content-box to get border and padding (gh-3699)

            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
            } // Convert to pixels if value adjustment is needed


            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }

            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
          }, function () {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }); // These hooks are used by animate to expand properties

      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function expand(value) {
            var i = 0,
                expanded = {},
                // Assumes a single number if not a string
            parts = typeof value === "string" ? value.split(" ") : [value];

            for (; i < 4; i++) {
              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }

            return expanded;
          }
        };

        if (prefix !== "margin") {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function css(name, value) {
          return access(this, function (elem, name, value) {
            var styles,
                len,
                map = {},
                i = 0;

            if (Array.isArray(name)) {
              styles = getStyles(elem);
              len = name.length;

              for (; i < len; i++) {
                map[name[i]] = jQuery.css(elem, name[i], false, styles);
              }

              return map;
            }

            return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
          }, name, value, arguments.length > 1);
        }
      });

      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }

      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function init(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function cur() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function run(percent) {
          var eased,
              hooks = Tween.propHooks[this.prop];

          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
          } else {
            this.pos = eased = percent;
          }

          this.now = (this.end - this.start) * eased + this.start;

          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }

          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }

          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function get(tween) {
            var result; // Use a property on the element directly when it is not a DOM element,
            // or when there is no matching style property that exists.

            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            } // Passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails.
            // Simple values such as "10px" are parsed to Float;
            // complex values such as "rotate(1rad)" are returned as-is.


            result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

            return !result || result === "auto" ? 0 : result;
          },
          set: function set(tween) {
            // Use step hook for back compat.
            // Use cssHook if its there.
            // Use .style if available and use plain properties where available.
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      }; // Support: IE <=9 only
      // Panic based approach to setting things on disconnected nodes

      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function set(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function linear(p) {
          return p;
        },
        swing: function swing(p) {
          return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

      jQuery.fx.step = {};
      var fxNow,
          inProgress,
          rfxtypes = /^(?:toggle|show|hide)$/,
          rrun = /queueHooks$/;

      function schedule() {
        if (inProgress) {
          if (document.hidden === false && window.requestAnimationFrame) {
            window.requestAnimationFrame(schedule);
          } else {
            window.setTimeout(schedule, jQuery.fx.interval);
          }

          jQuery.fx.tick();
        }
      } // Animations created synchronously will run synchronously


      function createFxNow() {
        window.setTimeout(function () {
          fxNow = undefined;
        });
        return fxNow = Date.now();
      } // Generate parameters to create a standard animation


      function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {
          height: type
        }; // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right

        includeWidth = includeWidth ? 1 : 0;

        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }

        return attrs;
      }

      function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;

        for (; index < length; index++) {
          if (tween = collection[index].call(animation, prop, value)) {
            // We're done with this property
            return tween;
          }
        }
      }

      function defaultPrefilter(elem, props, opts) {
        var prop,
            value,
            toggle,
            hooks,
            oldfire,
            propTween,
            restoreDisplay,
            display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree(elem),
            dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");

          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;

            hooks.empty.fire = function () {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }

          hooks.unqueued++;
          anim.always(function () {
            // Ensure the complete handler is called before this completes
            anim.always(function () {
              hooks.unqueued--;

              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        } // Detect show/hide animations


        for (prop in props) {
          value = props[prop];

          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";

            if (value === (hidden ? "hide" : "show")) {
              // Pretend to be hidden if this is a "show" and
              // there is still data from a stopped show/hide
              if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                hidden = true; // Ignore all other no-op show/hide data
              } else {
                continue;
              }
            }

            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        } // Bail out if this is a no-op like .hide().hide()


        propTween = !jQuery.isEmptyObject(props);

        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        } // Restrict "overflow" and "display" styles during box animations


        if (isBox && elem.nodeType === 1) {
          // Support: IE <=9 - 11, Edge 12 - 15
          // Record all 3 overflow attributes because IE does not infer the shorthand
          // from identically-valued overflowX and overflowY and Edge just mirrors
          // the overflowX value there.
          opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

          restoreDisplay = dataShow && dataShow.display;

          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }

          display = jQuery.css(elem, "display");

          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              // Get nonempty value(s) by temporarily forcing visibility
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          } // Animate inline elements as inline-block


          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              // Restore the original display value at the end of pure show/hide animations
              if (!propTween) {
                anim.done(function () {
                  style.display = restoreDisplay;
                });

                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }

              style.display = "inline-block";
            }
          }
        }

        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function () {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        } // Implement show/hide animations


        propTween = false;

        for (prop in orig) {
          // General show/hide setup for this element animation
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", {
                display: restoreDisplay
              });
            } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


            if (toggle) {
              dataShow.hidden = !hidden;
            } // Show elements before animating them


            if (hidden) {
              showHide([elem], true);
            }
            /* eslint-disable no-loop-func */


            anim.done(function () {
              /* eslint-enable no-loop-func */
              // The final step of a "hide" animation is actually hiding the element
              if (!hidden) {
                showHide([elem]);
              }

              dataPriv.remove(elem, "fxshow");

              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          } // Per-property setup


          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;

            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }

      function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

        for (index in props) {
          name = camelCase(index);
          easing = specialEasing[name];
          value = props[index];

          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }

          if (index !== name) {
            props[name] = value;
            delete props[index];
          }

          hooks = jQuery.cssHooks[name];

          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
            // Reusing 'index' because we have the correct "name"

            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }

      function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function () {
          // Don't match elem in the :animated selector
          delete tick.elem;
        }),
            tick = function tick() {
          if (stopped) {
            return false;
          }

          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              // Support: Android 2.3 only
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (trac-12497)
          temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;

          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }

          deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

          if (percent < 1 && length) {
            return remaining;
          } // If this was an empty animation, synthesize a final progress notification


          if (!length) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          } // Resolve the animation and report its conclusion


          deferred.resolveWith(elem, [animation]);
          return false;
        },
            animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function createTween(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function stop(gotoEnd) {
            var index = 0,
                // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;

            if (stopped) {
              return this;
            }

            stopped = true;

            for (; index < length; index++) {
              animation.tweens[index].run(1);
            } // Resolve when we played the last frame; otherwise, reject


            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }

            return this;
          }
        }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
          result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

          if (result) {
            if (isFunction(result.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }

            return result;
          }
        }

        jQuery.map(props, createTween, animation);

        if (isFunction(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        } // Attach callbacks from options


        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
          elem: elem,
          anim: animation,
          queue: animation.opts.queue
        }));
        return animation;
      }

      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
          "*": [function (prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function tweener(props, callback) {
          if (isFunction(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }

          var prop,
              index = 0,
              length = props.length;

          for (; index < length; index++) {
            prop = props[index];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function prefilter(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });

      jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction(easing) && easing
        }; // Go to the end state if fx are off

        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        } // Normalize opt.queue - true/undefined/null -> "fx"


        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        } // Queueing


        opt.old = opt.complete;

        opt.complete = function () {
          if (isFunction(opt.old)) {
            opt.old.call(this);
          }

          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };

        return opt;
      };

      jQuery.fn.extend({
        fadeTo: function fadeTo(speed, to, easing, callback) {
          // Show any hidden elements after setting opacity to 0
          return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
          .end().animate({
            opacity: to
          }, speed, easing, callback);
        },
        animate: function animate(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop),
              optall = jQuery.speed(speed, easing, callback),
              doAnimation = function doAnimation() {
            // Operate on a copy of prop so per-property easing won't be lost
            var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };

          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function stop(type, clearQueue, gotoEnd) {
          var stopQueue = function stopQueue(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };

          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
          }

          if (clearQueue) {
            this.queue(type || "fx", []);
          }

          return this.each(function () {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = dataPriv.get(this);

            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }

            for (index = timers.length; index--;) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            } // Start the next in the queue if the last step wasn't forced.
            // Timers currently will call their complete callbacks, which
            // will dequeue but only if they were gotoEnd.


            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function finish(type) {
          if (type !== false) {
            type = type || "fx";
          }

          return this.each(function () {
            var index,
                data = dataPriv.get(this),
                queue = data[type + "queue"],
                hooks = data[type + "queueHooks"],
                timers = jQuery.timers,
                length = queue ? queue.length : 0; // Enable finishing flag on private data

            data.finish = true; // Empty the queue first

            jQuery.queue(this, type, []);

            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            } // Look for any active animations, and finish them


            for (index = timers.length; index--;) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            } // Look for any animations in the old queue and finish them


            for (index = 0; index < length; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            } // Turn off finishing flag


            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function (_i, name) {
        var cssFn = jQuery.fn[name];

        jQuery.fn[name] = function (speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      }); // Generate shortcuts for custom animations

      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
          opacity: "show"
        },
        fadeOut: {
          opacity: "hide"
        },
        fadeToggle: {
          opacity: "toggle"
        }
      }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];

      jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;
        fxNow = Date.now();

        for (; i < timers.length; i++) {
          timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }

        if (!timers.length) {
          jQuery.fx.stop();
        }

        fxNow = undefined;
      };

      jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };

      jQuery.fx.interval = 13;

      jQuery.fx.start = function () {
        if (inProgress) {
          return;
        }

        inProgress = true;
        schedule();
      };

      jQuery.fx.stop = function () {
        inProgress = null;
      };

      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      }; // Based off of the plugin by Clint Helfers, with permission.

      jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function (next, hooks) {
          var timeout = window.setTimeout(next, time);

          hooks.stop = function () {
            window.clearTimeout(timeout);
          };
        });
      };

      (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox"; // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"

        support.checkOn = input.value !== ""; // Support: IE <=11 only
        // Must access selectedIndex to make default options select

        support.optSelected = opt.selected; // Support: IE <=11 only
        // An input loses its value after becoming a radio

        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();

      var boolHook,
          attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function attr(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function removeAttr(name) {
          return this.each(function () {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function attr(elem, name, value) {
          var ret,
              hooks,
              nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          } // Fallback to prop when attributes are not supported


          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          } // Attribute hooks are determined by the lowercase version
          // Grab necessary hook if one is defined


          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
          }

          if (value !== undefined) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }

            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            }

            elem.setAttribute(name, value + "");
            return value;
          }

          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }

          ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

          return ret == null ? undefined : ret;
        },
        attrHooks: {
          type: {
            set: function set(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);

                if (val) {
                  elem.value = val;
                }

                return value;
              }
            }
          }
        },
        removeAttr: function removeAttr(elem, value) {
          var name,
              i = 0,
              // Attribute names can contain non-HTML whitespace characters
          // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
          attrNames = value && value.match(rnothtmlwhite);

          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i++]) {
              elem.removeAttribute(name);
            }
          }
        }
      }); // Hooks for boolean attributes

      boolHook = {
        set: function set(elem, value, name) {
          if (value === false) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }

          return name;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
          var ret,
              handle,
              lowercaseName = name.toLowerCase();

          if (!isXML) {
            // Avoid an infinite loop by temporarily removing this function from the getter
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }

          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i,
          rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function prop(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function removeProp(name) {
          return this.each(function () {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function prop(elem, name, value) {
          var ret,
              hooks,
              nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }

          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            // Fix name and attach hooks
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }

          if (value !== undefined) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            }

            return elem[name] = value;
          }

          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }

          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function get(elem) {
              // Support: IE <=9 - 11 only
              // elem.tabIndex doesn't always return the
              // correct value when it hasn't been explicitly set
              // Use proper attribute retrieval (trac-12072)
              var tabindex = jQuery.find.attr(elem, "tabindex");

              if (tabindex) {
                return parseInt(tabindex, 10);
              }

              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }

              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      }); // Support: IE <=11 only
      // Accessing the selectedIndex property
      // forces the browser to respect setting selected
      // on the option
      // The getter ensures a default option is selected
      // when in an optgroup
      // eslint rule "no-unused-expressions" is disabled for this code
      // since it considers such accessions noop

      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function get(elem) {
            /* eslint no-unused-expressions: "off" */
            var parent = elem.parentNode;

            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }

            return null;
          },
          set: function set(elem) {
            /* eslint no-unused-expressions: "off" */
            var parent = elem.parentNode;

            if (parent) {
              parent.selectedIndex;

              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }

      jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        jQuery.propFix[this.toLowerCase()] = this;
      }); // Strip and collapse whitespace according to HTML spec
      // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }

      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }

      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }

        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }

        return [];
      }

      jQuery.fn.extend({
        addClass: function addClass(value) {
          var classNames, cur, curValue, className, i, finalValue;

          if (isFunction(value)) {
            return this.each(function (j) {
              jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
          }

          classNames = classesToArray(value);

          if (classNames.length) {
            return this.each(function () {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

              if (cur) {
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];

                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                } // Only assign if different to avoid unneeded rendering.


                finalValue = stripAndCollapse(cur);

                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }

          return this;
        },
        removeClass: function removeClass(value) {
          var classNames, cur, curValue, className, i, finalValue;

          if (isFunction(value)) {
            return this.each(function (j) {
              jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
          }

          if (!arguments.length) {
            return this.attr("class", "");
          }

          classNames = classesToArray(value);

          if (classNames.length) {
            return this.each(function () {
              curValue = getClass(this); // This expression is here for better compressibility (see addClass)

              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

              if (cur) {
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i]; // Remove *all* instances

                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                } // Only assign if different to avoid unneeded rendering.


                finalValue = stripAndCollapse(cur);

                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }

          return this;
        },
        toggleClass: function toggleClass(value, stateVal) {
          var classNames,
              className,
              i,
              self,
              type = typeof value,
              isValidValue = type === "string" || Array.isArray(value);

          if (isFunction(value)) {
            return this.each(function (i) {
              jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
          }

          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }

          classNames = classesToArray(value);
          return this.each(function () {
            if (isValidValue) {
              // Toggle individual class names
              self = jQuery(this);

              for (i = 0; i < classNames.length; i++) {
                className = classNames[i]; // Check each className given, space separated list

                if (self.hasClass(className)) {
                  self.removeClass(className);
                } else {
                  self.addClass(className);
                }
              } // Toggle whole class name

            } else if (value === undefined || type === "boolean") {
              className = getClass(this);

              if (className) {
                // Store className if set
                dataPriv.set(this, "__className__", className);
              } // If the element has a class name or if we're passed `false`,
              // then remove the whole classname (if there was one, the above saved it).
              // Otherwise bring back whatever was previously saved (if anything),
              // falling back to the empty string if nothing was stored.


              if (this.setAttribute) {
                this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
              }
            }
          });
        },
        hasClass: function hasClass(selector) {
          var className,
              elem,
              i = 0;
          className = " " + selector + " ";

          while (elem = this[i++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }

          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function val(value) {
          var hooks,
              ret,
              valueIsFunction,
              elem = this[0];

          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                return ret;
              }

              ret = elem.value; // Handle most common string cases

              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              } // Handle cases where value is null/undef or number


              return ret == null ? "" : ret;
            }

            return;
          }

          valueIsFunction = isFunction(value);
          return this.each(function (i) {
            var val;

            if (this.nodeType !== 1) {
              return;
            }

            if (valueIsFunction) {
              val = value.call(this, i, jQuery(this).val());
            } else {
              val = value;
            } // Treat null/undefined as ""; convert numbers to string


            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function (value) {
                return value == null ? "" : value + "";
              });
            }

            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function get(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : // Support: IE <=10 - 11 only
              // option.text throws exceptions (trac-14686, trac-14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery.text(elem));
            }
          },
          select: {
            get: function get(elem) {
              var value,
                  option,
                  i,
                  options = elem.options,
                  index = elem.selectedIndex,
                  one = elem.type === "select-one",
                  values = one ? null : [],
                  max = one ? index + 1 : options.length;

              if (index < 0) {
                i = max;
              } else {
                i = one ? index : 0;
              } // Loop through all the selected options


              for (; i < max; i++) {
                option = options[i]; // Support: IE <=9 only
                // IE8-9 doesn't update selected after form reset (trac-2551)

                if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  // Get the specific value for the option
                  value = jQuery(option).val(); // We don't need an array for one selects

                  if (one) {
                    return value;
                  } // Multi-Selects return an array


                  values.push(value);
                }
              }

              return values;
            },
            set: function set(elem, value) {
              var optionSet,
                  option,
                  options = elem.options,
                  values = jQuery.makeArray(value),
                  i = options.length;

              while (i--) {
                option = options[i];
                /* eslint-disable no-cond-assign */

                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                  optionSet = true;
                }
                /* eslint-enable no-cond-assign */

              } // Force browsers to behave consistently when non-matching value is set


              if (!optionSet) {
                elem.selectedIndex = -1;
              }

              return values;
            }
          }
        }
      }); // Radios and checkboxes getter/setter

      jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
          set: function set(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };

        if (!support.checkOn) {
          jQuery.valHooks[this].get = function (elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      }); // Return jQuery for attributes-only inclusion

      var location = window.location;
      var nonce = {
        guid: Date.now()
      };
      var rquery = /\?/; // Cross-browser xml parsing

      jQuery.parseXML = function (data) {
        var xml, parserErrorElem;

        if (!data || typeof data !== "string") {
          return null;
        } // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.


        try {
          xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {}

        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

        if (!xml || parserErrorElem) {
          jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
            return el.textContent;
          }).join("\n") : data));
        }

        return xml;
      };

      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
          stopPropagationCallback = function stopPropagationCallback(e) {
        e.stopPropagation();
      };

      jQuery.extend(jQuery.event, {
        trigger: function trigger(event, data, elem, onlyHandlers) {
          var i,
              cur,
              tmp,
              bubbleType,
              ontype,
              handle,
              special,
              lastElement,
              eventPath = [elem || document],
              type = hasOwn.call(event, "type") ? event.type : event,
              namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          } // focus/blur morphs to focusin/out; ensure we're not firing them right now


          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }

          if (type.indexOf(".") > -1) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }

          ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

          event.result = undefined;

          if (!event.target) {
            event.target = elem;
          } // Clone any incoming data and prepend the event, creating the handler arg list


          data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

          special = jQuery.event.special[type] || {};

          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          } // Determine event propagation path in advance, per W3C events spec (trac-9951)
          // Bubble up to document, then to window; watch for a global ownerDocument var (trac-9724)


          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;

            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }

            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            } // Only add window if we got to document (e.g., not plain obj or detached DOM)


            if (tmp === (elem.ownerDocument || document)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window);
            }
          } // Fire handlers on the event path


          i = 0;

          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

            handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

            if (handle) {
              handle.apply(cur, data);
            } // Native handler


            handle = ontype && cur[ontype];

            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);

              if (event.result === false) {
                event.preventDefault();
              }
            }
          }

          event.type = type; // If nobody prevented the default action, do it now

          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              // Call a native DOM method on the target with the same name as the event.
              // Don't do default actions on window, that's where global variables be (trac-6170)
              if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                // Don't re-trigger an onFOO event when we call its FOO() method
                tmp = elem[ontype];

                if (tmp) {
                  elem[ontype] = null;
                } // Prevent re-triggering of the same event, since we already bubbled it above


                jQuery.event.triggered = type;

                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }

                elem[type]();

                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }

                jQuery.event.triggered = undefined;

                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }

          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function simulate(type, elem, event) {
          var e = jQuery.extend(new jQuery.Event(), event, {
            type: type,
            isSimulated: true
          });
          jQuery.event.trigger(e, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function trigger(type, data) {
          return this.each(function () {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function triggerHandler(type, data) {
          var elem = this[0];

          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/,
          rCRLF = /\r?\n/g,
          rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
          rsubmittable = /^(?:input|select|textarea|keygen)/i;

      function buildParams(prefix, obj, traditional, add) {
        var name;

        if (Array.isArray(obj)) {
          // Serialize array item.
          jQuery.each(obj, function (i, v) {
            if (traditional || rbracket.test(prefix)) {
              // Treat each array item as a scalar.
              add(prefix, v);
            } else {
              // Item is non-scalar (array or object), encode its numeric index.
              buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          // Serialize object item.
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          // Serialize scalar item.
          add(prefix, obj);
        }
      } // Serialize an array of form elements or a set of
      // key/values into a query string


      jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function add(key, valueOrFunction) {
          // If value is a function, invoke it and use its return value
          var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };

        if (a == null) {
          return "";
        } // If an array was passed in, assume that it is an array of form elements.


        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
          // Serialize the form elements
          jQuery.each(a, function () {
            add(this.name, this.value);
          });
        } else {
          // If traditional, encode the "old" way (the way 1.3.2 or older
          // did it), otherwise encode params recursively.
          for (prefix in a) {
            buildParams(prefix, a[prefix], traditional, add);
          }
        } // Return the resulting serialization


        return s.join("&");
      };

      jQuery.fn.extend({
        serialize: function serialize() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function serializeArray() {
          return this.map(function () {
            // Can add propHook for "elements" to filter or add form elements
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function () {
            var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function (_i, elem) {
            var val = jQuery(this).val();

            if (val == null) {
              return null;
            }

            if (Array.isArray(val)) {
              return jQuery.map(val, function (val) {
                return {
                  name: elem.name,
                  value: val.replace(rCRLF, "\r\n")
                };
              });
            }

            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          }).get();
        }
      });
      var r20 = /%20/g,
          rhash = /#.*$/,
          rantiCache = /([?&])_=[^&]*/,
          rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
          // trac-7653, trac-8125, trac-8152: local protocol detection
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
          rnoContent = /^(?:GET|HEAD)$/,
          rprotocol = /^\/\//,

      /* Prefilters
       * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
       * 2) These are called:
       *    - BEFORE asking for a transport
       *    - AFTER param serialization (s.data is a string if s.processData is true)
       * 3) key is the dataType
       * 4) the catchall symbol "*" can be used
       * 5) execution will start with transport dataType and THEN continue down to "*" if needed
       */
      prefilters = {},

      /* Transports bindings
       * 1) key is the dataType
       * 2) the catchall symbol "*" can be used
       * 3) selection will start with transport dataType and THEN go to "*" if needed
       */
      transports = {},
          // Avoid comment-prolog char sequence (trac-10098); must appease lint and evade compression
      allTypes = "*/".concat("*"),
          // Anchor tag for parsing the document origin
      originAnchor = document.createElement("a");
      originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

      function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }

          var dataType,
              i = 0,
              dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

          if (isFunction(func)) {
            // For each dataType in the dataTypeExpression
            while (dataType = dataTypes[i++]) {
              // Prepend if requested
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      } // Base inspection function for prefilters and transports


      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = structure === transports;

        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      } // A special extend for ajax options
      // that takes "flat" options (not to be deep extended)
      // Fixes trac-9887


      function ajaxExtend(target, src) {
        var key,
            deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
          if (src[key] !== undefined) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }

        if (deep) {
          jQuery.extend(true, target, deep);
        }

        return target;
      }
      /* Handles responses to an ajax request:
       * - finds the right dataType (mediates between content-type and expected dataType)
       * - returns the corresponding response
       */


      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct,
            type,
            finalDataType,
            firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

        while (dataTypes[0] === "*") {
          dataTypes.shift();

          if (ct === undefined) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        } // Check if we're dealing with a known content-type


        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        } // Check to see if we have a response for the expected dataType


        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          // Try convertible dataTypes
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }

            if (!firstDataType) {
              firstDataType = type;
            }
          } // Or just use first one


          finalDataType = finalDataType || firstDataType;
        } // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response


        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }

          return responses[finalDataType];
        }
      }
      /* Chain conversions given the request and the original response
       * Also sets the responseXXX fields on the jqXHR instance
       */


      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2,
            current,
            conv,
            tmp,
            prev,
            converters = {},
            // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }

        current = dataTypes.shift(); // Convert to each sequential dataType

        while (current) {
          if (s.responseFields[current]) {
            jqXHR[s.responseFields[current]] = response;
          } // Apply the dataFilter if provided


          if (!prev && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }

          prev = current;
          current = dataTypes.shift();

          if (current) {
            // There's only work to do if current dataType is non-auto
            if (current === "*") {
              current = prev; // Convert response if prev dataType is non-auto and differs from current
            } else if (prev !== "*" && prev !== current) {
              // Seek a direct converter
              conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

              if (!conv) {
                for (conv2 in converters) {
                  // If conv2 outputs current
                  tmp = conv2.split(" ");

                  if (tmp[1] === current) {
                    // If prev can be converted to accepted input
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                    if (conv) {
                      // Condense equivalence converters
                      if (conv === true) {
                        conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }

                      break;
                    }
                  }
                }
              } // Apply converter (if not an equivalence)


              if (conv !== true) {
                // Unless errors are allowed to bubble, catch and return them
                if (conv && s["throws"]) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }

        return {
          state: "success",
          data: response
        };
      }

      jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",

          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function ajaxSetup(target, settings) {
          return settings ? // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function ajax(url, options) {
          // If url is an object, simulate pre-1.5 signature
          if (typeof url === "object") {
            options = url;
            url = undefined;
          } // Force options to be an object


          options = options || {};

          var transport,
              // URL without anti-cache param
          cacheURL,
              // Response headers
          responseHeadersString,
              responseHeaders,
              // timeout handle
          timeoutTimer,
              // Url cleanup var
          urlAnchor,
              // Request state (becomes false upon send and true upon completion)
          completed,
              // To know if global events are to be dispatched
          fireGlobals,
              // Loop variable
          i,
              // uncached part of the url
          uncached,
              // Create the final options object
          s = jQuery.ajaxSetup({}, options),
              // Callbacks context
          callbackContext = s.context || s,
              // Context for global events is callbackContext if it is a DOM node or jQuery collection
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
              // Deferreds
          deferred = jQuery.Deferred(),
              completeDeferred = jQuery.Callbacks("once memory"),
              // Status-dependent callbacks
          _statusCode = s.statusCode || {},
              // Headers (they are sent all at once)
          requestHeaders = {},
              requestHeadersNames = {},
              // Default abort message
          strAbort = "canceled",
              // Fake xhr
          jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function getResponseHeader(key) {
              var match;

              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};

                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }

                match = responseHeaders[key.toLowerCase() + " "];
              }

              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function getAllResponseHeaders() {
              return completed ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function setRequestHeader(name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }

              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function overrideMimeType(type) {
              if (completed == null) {
                s.mimeType = type;
              }

              return this;
            },
            // Status-dependent callbacks
            statusCode: function statusCode(map) {
              var code;

              if (map) {
                if (completed) {
                  // Execute the appropriate callbacks
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  // Lazy-add the new callbacks in a way that preserves old ones
                  for (code in map) {
                    _statusCode[code] = [_statusCode[code], map[code]];
                  }
                }
              }

              return this;
            },
            // Cancel the request
            abort: function abort(statusText) {
              var finalText = statusText || strAbort;

              if (transport) {
                transport.abort(finalText);
              }

              done(0, finalText);
              return this;
            }
          }; // Attach deferreds


          deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
          // Handle falsy url in the settings object (trac-10093: consistency with old signature)
          // We also use the url parameter if available

          s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket trac-12004

          s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

          s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

          if (s.crossDomain == null) {
            urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
            // IE throws exception on accessing the href property if url is malformed,
            // e.g. http://example.com:80x/

            try {
              urlAnchor.href = s.url; // Support: IE <=8 - 11 only
              // Anchor's host property isn't correctly set when s.url is relative

              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e) {
              // If there is an error parsing the URL, assume it is crossDomain,
              // it can be rejected by the transport if it is invalid
              s.crossDomain = true;
            }
          } // Convert data if not already a string


          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery.param(s.data, s.traditional);
          } // Apply prefilters


          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

          if (completed) {
            return jqXHR;
          } // We can fire global events as of now if asked to
          // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (trac-15118)


          fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          } // Uppercase the type


          s.type = s.type.toUpperCase(); // Determine if request has content

          s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
          // and/or If-None-Match header later on
          // Remove hash to simplify url manipulation

          cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

          if (!s.hasContent) {
            // Remember the hash so we can put it back
            uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

            if (s.data && (s.processData || typeof s.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // trac-9682: remove data so that it's not used in an eventual retry

              delete s.data;
            } // Add or update anti-cache param if needed


            if (s.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            } // Put hash and anti-cache on the URL that will be requested (gh-1732)


            s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
          } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s.data = s.data.replace(r20, "+");
          } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


          if (s.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }

            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          } // Set the correct header, if data is being sent


          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          } // Set the Accepts header for the server, depending on the dataType


          jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

          for (i in s.headers) {
            jqXHR.setRequestHeader(i, s.headers[i]);
          } // Allow custom headers/mimetypes and early abort


          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
            // Abort if not done already and return
            return jqXHR.abort();
          } // Aborting is no longer a cancellation


          strAbort = "abort"; // Install callbacks on deferreds

          completeDeferred.add(s.complete);
          jqXHR.done(s.success);
          jqXHR.fail(s.error); // Get transport

          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1; // Send global event

            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            } // If request was aborted inside ajaxSend, stop there


            if (completed) {
              return jqXHR;
            } // Timeout


            if (s.async && s.timeout > 0) {
              timeoutTimer = window.setTimeout(function () {
                jqXHR.abort("timeout");
              }, s.timeout);
            }

            try {
              completed = false;
              transport.send(requestHeaders, done);
            } catch (e) {
              // Rethrow post-completion exceptions
              if (completed) {
                throw e;
              } // Propagate others as results


              done(-1, e);
            }
          } // Callback for when everything is done


          function done(status, nativeStatusText, responses, headers) {
            var isSuccess,
                success,
                error,
                response,
                modified,
                statusText = nativeStatusText; // Ignore repeat invocations

            if (completed) {
              return;
            }

            completed = true; // Clear timeout if it exists

            if (timeoutTimer) {
              window.clearTimeout(timeoutTimer);
            } // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)


            transport = undefined; // Cache response headers

            responseHeadersString = headers || ""; // Set readyState

            jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

            isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            } // Use a noop converter for missing script but not if jsonp


            if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
              s.converters["text script"] = function () {};
            } // Convert no matter what (that way responseXXX fields are always set)


            response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

            if (isSuccess) {
              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");

                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }

                modified = jqXHR.getResponseHeader("etag");

                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              } // if no content


              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent"; // if not modified
              } else if (status === 304) {
                statusText = "notmodified"; // If we have data, let's convert it
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              // Extract error from statusText and normalize for non-aborts
              error = statusText;

              if (status || !statusText) {
                statusText = "error";

                if (status < 0) {
                  status = 0;
                }
              }
            } // Set data for the fake xhr object


            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            } // Status-dependent callbacks


            jqXHR.statusCode(_statusCode);
            _statusCode = undefined;

            if (fireGlobals) {
              globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
            } // Complete


            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

              if (! --jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }

          return jqXHR;
        },
        getJSON: function getJSON(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function getScript(url, callback) {
          return jQuery.get(url, undefined, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function (_i, method) {
        jQuery[method] = function (url, data, callback, type) {
          // Shift arguments if data argument was omitted
          if (isFunction(data)) {
            type = type || callback;
            callback = data;
            data = undefined;
          } // The url can be an options object (which then must have .url)


          return jQuery.ajax(jQuery.extend({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery.ajaxPrefilter(function (s) {
        var i;

        for (i in s.headers) {
          if (i.toLowerCase() === "content-type") {
            s.contentType = s.headers[i] || "";
          }
        }
      });

      jQuery._evalUrl = function (url, options, doc) {
        return jQuery.ajax({
          url: url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function textScript() {}
          },
          dataFilter: function dataFilter(response) {
            jQuery.globalEval(response, options, doc);
          }
        });
      };

      jQuery.fn.extend({
        wrapAll: function wrapAll(html) {
          var wrap;

          if (this[0]) {
            if (isFunction(html)) {
              html = html.call(this[0]);
            } // The elements to wrap the target around


            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }

            wrap.map(function () {
              var elem = this;

              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }

              return elem;
            }).append(this);
          }

          return this;
        },
        wrapInner: function wrapInner(html) {
          if (isFunction(html)) {
            return this.each(function (i) {
              jQuery(this).wrapInner(html.call(this, i));
            });
          }

          return this.each(function () {
            var self = jQuery(this),
                contents = self.contents();

            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self.append(html);
            }
          });
        },
        wrap: function wrap(html) {
          var htmlIsFunction = isFunction(html);
          return this.each(function (i) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function unwrap(selector) {
          this.parent(selector).not("body").each(function () {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });

      jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };

      jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };

      jQuery.ajaxSettings.xhr = function () {
        try {
          return new window.XMLHttpRequest();
        } catch (e) {}
      };

      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      },
          xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function (options) {
        var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function send(headers, complete) {
              var i,
                  xhr = options.xhr();
              xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              } // Override mime type if needed


              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              } // X-Requested-With header
              // For cross-domain requests, seeing as conditions for a preflight are
              // akin to a jigsaw puzzle, we simply never set it to be sure.
              // (it can always be set on a per-request basis or even using ajaxSetup)
              // For same-domain requests, won't change header if already provided.


              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              } // Set headers


              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              } // Callback


              _callback = function callback(type) {
                return function () {
                  if (_callback) {
                    _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      // Support: IE <=9 only
                      // On a manual native abort, IE9 throws
                      // errors on any property access that is not readyState
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete( // File: protocol always yields status 0; see trac-8605, trac-14207
                        xhr.status, xhr.statusText);
                      }
                    } else {
                      complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                        binary: xhr.response
                      } : {
                        text: xhr.responseText
                      }, xhr.getAllResponseHeaders());
                    }
                  }
                };
              }; // Listen to events


              xhr.onload = _callback();
              errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
              // Use onreadystatechange to replace onabort
              // to handle uncaught aborts

              if (xhr.onabort !== undefined) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function () {
                  // Check readyState before timeout as it changes
                  if (xhr.readyState === 4) {
                    // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window.setTimeout(function () {
                      if (_callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              } // Create the abort callback


              _callback = _callback("abort");

              try {
                // Do send the request (this may raise an exception)
                xhr.send(options.hasContent && options.data || null);
              } catch (e) {
                // trac-14683: Only rethrow if this hasn't been notified as an error yet
                if (_callback) {
                  throw e;
                }
              }
            },
            abort: function abort() {
              if (_callback) {
                _callback();
              }
            }
          };
        }
      }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

      jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
          s.contents.script = false;
        }
      }); // Install script dataType

      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function textScript(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      }); // Handle cache's special case and crossDomain

      jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
          s.cache = false;
        }

        if (s.crossDomain) {
          s.type = "GET";
        }
      }); // Bind script tag hack transport

      jQuery.ajaxTransport("script", function (s) {
        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
          var script, _callback2;

          return {
            send: function send(_, complete) {
              script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                charset: s.scriptCharset,
                src: s.url
              }).on("load error", _callback2 = function callback(evt) {
                script.remove();
                _callback2 = null;

                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              }); // Use native DOM manipulation to avoid our domManip AJAX trickery

              document.head.appendChild(script[0]);
            },
            abort: function abort() {
              if (_callback2) {
                _callback2();
              }
            }
          };
        }
      });
      var oldCallbacks = [],
          rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function jsonpCallback() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      }); // Detect, normalize options and install callbacks for jsonp requests

      jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
        var callbackName,
            overwritten,
            responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

        if (jsonProp || s.dataTypes[0] === "jsonp") {
          // Get callback name, remembering preexisting value associated with it
          callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          } // Use data converter to retrieve json after script execution


          s.converters["script json"] = function () {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }

            return responseContainer[0];
          }; // Force json dataType


          s.dataTypes[0] = "json"; // Install callback

          overwritten = window[callbackName];

          window[callbackName] = function () {
            responseContainer = arguments;
          }; // Clean-up function (fires after converters)


          jqXHR.always(function () {
            // If previous value didn't exist - remove it
            if (overwritten === undefined) {
              jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
            } else {
              window[callbackName] = overwritten;
            } // Save back as free


            if (s[callbackName]) {
              // Make sure that re-using the options doesn't screw things around
              s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

              oldCallbacks.push(callbackName);
            } // Call if it was a function and we have a response


            if (responseContainer && isFunction(overwritten)) {
              overwritten(responseContainer[0]);
            }

            responseContainer = overwritten = undefined;
          }); // Delegate to script

          return "script";
        }
      }); // Support: Safari 8 only
      // In Safari 8 documents created via document.implementation.createHTMLDocument
      // collapse sibling forms: the second one becomes a child of the first one.
      // Because of that, this security measure has to be disabled in Safari 8.
      // https://bugs.webkit.org/show_bug.cgi?id=137337

      support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }(); // Argument "data" should be string of html
      // context (optional): If specified, the fragment will be created in this context,
      // defaults to document
      // keepScripts (optional): If true, will include scripts passed in the html string


      jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }

        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }

        var base, parsed, scripts;

        if (!context) {
          // Stop scripts or inline event handlers from being executed immediately
          // by using document.implementation
          if (support.createHTMLDocument) {
            context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
            // so any parsed elements with URLs
            // are based on the document's URL (gh-2965)

            base = context.createElement("base");
            base.href = document.location.href;
            context.head.appendChild(base);
          } else {
            context = document;
          }
        }

        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && []; // Single tag

        if (parsed) {
          return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
      };
      /**
       * Load a url into a page
       */


      jQuery.fn.load = function (url, params, callback) {
        var selector,
            type,
            response,
            self = this,
            off = url.indexOf(" ");

        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        } // If it's a function


        if (isFunction(params)) {
          // We assume that it's the callback
          callback = params;
          params = undefined; // Otherwise, build a param string
        } else if (params && typeof params === "object") {
          type = "POST";
        } // If we have elements to modify, make the request


        if (self.length > 0) {
          jQuery.ajax({
            url: url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function (responseText) {
            // Save response for use in complete callback
            response = arguments;
            self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
            responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
            // but they are ignored because response was set above.
            // If it fails, this function gets "jqXHR", "status", "error"
          }).always(callback && function (jqXHR, status) {
            self.each(function () {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }

        return this;
      };

      jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
          return elem === fn.elem;
        }).length;
      };

      jQuery.offset = {
        setOffset: function setOffset(elem, options, i) {
          var curPosition,
              curLeft,
              curCSSTop,
              curTop,
              curOffset,
              curCSSLeft,
              calculatePosition,
              position = jQuery.css(elem, "position"),
              curElem = jQuery(elem),
              props = {}; // Set position first, in-case top/left are set even on static elem

          if (position === "static") {
            elem.style.position = "relative";
          }

          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
          // top or left is auto and position is either absolute or fixed

          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }

          if (isFunction(options)) {
            // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call(elem, i, jQuery.extend({}, curOffset));
          }

          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }

          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }

          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function offset(options) {
          // Preserve chaining for setter
          if (arguments.length) {
            return options === undefined ? this : this.each(function (i) {
              jQuery.offset.setOffset(this, options, i);
            });
          }

          var rect,
              win,
              elem = this[0];

          if (!elem) {
            return;
          } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
          // Support: IE <=11 only
          // Running getBoundingClientRect on a
          // disconnected node in IE throws an error


          if (!elem.getClientRects().length) {
            return {
              top: 0,
              left: 0
            };
          } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function position() {
          if (!this[0]) {
            return;
          }

          var offsetParent,
              offset,
              doc,
              elem = this[0],
              parentOffset = {
            top: 0,
            left: 0
          }; // position:fixed elements are offset from the viewport, which itself always has zero offset

          if (jQuery.css(elem, "position") === "fixed") {
            // Assume position:fixed implies availability of getBoundingClientRect
            offset = elem.getBoundingClientRect();
          } else {
            offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
            // when a statically positioned element is identified

            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;

            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }

            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              // Incorporate borders into its offset, since they are outside its content origin
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          } // Subtract parent offsets and element margins


          return {
            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function offsetParent() {
          return this.map(function () {
            var offsetParent = this.offsetParent;

            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }

            return offsetParent || documentElement;
          });
        }
      }); // Create scrollLeft and scrollTop methods

      jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
          return access(this, function (elem, method, val) {
            // Coalesce documents and windows
            var win;

            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }

            if (val === undefined) {
              return win ? win[prop] : elem[method];
            }

            if (win) {
              win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
            } else {
              elem[method] = val;
            }
          }, method, val, arguments.length);
        };
      }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
      // Add the top/left cssHooks using jQuery.fn.position
      // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
      // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
      // getComputedStyle returns percent when specified for top/left/bottom/right;
      // rather than make the css module depend on the offset module, just check for it here

      jQuery.each(["top", "left"], function (_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

            return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
          }
        });
      }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

      jQuery.each({
        Height: "height",
        Width: "width"
      }, function (name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function (defaultExtra, funcName) {
          // Margin is only for outerHeight, outerWidth
          jQuery.fn[funcName] = function (margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function (elem, type, value) {
              var doc;

              if (isWindow(elem)) {
                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              } // Get document width or height


              if (elem.nodeType === 9) {
                doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                // whichever is greatest

                return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
              }

              return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
              jQuery.css(elem, type, extra) : // Set width or height on the element
              jQuery.style(elem, type, value, extra);
            }, type, chainable ? margin : undefined, chainable);
          };
        });
      });
      jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
        jQuery.fn[type] = function (fn) {
          return this.on(type, fn);
        };
      });
      jQuery.fn.extend({
        bind: function bind(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function unbind(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function delegate(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function undelegate(selector, types, fn) {
          // ( namespace ) or ( selector, types [, fn] )
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function hover(fnOver, fnOut) {
          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
      });
      jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
        // Handle event binding
        jQuery.fn[name] = function (data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      }); // Support: Android <=4.0 only
      // Make sure we trim BOM and NBSP
      // Require that the "whitespace run" starts from a non-whitespace
      // to avoid O(N^2) behavior when the engine would try matching "\s+$" at each space position.

      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
      // arguments.
      // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
      // However, it is not slated for removal any time soon

      jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        } // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.


        if (!isFunction(fn)) {
          return undefined;
        } // Simulated bind


        args = _slice.call(arguments, 2);

        proxy = function proxy() {
          return fn.apply(context || this, args.concat(_slice.call(arguments)));
        }; // Set the guid of unique handler to the same of original handler, so it can be removed


        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };

      jQuery.holdReady = function (hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };

      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;

      jQuery.isNumeric = function (obj) {
        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };

      jQuery.trim = function (text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      }; // Register as a named AMD module, since jQuery can be concatenated with other
      // files that may use define, but not via a proper concatenation script that
      // understands anonymous AMD modules. A named AMD is safest and most robust
      // way to register. Lowercase jquery is used because AMD module names are
      // derived from file names, and jQuery is normally delivered in a lowercase
      // file name. Do this after creating the global so that if an AMD module wants
      // to call noConflict to hide this version of jQuery, it will work.
      // Note that for maximum portability, libraries that are not jQuery should
      // declare themselves as anonymous modules, and avoid setting a global if an
      // AMD loader is present. jQuery is a special case. For more information, see
      // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return jQuery;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }

      var // Map over jQuery in case of overwrite
      _jQuery = window.jQuery,
          // Map over the $ in case of overwrite
      _$ = window.$;

      jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
          window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
          window.jQuery = _jQuery;
        }

        return jQuery;
      }; // Expose jQuery and $ identifiers, even in AMD
      // (trac-7102#comment:10, https://github.com/jquery/jquery/pull/557)
      // and CommonJS for browser emulators (trac-13566)


      if (typeof noGlobal === "undefined") {
        window.jQuery = window.$ = jQuery;
      }

      return jQuery;
    });
    /***/

  },

  /***/
  "./node_modules/ngx-bootstrap/__ivy_ngcc__/collapse/fesm2015/ngx-bootstrap-collapse.js":
  /*!*********************************************************************************************!*\
    !*** ./node_modules/ngx-bootstrap/__ivy_ngcc__/collapse/fesm2015/ngx-bootstrap-collapse.js ***!
    \*********************************************************************************************/

  /*! exports provided: CollapseDirective, CollapseModule */

  /***/
  function node_modulesNgxBootstrap__ivy_ngcc__CollapseFesm2015NgxBootstrapCollapseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CollapseDirective", function () {
      return CollapseDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CollapseModule", function () {
      return CollapseModule;
    });
    /* harmony import */


    var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! @angular/animations */
    "./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    var COLLAPSE_ANIMATION_TIMING = '400ms cubic-bezier(0.4,0.0,0.2,1)';
    /** @type {?} */

    var expandAnimation = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      height: 0,
      visibility: 'hidden'
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(COLLAPSE_ANIMATION_TIMING, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      height: '*',
      visibility: 'visible'
    }))];
    /** @type {?} */

    var collapseAnimation = [Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      height: '*',
      visibility: 'visible'
    }), Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["animate"])(COLLAPSE_ANIMATION_TIMING, Object(_angular_animations__WEBPACK_IMPORTED_MODULE_0__["style"])({
      height: 0,
      visibility: 'hidden'
    }))];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    var CollapseDirective = /*#__PURE__*/function () {
      /**
       * @param {?} _el
       * @param {?} _renderer
       * @param {?} _builder
       */
      function CollapseDirective(_el, _renderer, _builder) {
        _classCallCheck(this, CollapseDirective);

        this._el = _el;
        this._renderer = _renderer;
        /**
         * This event fires as soon as content collapses
         */

        this.collapsed = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event fires when collapsing is started
         */

        this.collapses = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event fires as soon as content becomes visible
         */

        this.expanded = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"]();
        /**
         * This event fires when expansion is started
         */

        this.expands = new _angular_core__WEBPACK_IMPORTED_MODULE_1__["EventEmitter"](); // shown

        this.isExpanded = true;
        this.collapseNewValue = true; // hidden

        this.isCollapsed = false; // stale state

        this.isCollapse = true; // animation state

        this.isCollapsing = false;
        /**
         * turn on/off animation
         */

        this.isAnimated = false;
        this._display = 'block';
        this._stylesLoaded = false;
        this._COLLAPSE_ACTION_NAME = 'collapse';
        this._EXPAND_ACTION_NAME = 'expand';
        this._factoryCollapseAnimation = _builder.build(collapseAnimation);
        this._factoryExpandAnimation = _builder.build(expandAnimation);
      }
      /**
       * @param {?} value
       * @return {?}
       */


      _createClass(CollapseDirective, [{
        key: "display",
        set: function set(value) {
          if (!this.isAnimated) {
            this._renderer.setStyle(this._el.nativeElement, 'display', value);

            return;
          }

          this._display = value;

          if (value === 'none') {
            this.hide();
            return;
          }

          this.show();
        }
        /**
         * A flag indicating visibility of content (shown or hidden)
         * @param {?} value
         * @return {?}
         */

      }, {
        key: "collapse",
        get:
        /**
         * @return {?}
         */
        function get() {
          return this.isExpanded;
        }
        /**
         * @return {?}
         */
        ,
        set: function set(value) {
          this.collapseNewValue = value;

          if (!this._player || this._isAnimationDone) {
            this.isExpanded = value;
            this.toggle();
          }
        }
      }, {
        key: "ngAfterViewChecked",
        value: function ngAfterViewChecked() {
          this._stylesLoaded = true;

          if (!this._player || !this._isAnimationDone) {
            return;
          }

          this._player.reset();

          this._renderer.setStyle(this._el.nativeElement, 'height', '*');
        }
        /**
         * allows to manually toggle content visibility
         * @return {?}
         */

      }, {
        key: "toggle",
        value: function toggle() {
          if (this.isExpanded) {
            this.hide();
          } else {
            this.show();
          }
        }
        /**
         * allows to manually hide content
         * @return {?}
         */

      }, {
        key: "hide",
        value: function hide() {
          var _this3 = this;

          this.isCollapsing = true;
          this.isExpanded = false;
          this.isCollapsed = true;
          this.isCollapsing = false;
          this.collapses.emit(this);
          this._isAnimationDone = false;
          this.animationRun(this.isAnimated, this._COLLAPSE_ACTION_NAME)(
          /**
          * @return {?}
          */
          function () {
            _this3._isAnimationDone = true;

            if (_this3.collapseNewValue !== _this3.isCollapsed && _this3.isAnimated) {
              _this3.show();

              return;
            }

            _this3.collapsed.emit(_this3);

            _this3._renderer.setStyle(_this3._el.nativeElement, 'display', 'none');
          });
        }
        /**
         * allows to manually show collapsed content
         * @return {?}
         */

      }, {
        key: "show",
        value: function show() {
          var _this4 = this;

          this._renderer.setStyle(this._el.nativeElement, 'display', this._display);

          this.isCollapsing = true;
          this.isExpanded = true;
          this.isCollapsed = false;
          this.isCollapsing = false;
          this.expands.emit(this);
          this._isAnimationDone = false;
          this.animationRun(this.isAnimated, this._EXPAND_ACTION_NAME)(
          /**
          * @return {?}
          */
          function () {
            _this4._isAnimationDone = true;

            if (_this4.collapseNewValue !== _this4.isCollapsed && _this4.isAnimated) {
              _this4.hide();

              return;
            }

            _this4.expanded.emit(_this4);

            _this4._renderer.removeStyle(_this4._el.nativeElement, 'overflow');
          });
        }
        /**
         * @param {?} isAnimated
         * @param {?} action
         * @return {?}
         */

      }, {
        key: "animationRun",
        value: function animationRun(isAnimated, action) {
          var _this5 = this;

          if (!isAnimated || !this._stylesLoaded) {
            return (
              /**
              * @param {?} callback
              * @return {?}
              */
              function (callback) {
                return callback();
              }
            );
          }

          this._renderer.setStyle(this._el.nativeElement, 'overflow', 'hidden');

          this._renderer.addClass(this._el.nativeElement, 'collapse');
          /** @type {?} */


          var factoryAnimation = action === this._EXPAND_ACTION_NAME ? this._factoryExpandAnimation : this._factoryCollapseAnimation;

          if (this._player) {
            this._player.destroy();
          }

          this._player = factoryAnimation.create(this._el.nativeElement);

          this._player.play();

          return (
            /**
            * @param {?} callback
            * @return {?}
            */
            function (callback) {
              return _this5._player.onDone(callback);
            }
          );
        }
      }]);

      return CollapseDirective;
    }();

    CollapseDirective.ɵfac = function CollapseDirective_Factory(t) {
      return new (t || CollapseDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdirectiveInject"](_angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]));
    };

    CollapseDirective.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineDirective"]({
      type: CollapseDirective,
      selectors: [["", "collapse", ""]],
      hostVars: 10,
      hostBindings: function CollapseDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵattribute"]("aria-expanded", ctx.isExpanded)("aria-hidden", ctx.isCollapsed);

          _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵclassProp"]("collapse", ctx.isCollapse)("in", ctx.isExpanded)("show", ctx.isExpanded)("collapsing", ctx.isCollapsing);
        }
      },
      inputs: {
        isAnimated: "isAnimated",
        display: "display",
        collapse: "collapse"
      },
      outputs: {
        collapsed: "collapsed",
        collapses: "collapses",
        expanded: "expanded",
        expands: "expands"
      },
      exportAs: ["bs-collapse"]
    });
    /** @nocollapse */

    CollapseDirective.ctorParameters = function () {
      return [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
      }, {
        type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]
      }];
    };

    CollapseDirective.propDecorators = {
      collapsed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      collapses: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      expanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      expands: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
      }],
      isExpanded: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.in']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.show']
      }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-expanded']
      }],
      isCollapsed: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['attr.aria-hidden']
      }],
      isCollapse: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.collapse']
      }],
      isCollapsing: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
        args: ['class.collapsing']
      }],
      display: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      isAnimated: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }],
      collapse: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
      }]
    };
    /*@__PURE__*/

    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](CollapseDirective, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Directive"],
        args: [{
          selector: '[collapse]',
          exportAs: 'bs-collapse',
          host: {
            '[class.collapse]': 'true'
          }
        }]
      }], function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ElementRef"]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Renderer2"]
        }, {
          type: _angular_animations__WEBPACK_IMPORTED_MODULE_0__["AnimationBuilder"]
        }];
      }, {
        collapsed: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }],
        collapses: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }],
        expanded: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }],
        expands: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Output"]
        }],
        isExpanded: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['class.in']
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['class.show']
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['attr.aria-expanded']
        }],
        isCollapsed: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['attr.aria-hidden']
        }],
        isCollapse: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['class.collapse']
        }],
        isCollapsing: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["HostBinding"],
          args: ['class.collapsing']
        }],
        isAnimated: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        display: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }],
        collapse: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"]
        }]
      });
    })();

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    var CollapseModule = /*#__PURE__*/function () {
      function CollapseModule() {
        _classCallCheck(this, CollapseModule);
      }

      _createClass(CollapseModule, null, [{
        key: "forRoot",
        value:
        /**
         * @return {?}
         */
        function forRoot() {
          return {
            ngModule: CollapseModule,
            providers: []
          };
        }
      }]);

      return CollapseModule;
    }();

    CollapseModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
      type: CollapseModule
    });
    CollapseModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({
      factory: function CollapseModule_Factory(t) {
        return new (t || CollapseModule)();
      }
    });

    (function () {
      (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵsetNgModuleScope"](CollapseModule, {
        declarations: [CollapseDirective],
        exports: [CollapseDirective]
      });
    })();
    /*@__PURE__*/


    (function () {
      _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](CollapseModule, [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"],
        args: [{
          declarations: [CollapseDirective],
          exports: [CollapseDirective]
        }]
      }], null, null);
    })();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    //# sourceMappingURL=ngx-bootstrap-collapse.js.map

    /***/

  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/breadcrumbs/breadcrumb1/breadcrumb1.component.html":
  /*!****************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/breadcrumbs/breadcrumb1/breadcrumb1.component.html ***!
    \****************************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxBreadcrumbsBreadcrumb1Breadcrumb1ComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"navbar-breadcrumb\">\r\n  <h5 class=\"mb-0\">{{ title }}</h5>\r\n  <nav aria-label=\"breadcrumb\">\r\n    <ul class=\"breadcrumb\">\r\n      <li *ngFor=\"let item of items\" class=\"animate__animated animate__fadeIn breadcrumb-item {{ (item.isActive) ? 'active' : '' }}\">\r\n        <span *ngIf=\"item.isActive\">{{ item.label }}</span>\r\n        <a *ngIf=\"!item.isActive\" [href]=\"item.link\">{{ item.label }}</a>\r\n      </li>\r\n    </ul>\r\n  </nav>\r\n</div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/card-with-image/card-with-image.component.html":
  /*!************************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/card-with-image/card-with-image.component.html ***!
    \************************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxCardWithImageCardWithImageComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div [ngClass]=\"cardClass\">\r\n  <div [ngClass]=\"cardRowClass\">\r\n    <div class=\"col-md-4\">\r\n      <ng-content select=\"[card-image]\"></ng-content>\r\n    </div>\r\n    <div class=\"col-md-8\">\r\n      <div [ngClass]=\"cardBodyClass\">\r\n        <ng-content></ng-content>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/cards/iq-card/iq-card.component.html":
  /*!**************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/cards/iq-card/iq-card.component.html ***!
    \**************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxCardsIqCardIqCardComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div [ngClass]=\"cardClass\">\r\n  <!-- card image or extra content here -->\r\n  <ng-content select=\"[card-top]\"></ng-content>\r\n  <!-- card header content here -->\r\n  <div [ngClass]=\"cardHeaderClass\" *ngIf=\"isCardHeader\">\r\n    <ng-content select=\"[card-header]\"></ng-content>\r\n  </div>\r\n  <!-- card body content here  -->\r\n  <div [ngClass]=\"cardBodyClass\" *ngIf=\"isCardBody\">\r\n    <ng-content></ng-content>\r\n  </div>\r\n  <!-- card footer content here  -->\r\n  <div [ngClass]=\"cardFooterClass\" *ngIf=\"isCardFooter\">\r\n    <ng-content select=\"[card-footer]\"></ng-content>\r\n  </div>\r\n  <!-- card extra content here  -->\r\n  <ng-content select=\"[card-bottom]\"></ng-content>\r\n</div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/charts/apex-chart/apex-chart.component.html":
  /*!*********************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/charts/apex-chart/apex-chart.component.html ***!
    \*********************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxChartsApexChartApexChartComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div [id]=\"ids\"></div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/charts/high-chart/high-chart.component.html":
  /*!*********************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/charts/high-chart/high-chart.component.html ***!
    \*********************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxChartsHighChartHighChartComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div [id]=\"ids\"></div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/full-calendar/full-calendar.component.html":
  /*!********************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/full-calendar/full-calendar.component.html ***!
    \********************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxFullCalendarFullCalendarComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<full-calendar\r\n  defaultView=\"dayGridMonth\"\r\n  [plugins]=\"calendarPlugins\"\r\n  [events]=\"calendarEvents\"\r\n  [weekends]=\"calendarWeekends\"\r\n></full-calendar>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/loaders/loader1/loader.component.html":
  /*!***************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/loaders/loader1/loader.component.html ***!
    \***************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxLoadersLoader1LoaderComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- Loader [START] -->\r\n<div id=\"loading\">\r\n  <div id=\"loading-center\">\r\n    <div class=\"loader\">\r\n      <div class=\"cube\">\r\n        <div class=\"sides\">\r\n          <div class=\"top\"></div>\r\n          <div class=\"right\"></div>\r\n          <div class=\"bottom\"></div>\r\n          <div class=\"left\"></div>\r\n          <div class=\"front\"></div>\r\n          <div class=\"back\"></div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<!-- Loader [END] -->\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/scroll-top/scroll-top.component.html":
  /*!**************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/scroll-top/scroll-top.component.html ***!
    \**************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxScrollTopScrollTopComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<!-- back-to-top -->\r\n<div id=\"back-to-top\" style=\"display: none;\">\r\n  <a class=\"top\" id=\"top\" href=\"javascript:void(0)\" (click)=\"scrollTop()\"> <i class=\"ion-ios-upload-outline\"></i> </a>\r\n</div>\r\n<!-- back-to-top End -->\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/tabs/tab-content/tab-content.component.html":
  /*!*********************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/tabs/tab-content/tab-content.component.html ***!
    \*********************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxTabsTabContentTabContentComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<div class=\"tab-pane fade\" [id]=\"tabContentLink\" role=\"tabpanel\">\r\n   <ng-content select=\"[tab-content]\"></ng-content>\r\n</div>\r\n";
    /***/
  },

  /***/
  "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/tabs/tab-nav/tab-nav.component.html":
  /*!*************************************************************************************************************!*\
    !*** ./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/tabs/tab-nav/tab-nav.component.html ***!
    \*************************************************************************************************************/

  /*! exports provided: default */

  /***/
  function node_modulesRawLoaderDistCjsJsSrcAppComponentsSofboxTabsTabNavTabNavComponentHtml(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "<ul [classList]=\"tabClass\">\r\n  <li *ngFor=\"let tabNavItem of tabNavItems; let index = index\">\r\n    <a [href]=\"tabNavItem.link\"\r\n       [ngClass]=\"(tabNavItem.isActive ? 'nav-link active' : 'nav-link' )\"\r\n       role=\"tab\" data-toggle=\"pill\"\r\n       [attr.active]=\"tabNavItem.isActive\">\r\n      <i *ngIf=\"tabNavItem.icon\" [classList]=\"tabNavItem.icon\"></i>{{ tabNavItem.label }}\r\n      <span [innerHTML]=\"tabNavItem.append\"></span>\r\n    </a>\r\n  </li>\r\n</ul>\r\n";
    /***/
  },

  /***/
  "./src/app/components/sofbox/breadcrumbs/breadcrumb1/breadcrumb1.component.ts":
  /*!************************************************************************************!*\
    !*** ./src/app/components/sofbox/breadcrumbs/breadcrumb1/breadcrumb1.component.ts ***!
    \************************************************************************************/

  /*! exports provided: Breadcrumb1Component */

  /***/
  function srcAppComponentsSofboxBreadcrumbsBreadcrumb1Breadcrumb1ComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Breadcrumb1Component", function () {
      return Breadcrumb1Component;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var Breadcrumb1Component = /*#__PURE__*/function () {
      function Breadcrumb1Component() {
        _classCallCheck(this, Breadcrumb1Component);
      }

      _createClass(Breadcrumb1Component, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return Breadcrumb1Component;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], Breadcrumb1Component.prototype, "title", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], Breadcrumb1Component.prototype, "items", void 0);
    Breadcrumb1Component = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-breadcrumb1',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./breadcrumb1.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/breadcrumbs/breadcrumb1/breadcrumb1.component.html"))["default"]
    })], Breadcrumb1Component);
    /***/
  },

  /***/
  "./src/app/components/sofbox/card-with-image/card-with-image.component.ts":
  /*!********************************************************************************!*\
    !*** ./src/app/components/sofbox/card-with-image/card-with-image.component.ts ***!
    \********************************************************************************/

  /*! exports provided: CardWithImageComponent */

  /***/
  function srcAppComponentsSofboxCardWithImageCardWithImageComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CardWithImageComponent", function () {
      return CardWithImageComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var CardWithImageComponent = /*#__PURE__*/function () {
      function CardWithImageComponent() {
        _classCallCheck(this, CardWithImageComponent);

        this.cardClass = 'iq-card';
        this.cardRowClass = 'row no-gutters';
        this.cardBodyClass = 'card-body';
      }

      _createClass(CardWithImageComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return CardWithImageComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], CardWithImageComponent.prototype, "cardClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], CardWithImageComponent.prototype, "cardRowClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], CardWithImageComponent.prototype, "cardBodyClass", void 0);
    CardWithImageComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-card-with-image',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./card-with-image.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/card-with-image/card-with-image.component.html"))["default"]
    })], CardWithImageComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/cards/iq-card/iq-card.component.ts":
  /*!**********************************************************************!*\
    !*** ./src/app/components/sofbox/cards/iq-card/iq-card.component.ts ***!
    \**********************************************************************/

  /*! exports provided: IqCardComponent */

  /***/
  function srcAppComponentsSofboxCardsIqCardIqCardComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IqCardComponent", function () {
      return IqCardComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var IqCardComponent = /*#__PURE__*/function () {
      function IqCardComponent() {
        _classCallCheck(this, IqCardComponent);

        this.cardClass = 'iq-card';
        this.cardHeaderClass = 'iq-card-header d-flex justify-content-between';
        this.cardBodyClass = 'iq-card-body';
        this.cardFooterClass = 'card-footer';
        this.isCardHeader = true;
        this.isCardBody = true;
        this.isCardFooter = false;
      }

      _createClass(IqCardComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return IqCardComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "cardClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "cardHeaderClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "cardBodyClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "cardFooterClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "isCardHeader", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "isCardBody", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], IqCardComponent.prototype, "isCardFooter", void 0);
    IqCardComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-iq-card',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./iq-card.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/cards/iq-card/iq-card.component.html"))["default"]
    })], IqCardComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/charts/apex-chart/apex-chart.component.ts":
  /*!*****************************************************************************!*\
    !*** ./src/app/components/sofbox/charts/apex-chart/apex-chart.component.ts ***!
    \*****************************************************************************/

  /*! exports provided: ApexChartComponent */

  /***/
  function srcAppComponentsSofboxChartsApexChartApexChartComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ApexChartComponent", function () {
      return ApexChartComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _plugins_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../../../../plugins.service */
    "./src/app/plugins.service.ts");

    var ApexChartComponent = /*#__PURE__*/function () {
      function ApexChartComponent(plugins) {
        _classCallCheck(this, ApexChartComponent);

        this.plugins = plugins;
      }

      _createClass(ApexChartComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this = this;

          setTimeout(function () {
            _this.plugins.apexChart(_this.ids, _this.options);
          }, 500);
        }
      }]);

      return ApexChartComponent;
    }();

    ApexChartComponent.ctorParameters = function () {
      return [{
        type: _plugins_service__WEBPACK_IMPORTED_MODULE_2__["PluginsService"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], ApexChartComponent.prototype, "ids", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], ApexChartComponent.prototype, "options", void 0);
    ApexChartComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-apex-chart',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./apex-chart.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/charts/apex-chart/apex-chart.component.html"))["default"]
    })], ApexChartComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/charts/high-chart/high-chart.component.ts":
  /*!*****************************************************************************!*\
    !*** ./src/app/components/sofbox/charts/high-chart/high-chart.component.ts ***!
    \*****************************************************************************/

  /*! exports provided: HighChartComponent */

  /***/
  function srcAppComponentsSofboxChartsHighChartHighChartComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HighChartComponent", function () {
      return HighChartComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _plugins_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../../../../plugins.service */
    "./src/app/plugins.service.ts");
    /* harmony import */


    var highcharts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! highcharts */
    "./node_modules/highcharts/highcharts.js");
    /* harmony import */


    var highcharts__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(highcharts__WEBPACK_IMPORTED_MODULE_3__);

    var HighChartComponent = /*#__PURE__*/function () {
      function HighChartComponent(plugins) {
        _classCallCheck(this, HighChartComponent);

        this.plugins = plugins;
      }

      _createClass(HighChartComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {
          var _this6 = this;

          setTimeout(function () {
            if (_this6.ids !== undefined) {
              highcharts__WEBPACK_IMPORTED_MODULE_3__["chart"](_this6.ids, _this6.options);
            }
          }, 500);
        }
      }]);

      return HighChartComponent;
    }();

    HighChartComponent.ctorParameters = function () {
      return [{
        type: _plugins_service__WEBPACK_IMPORTED_MODULE_2__["PluginsService"]
      }];
    };

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], HighChartComponent.prototype, "ids", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], HighChartComponent.prototype, "options", void 0);
    HighChartComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-high-chart',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./high-chart.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/charts/high-chart/high-chart.component.html"))["default"]
    })], HighChartComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/full-calendar/full-calendar.component.css":
  /*!*****************************************************************************!*\
    !*** ./src/app/components/sofbox/full-calendar/full-calendar.component.css ***!
    \*****************************************************************************/

  /*! exports provided: default */

  /***/
  function srcAppComponentsSofboxFullCalendarFullCalendarComponentCss(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony default export */


    __webpack_exports__["default"] = "@charset \"UTF-8\";\n.fc {\n  direction: ltr;\n  text-align: left;\n}\n.fc-rtl {\n  text-align: right;\n}\nbody .fc {\n  /* extra precedence to overcome jqui */\n  font-size: 1em;\n}\n/* Colors\n--------------------------------------------------------------------------------------------------*/\n.fc-highlight {\n  /* when user is selecting cells */\n  background: #bce8f1;\n  opacity: 0.3;\n}\n.fc-bgevent {\n  /* default look for background events */\n  background: #8fdf82;\n  opacity: 0.3;\n}\n.fc-nonbusiness {\n  /* default look for non-business-hours areas */\n  /* will inherit .fc-bgevent's styles */\n  background: #d7d7d7;\n}\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-popover {\n  position: absolute;\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);\n}\n.fc-popover .fc-header {\n  /* TODO: be more consistent with fc-head/fc-body */\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  align-items: center;\n  padding: 2px 4px;\n}\n.fc-rtl .fc-popover .fc-header {\n  flex-direction: row-reverse;\n}\n.fc-popover .fc-header .fc-title {\n  margin: 0 2px;\n}\n.fc-popover .fc-header .fc-close {\n  cursor: pointer;\n  opacity: 0.65;\n  font-size: 1.1em;\n}\n/* Misc Reusable Components\n--------------------------------------------------------------------------------------------------*/\n.fc-divider {\n  border-style: solid;\n  border-width: 1px;\n}\nhr.fc-divider {\n  height: 0;\n  margin: 0;\n  padding: 0 0 2px;\n  /* height is unreliable across browsers, so use padding */\n  border-width: 1px 0;\n}\n.fc-bg,\n.fc-bgevent-skeleton,\n.fc-highlight-skeleton,\n.fc-mirror-skeleton {\n  /* these element should always cling to top-left/right corners */\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n.fc-bg {\n  bottom: 0;\n  /* strech bg to bottom edge */\n}\n.fc-bg table {\n  height: 100%;\n  /* strech bg to bottom edge */\n}\n/* Tables\n--------------------------------------------------------------------------------------------------*/\n.fc table {\n  width: 100%;\n  box-sizing: border-box;\n  /* fix scrollbar issue in firefox */\n  table-layout: fixed;\n  border-collapse: collapse;\n  border-spacing: 0;\n  font-size: 1em;\n  /* normalize cross-browser */\n}\n.fc th {\n  text-align: center;\n}\n.fc th,\n.fc td {\n  border-style: solid;\n  border-width: 1px;\n  padding: 0;\n  vertical-align: top;\n}\n.fc td.fc-today {\n  border-style: double;\n  /* overcome neighboring borders */\n}\n/* Internal Nav Links\n--------------------------------------------------------------------------------------------------*/\na[data-goto] {\n  cursor: pointer;\n}\na[data-goto]:hover {\n  text-decoration: underline;\n}\n/* Fake Table Rows\n--------------------------------------------------------------------------------------------------*/\n.fc .fc-row {\n  /* extra precedence to overcome themes forcing a 1px border */\n  /* no visible border by default. but make available if need be (scrollbar width compensation) */\n  border-style: solid;\n  border-width: 0;\n}\n.fc-row table {\n  /* don't put left/right border on anything within a fake row.\n     the outer tbody will worry about this */\n  border-left: 0 hidden transparent;\n  border-right: 0 hidden transparent;\n  /* no bottom borders on rows */\n  border-bottom: 0 hidden transparent;\n}\n.fc-row:first-child table {\n  border-top: 0 hidden transparent;\n  /* no top border on first row */\n}\n/* Day Row (used within the header and the DayGrid)\n--------------------------------------------------------------------------------------------------*/\n.fc-row {\n  position: relative;\n}\n.fc-row .fc-bg {\n  z-index: 1;\n}\n/* highlighting cells & background event skeleton */\n.fc-row .fc-bgevent-skeleton,\n.fc-row .fc-highlight-skeleton {\n  bottom: 0;\n  /* stretch skeleton to bottom of row */\n}\n.fc-row .fc-bgevent-skeleton table,\n.fc-row .fc-highlight-skeleton table {\n  height: 100%;\n  /* stretch skeleton to bottom of row */\n}\n.fc-row .fc-highlight-skeleton td,\n.fc-row .fc-bgevent-skeleton td {\n  border-color: transparent;\n}\n.fc-row .fc-bgevent-skeleton {\n  z-index: 2;\n}\n.fc-row .fc-highlight-skeleton {\n  z-index: 3;\n}\n/*\nrow content (which contains day/week numbers and events) as well as \"mirror\" (which contains\ntemporary rendered events).\n*/\n.fc-row .fc-content-skeleton {\n  position: relative;\n  z-index: 4;\n  padding-bottom: 2px;\n  /* matches the space above the events */\n}\n.fc-row .fc-mirror-skeleton {\n  z-index: 5;\n}\n.fc .fc-row .fc-content-skeleton table,\n.fc .fc-row .fc-content-skeleton td,\n.fc .fc-row .fc-mirror-skeleton td {\n  /* see-through to the background below */\n  /* extra precedence to prevent theme-provided backgrounds */\n  background: none;\n  /* in case <td>s are globally styled */\n  border-color: transparent;\n}\n.fc-row .fc-content-skeleton td,\n.fc-row .fc-mirror-skeleton td {\n  /* don't put a border between events and/or the day number */\n  border-bottom: 0;\n}\n.fc-row .fc-content-skeleton tbody td,\n.fc-row .fc-mirror-skeleton tbody td {\n  /* don't put a border between event cells */\n  border-top: 0;\n}\n/* Scrolling Container\n--------------------------------------------------------------------------------------------------*/\n.fc-scroller {\n  -webkit-overflow-scrolling: touch;\n}\n/* TODO: move to timegrid/daygrid */\n.fc-scroller > .fc-day-grid,\n.fc-scroller > .fc-time-grid {\n  position: relative;\n  /* re-scope all positions */\n  width: 100%;\n  /* hack to force re-sizing this inner element when scrollbars appear/disappear */\n}\n/* Global Event Styles\n--------------------------------------------------------------------------------------------------*/\n.fc-event {\n  position: relative;\n  /* for resize handle and other inner positioning */\n  display: block;\n  /* make the <a> tag block */\n  font-size: 0.85em;\n  line-height: 1.4;\n  border-radius: 3px;\n  border: 1px solid #3788d8;\n}\n.fc-event,\n.fc-event-dot {\n  background-color: #3788d8;\n  /* default BACKGROUND color */\n}\n.fc-event,\n.fc-event:hover {\n  color: #fff;\n  /* default TEXT color */\n  text-decoration: none;\n  /* if <a> has an href */\n}\n.fc-event[href],\n.fc-event.fc-draggable {\n  cursor: pointer;\n  /* give events with links and draggable events a hand mouse pointer */\n}\n.fc-not-allowed,\n.fc-not-allowed .fc-event {\n  /* to override an event's custom cursor */\n  cursor: not-allowed;\n}\n.fc-event .fc-content {\n  position: relative;\n  z-index: 2;\n}\n/* resizer (cursor AND touch devices) */\n.fc-event .fc-resizer {\n  position: absolute;\n  z-index: 4;\n}\n/* resizer (touch devices) */\n.fc-event .fc-resizer {\n  display: none;\n}\n.fc-event.fc-allow-mouse-resize .fc-resizer,\n.fc-event.fc-selected .fc-resizer {\n  /* only show when hovering or selected (with touch) */\n  display: block;\n}\n/* hit area */\n.fc-event.fc-selected .fc-resizer:before {\n  /* 40x40 touch area */\n  content: \"\";\n  position: absolute;\n  z-index: 9999;\n  /* user of this util can scope within a lower z-index */\n  top: 50%;\n  left: 50%;\n  width: 40px;\n  height: 40px;\n  margin-left: -20px;\n  margin-top: -20px;\n}\n/* Event Selection (only for touch devices)\n--------------------------------------------------------------------------------------------------*/\n.fc-event.fc-selected {\n  z-index: 9999 !important;\n  /* overcomes inline z-index */\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n}\n.fc-event.fc-selected:after {\n  content: \"\";\n  position: absolute;\n  z-index: 1;\n  /* same z-index as fc-bg, behind text */\n  /* overcome the borders */\n  top: -1px;\n  right: -1px;\n  bottom: -1px;\n  left: -1px;\n  /* darkening effect */\n  background: #000;\n  opacity: 0.25;\n}\n/* Event Dragging\n--------------------------------------------------------------------------------------------------*/\n.fc-event.fc-dragging.fc-selected {\n  box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3);\n}\n.fc-event.fc-dragging:not(.fc-selected) {\n  opacity: 0.75;\n}\n/* Horizontal Events\n--------------------------------------------------------------------------------------------------*/\n/* bigger touch area when selected */\n.fc-h-event.fc-selected:before {\n  content: \"\";\n  position: absolute;\n  z-index: 3;\n  /* below resizers */\n  top: -10px;\n  bottom: -10px;\n  left: 0;\n  right: 0;\n}\n/* events that are continuing to/from another week. kill rounded corners and butt up against edge */\n.fc-ltr .fc-h-event.fc-not-start,\n.fc-rtl .fc-h-event.fc-not-end {\n  margin-left: 0;\n  border-left-width: 0;\n  padding-left: 1px;\n  /* replace the border with padding */\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.fc-ltr .fc-h-event.fc-not-end,\n.fc-rtl .fc-h-event.fc-not-start {\n  margin-right: 0;\n  border-right-width: 0;\n  padding-right: 1px;\n  /* replace the border with padding */\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n/* resizer (cursor AND touch devices) */\n/* left resizer  */\n.fc-ltr .fc-h-event .fc-start-resizer,\n.fc-rtl .fc-h-event .fc-end-resizer {\n  cursor: w-resize;\n  left: -1px;\n  /* overcome border */\n}\n/* right resizer */\n.fc-ltr .fc-h-event .fc-end-resizer,\n.fc-rtl .fc-h-event .fc-start-resizer {\n  cursor: e-resize;\n  right: -1px;\n  /* overcome border */\n}\n/* resizer (mouse devices) */\n.fc-h-event.fc-allow-mouse-resize .fc-resizer {\n  width: 7px;\n  top: -1px;\n  /* overcome top border */\n  bottom: -1px;\n  /* overcome bottom border */\n}\n/* resizer (touch devices) */\n.fc-h-event.fc-selected .fc-resizer {\n  /* 8x8 little dot */\n  border-radius: 4px;\n  border-width: 1px;\n  width: 6px;\n  height: 6px;\n  border-style: solid;\n  border-color: inherit;\n  background: #fff;\n  /* vertically center */\n  top: 50%;\n  margin-top: -4px;\n}\n/* left resizer  */\n.fc-ltr .fc-h-event.fc-selected .fc-start-resizer,\n.fc-rtl .fc-h-event.fc-selected .fc-end-resizer {\n  margin-left: -4px;\n  /* centers the 8x8 dot on the left edge */\n}\n/* right resizer */\n.fc-ltr .fc-h-event.fc-selected .fc-end-resizer,\n.fc-rtl .fc-h-event.fc-selected .fc-start-resizer {\n  margin-right: -4px;\n  /* centers the 8x8 dot on the right edge */\n}\n/* DayGrid events\n----------------------------------------------------------------------------------------------------\nWe use the full \"fc-day-grid-event\" class instead of using descendants because the event won't\nbe a descendant of the grid when it is being dragged.\n*/\n.fc-day-grid-event {\n  margin: 1px 2px 0;\n  /* spacing between events and edges */\n  padding: 0 1px;\n}\ntr:first-child > td > .fc-day-grid-event {\n  margin-top: 2px;\n  /* a little bit more space before the first event */\n}\n.fc-mirror-skeleton tr:first-child > td > .fc-day-grid-event {\n  margin-top: 0;\n  /* except for mirror skeleton */\n}\n.fc-day-grid-event .fc-content {\n  /* force events to be one-line tall */\n  white-space: nowrap;\n  overflow: hidden;\n}\n.fc-day-grid-event .fc-time {\n  font-weight: bold;\n}\n/* resizer (cursor devices) */\n/* left resizer  */\n.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer,\n.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer {\n  margin-left: -2px;\n  /* to the day cell's edge */\n}\n/* right resizer */\n.fc-ltr .fc-day-grid-event.fc-allow-mouse-resize .fc-end-resizer,\n.fc-rtl .fc-day-grid-event.fc-allow-mouse-resize .fc-start-resizer {\n  margin-right: -2px;\n  /* to the day cell's edge */\n}\n/* Event Limiting\n--------------------------------------------------------------------------------------------------*/\n/* \"more\" link that represents hidden events */\na.fc-more {\n  margin: 1px 3px;\n  font-size: 0.85em;\n  cursor: pointer;\n  text-decoration: none;\n}\na.fc-more:hover {\n  text-decoration: underline;\n}\n.fc-limited {\n  /* rows and cells that are hidden because of a \"more\" link */\n  display: none;\n}\n/* popover that appears when \"more\" link is clicked */\n.fc-day-grid .fc-row {\n  z-index: 1;\n  /* make the \"more\" popover one higher than this */\n}\n.fc-more-popover {\n  z-index: 2;\n  width: 220px;\n}\n.fc-more-popover .fc-event-container {\n  padding: 10px;\n}\n/* Now Indicator\n--------------------------------------------------------------------------------------------------*/\n.fc-now-indicator {\n  position: absolute;\n  border: 0 solid red;\n}\n/* Utilities\n--------------------------------------------------------------------------------------------------*/\n.fc-unselectable {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n/*\nTODO: more distinction between this file and common.css\n*/\n/* Colors\n--------------------------------------------------------------------------------------------------*/\n.fc-unthemed th,\n.fc-unthemed td,\n.fc-unthemed thead,\n.fc-unthemed tbody,\n.fc-unthemed .fc-divider,\n.fc-unthemed .fc-row,\n.fc-unthemed .fc-content,\n.fc-unthemed .fc-popover,\n.fc-unthemed .fc-list-view,\n.fc-unthemed .fc-list-heading td {\n  border-color: #ddd;\n}\n.fc-unthemed .fc-popover {\n  background-color: #fff;\n}\n.fc-unthemed .fc-divider,\n.fc-unthemed .fc-popover .fc-header,\n.fc-unthemed .fc-list-heading td {\n  background: #eee;\n}\n.fc-unthemed td.fc-today {\n  background: #fcf8e3;\n}\n.fc-unthemed .fc-disabled-day {\n  background: #d7d7d7;\n  opacity: 0.3;\n}\n/* Icons\n--------------------------------------------------------------------------------------------------\nfrom https://feathericons.com/ and built with IcoMoon\n*/\n@font-face {\n  font-family: \"fcicons\";\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format(\"truetype\");\n  font-weight: normal;\n  font-style: normal;\n}\n.fc-icon {\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: \"fcicons\" !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.fc-icon-chevron-left:before {\n  content: \"\";\n}\n.fc-icon-chevron-right:before {\n  content: \"\";\n}\n.fc-icon-chevrons-left:before {\n  content: \"\";\n}\n.fc-icon-chevrons-right:before {\n  content: \"\";\n}\n.fc-icon-minus-square:before {\n  content: \"\";\n}\n.fc-icon-plus-square:before {\n  content: \"\";\n}\n.fc-icon-x:before {\n  content: \"\";\n}\n.fc-icon {\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  text-align: center;\n}\n/* Buttons\n--------------------------------------------------------------------------------------------------\nLots taken from Flatly (MIT): https://bootswatch.com/4/flatly/bootstrap.css\n*/\n/* reset */\n.fc-button {\n  border-radius: 0;\n  overflow: visible;\n  text-transform: none;\n  margin: 0;\n  font-family: inherit;\n  font-size: inherit;\n  line-height: inherit;\n}\n.fc-button:focus {\n  outline: 1px dotted;\n  outline: 5px auto -webkit-focus-ring-color;\n}\n.fc-button {\n  -webkit-appearance: button;\n}\n.fc-button:not(:disabled) {\n  cursor: pointer;\n}\n.fc-button::-moz-focus-inner {\n  padding: 0;\n  border-style: none;\n}\n/* theme */\n.fc-button {\n  display: inline-block;\n  font-weight: 400;\n  color: #212529;\n  text-align: center;\n  vertical-align: middle;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  background-color: transparent;\n  border: 1px solid transparent;\n  padding: 0.4em 0.65em;\n  font-size: 1em;\n  line-height: 1.5;\n  border-radius: 0.25em;\n}\n.fc-button:hover {\n  color: #212529;\n  text-decoration: none;\n}\n.fc-button:focus {\n  outline: 0;\n  box-shadow: 0 0 0 0.2rem rgba(44, 62, 80, 0.25);\n}\n.fc-button:disabled {\n  opacity: 0.65;\n}\n/* \"primary\" coloring */\n.fc-button-primary {\n  color: #fff;\n  background-color: #2C3E50;\n  border-color: #2C3E50;\n}\n.fc-button-primary:hover {\n  color: #fff;\n  background-color: #1e2b37;\n  border-color: #1a252f;\n}\n.fc-button-primary:focus {\n  box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n}\n.fc-button-primary:disabled {\n  color: #fff;\n  background-color: #2C3E50;\n  border-color: #2C3E50;\n}\n.fc-button-primary:not(:disabled):active,\n.fc-button-primary:not(:disabled).fc-button-active {\n  color: #fff;\n  background-color: #1a252f;\n  border-color: #151e27;\n}\n.fc-button-primary:not(:disabled):active:focus,\n.fc-button-primary:not(:disabled).fc-button-active:focus {\n  box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n}\n/* icons within buttons */\n.fc-button .fc-icon {\n  vertical-align: middle;\n  font-size: 1.5em;\n}\n/* Buttons Groups\n--------------------------------------------------------------------------------------------------*/\n.fc-button-group {\n  position: relative;\n  display: inline-flex;\n  vertical-align: middle;\n}\n.fc-button-group > .fc-button {\n  position: relative;\n  flex: 1 1 auto;\n}\n.fc-button-group > .fc-button:hover {\n  z-index: 1;\n}\n.fc-button-group > .fc-button:focus,\n.fc-button-group > .fc-button:active,\n.fc-button-group > .fc-button.fc-button-active {\n  z-index: 1;\n}\n.fc-button-group > .fc-button:not(:first-child) {\n  margin-left: -1px;\n}\n.fc-button-group > .fc-button:not(:last-child) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.fc-button-group > .fc-button:not(:first-child) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n/* Popover\n--------------------------------------------------------------------------------------------------*/\n.fc-unthemed .fc-popover {\n  border-width: 1px;\n  border-style: solid;\n}\n/* List View\n--------------------------------------------------------------------------------------------------*/\n.fc-unthemed .fc-list-item:hover td {\n  background-color: #f5f5f5;\n}\n/* Toolbar\n--------------------------------------------------------------------------------------------------*/\n.fc-toolbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.fc-toolbar.fc-header-toolbar {\n  margin-bottom: 1.5em;\n}\n.fc-toolbar.fc-footer-toolbar {\n  margin-top: 1.5em;\n}\n/* inner content */\n.fc-toolbar > * > :not(:first-child) {\n  margin-left: 0.75em;\n}\n.fc-toolbar h2 {\n  font-size: 1.75em;\n  margin: 0;\n}\n/* View Structure\n--------------------------------------------------------------------------------------------------*/\n.fc-view-container {\n  position: relative;\n}\n/* undo twitter bootstrap's box-sizing rules. normalizes positioning techniques */\n/* don't do this for the toolbar because we'll want bootstrap to style those buttons as some pt */\n.fc-view-container *,\n.fc-view-container *:before,\n.fc-view-container *:after {\n  box-sizing: content-box;\n}\n.fc-view,\n.fc-view > table {\n  /* so dragged elements can be above the view's main element */\n  position: relative;\n  z-index: 1;\n}\n@media print {\n  .fc {\n    max-width: 100% !important;\n  }\n\n  /* Global Event Restyling\n  --------------------------------------------------------------------------------------------------*/\n  .fc-event {\n    background: #fff !important;\n    color: #000 !important;\n    page-break-inside: avoid;\n  }\n\n  .fc-event .fc-resizer {\n    display: none;\n  }\n\n  /* Table & Day-Row Restyling\n  --------------------------------------------------------------------------------------------------*/\n  .fc th,\n.fc td,\n.fc hr,\n.fc thead,\n.fc tbody,\n.fc-row {\n    border-color: #ccc !important;\n    background: #fff !important;\n  }\n\n  /* kill the overlaid, absolutely-positioned components */\n  /* common... */\n  .fc-bg,\n.fc-bgevent-skeleton,\n.fc-highlight-skeleton,\n.fc-mirror-skeleton,\n.fc-bgevent-container,\n.fc-business-container,\n.fc-highlight-container,\n.fc-mirror-container {\n    display: none;\n  }\n\n  /* don't force a min-height on rows (for DayGrid) */\n  .fc tbody .fc-row {\n    height: auto !important;\n    /* undo height that JS set in distributeHeight */\n    min-height: 0 !important;\n    /* undo the min-height from each view's specific stylesheet */\n  }\n\n  .fc tbody .fc-row .fc-content-skeleton {\n    position: static;\n    /* undo .fc-rigid */\n    padding-bottom: 0 !important;\n    /* use a more border-friendly method for this... */\n  }\n\n  .fc tbody .fc-row .fc-content-skeleton tbody tr:last-child td {\n    /* only works in newer browsers */\n    padding-bottom: 1em;\n    /* ...gives space within the skeleton. also ensures min height in a way */\n  }\n\n  .fc tbody .fc-row .fc-content-skeleton table {\n    /* provides a min-height for the row, but only effective for IE, which exaggerates this value,\n       making it look more like 3em. for other browers, it will already be this tall */\n    height: 1em;\n  }\n\n  /* Undo month-view event limiting. Display all events and hide the \"more\" links\n  --------------------------------------------------------------------------------------------------*/\n  .fc-more-cell,\n.fc-more {\n    display: none !important;\n  }\n\n  .fc tr.fc-limited {\n    display: table-row !important;\n  }\n\n  .fc td.fc-limited {\n    display: table-cell !important;\n  }\n\n  .fc-popover {\n    display: none;\n    /* never display the \"more..\" popover in print mode */\n  }\n\n  /* TimeGrid Restyling\n  --------------------------------------------------------------------------------------------------*/\n  /* undo the min-height 100% trick used to fill the container's height */\n  .fc-time-grid {\n    min-height: 0 !important;\n  }\n\n  /* don't display the side axis at all (\"all-day\" and time cells) */\n  .fc-timeGrid-view .fc-axis {\n    display: none;\n  }\n\n  /* don't display the horizontal lines */\n  .fc-slats,\n.fc-time-grid hr {\n    /* this hr is used when height is underused and needs to be filled */\n    display: none !important;\n    /* important overrides inline declaration */\n  }\n\n  /* let the container that holds the events be naturally positioned and create real height */\n  .fc-time-grid .fc-content-skeleton {\n    position: static;\n  }\n\n  /* in case there are no events, we still want some height */\n  .fc-time-grid .fc-content-skeleton table {\n    height: 4em;\n  }\n\n  /* kill the horizontal spacing made by the event container. event margins will be done below */\n  .fc-time-grid .fc-event-container {\n    margin: 0 !important;\n  }\n\n  /* TimeGrid *Event* Restyling\n  --------------------------------------------------------------------------------------------------*/\n  /* naturally position events, vertically stacking them */\n  .fc-time-grid .fc-event {\n    position: static !important;\n    margin: 3px 2px !important;\n  }\n\n  /* for events that continue to a future day, give the bottom border back */\n  .fc-time-grid .fc-event.fc-not-end {\n    border-bottom-width: 1px !important;\n  }\n\n  /* indicate the event continues via \"...\" text */\n  .fc-time-grid .fc-event.fc-not-end:after {\n    content: \"...\";\n  }\n\n  /* for events that are continuations from previous days, give the top border back */\n  .fc-time-grid .fc-event.fc-not-start {\n    border-top-width: 1px !important;\n  }\n\n  /* indicate the event is a continuation via \"...\" text */\n  .fc-time-grid .fc-event.fc-not-start:before {\n    content: \"...\";\n  }\n\n  /* time */\n  /* undo a previous declaration and let the time text span to a second line */\n  .fc-time-grid .fc-event .fc-time {\n    white-space: normal !important;\n  }\n\n  /* hide the the time that is normally displayed... */\n  .fc-time-grid .fc-event .fc-time span {\n    display: none;\n  }\n\n  /* ...replace it with a more verbose version (includes AM/PM) stored in an html attribute */\n  .fc-time-grid .fc-event .fc-time:after {\n    content: attr(data-full);\n  }\n\n  /* Vertical Scroller & Containers\n  --------------------------------------------------------------------------------------------------*/\n  /* kill the scrollbars and allow natural height */\n  .fc-scroller,\n.fc-day-grid-container,\n.fc-time-grid-container {\n    /* */\n    overflow: visible !important;\n    height: auto !important;\n  }\n\n  /* kill the horizontal border/padding used to compensate for scrollbars */\n  .fc-row {\n    border: 0 !important;\n    margin: 0 !important;\n  }\n\n  /* Button Controls\n  --------------------------------------------------------------------------------------------------*/\n  .fc-button-group,\n.fc button {\n    display: none;\n    /* don't display any button-related controls */\n  }\n}\n/* DayGridView\n--------------------------------------------------------------------------------------------------*/\n/* day row structure */\n.fc-dayGridWeek-view .fc-content-skeleton,\n.fc-dayGridDay-view .fc-content-skeleton {\n  /* there may be week numbers in these views, so no padding-top */\n  padding-bottom: 1em;\n  /* ensure a space at bottom of cell for user selecting/clicking */\n}\n.fc-dayGrid-view .fc-body .fc-row {\n  min-height: 4em;\n  /* ensure that all rows are at least this tall */\n}\n/* a \"rigid\" row will take up a constant amount of height because content-skeleton is absolute */\n.fc-row.fc-rigid {\n  overflow: hidden;\n}\n.fc-row.fc-rigid .fc-content-skeleton {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n}\n/* week and day number styling */\n.fc-day-top.fc-other-month {\n  opacity: 0.3;\n}\n.fc-dayGrid-view .fc-week-number,\n.fc-dayGrid-view .fc-day-number {\n  padding: 2px;\n}\n.fc-dayGrid-view th.fc-week-number,\n.fc-dayGrid-view th.fc-day-number {\n  padding: 0 2px;\n  /* column headers can't have as much v space */\n}\n.fc-ltr .fc-dayGrid-view .fc-day-top .fc-day-number {\n  float: right;\n}\n.fc-rtl .fc-dayGrid-view .fc-day-top .fc-day-number {\n  float: left;\n}\n.fc-ltr .fc-dayGrid-view .fc-day-top .fc-week-number {\n  float: left;\n  border-radius: 0 0 3px 0;\n}\n.fc-rtl .fc-dayGrid-view .fc-day-top .fc-week-number {\n  float: right;\n  border-radius: 0 0 0 3px;\n}\n.fc-dayGrid-view .fc-day-top .fc-week-number {\n  min-width: 1.5em;\n  text-align: center;\n  background-color: #f2f2f2;\n  color: #808080;\n}\n/* when week/day number have own column */\n.fc-dayGrid-view td.fc-week-number {\n  text-align: center;\n}\n.fc-dayGrid-view td.fc-week-number > * {\n  /* work around the way we do column resizing and ensure a minimum width */\n  display: inline-block;\n  min-width: 1.25em;\n}\n.fc-day-grid-event {color: white!important;}\r\n\r\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbWFpbi5jc3MiLCJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY3NzIiwic3JjL2FwcC9jb21wb25lbnRzL3NvZmJveC9mdWxsLWNhbGVuZGFyL2Z1bGwtY2FsZW5kYXIuY29tcG9uZW50LmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0I7QUFDaEI7RUFDRSxjQUFjO0VBQ2QsZ0JBQWdCO0FBQ2xCO0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7QUFFQTtFQUNFLHNDQUFzQztFQUN0QyxjQUFjO0FBQ2hCO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0UsaUNBQWlDO0VBQ2pDLG1CQUFtQjtFQUNuQixZQUFZO0FBQ2Q7QUFFQTtFQUNFLHVDQUF1QztFQUN2QyxtQkFBbUI7RUFDbkIsWUFBWTtBQUNkO0FBRUE7RUFDRSw4Q0FBOEM7RUFDOUMsc0NBQXNDO0VBQ3RDLG1CQUFtQjtBQUNyQjtBQUVBO21HQUNtRztBQUNuRztFQUNFLGtCQUFrQjtFQUNsQix5Q0FBeUM7QUFDM0M7QUFFQTtFQUNFLGtEQUFrRDtFQUNsRCxhQUFhO0VBQ2IsbUJBQW1CO0VBQ25CLDhCQUE4QjtFQUM5QixtQkFBbUI7RUFDbkIsZ0JBQWdCO0FBQ2xCO0FBRUE7RUFDRSwyQkFBMkI7QUFDN0I7QUFFQTtFQUNFLGFBQWE7QUFDZjtBQUVBO0VBQ0UsZUFBZTtFQUNmLGFBQWE7RUFDYixnQkFBZ0I7QUFDbEI7QUFFQTttR0FDbUc7QUFDbkc7RUFDRSxtQkFBbUI7RUFDbkIsaUJBQWlCO0FBQ25CO0FBRUE7RUFDRSxTQUFTO0VBQ1QsU0FBUztFQUNULGdCQUFnQjtFQUNoQix5REFBeUQ7RUFDekQsbUJBQW1CO0FBQ3JCO0FBRUE7Ozs7RUFJRSxnRUFBZ0U7RUFDaEUsa0JBQWtCO0VBQ2xCLE1BQU07RUFDTixPQUFPO0VBQ1AsUUFBUTtBQUNWO0FBRUE7RUFDRSxTQUFTO0VBQ1QsNkJBQTZCO0FBQy9CO0FBRUE7RUFDRSxZQUFZO0VBQ1osNkJBQTZCO0FBQy9CO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0UsV0FBVztFQUNYLHNCQUFzQjtFQUN0QixtQ0FBbUM7RUFDbkMsbUJBQW1CO0VBQ25CLHlCQUF5QjtFQUN6QixpQkFBaUI7RUFDakIsY0FBYztFQUNkLDRCQUE0QjtBQUM5QjtBQUVBO0VBQ0Usa0JBQWtCO0FBQ3BCO0FBRUE7O0VBRUUsbUJBQW1CO0VBQ25CLGlCQUFpQjtFQUNqQixVQUFVO0VBQ1YsbUJBQW1CO0FBQ3JCO0FBRUE7RUFDRSxvQkFBb0I7RUFDcEIsaUNBQWlDO0FBQ25DO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0UsZUFBZTtBQUNqQjtBQUVBO0VBQ0UsMEJBQTBCO0FBQzVCO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0UsNkRBQTZEO0VBQzdELCtGQUErRjtFQUMvRixtQkFBbUI7RUFDbkIsZUFBZTtBQUNqQjtBQUVBO0VBQ0U7NENBQzBDO0VBQzFDLGlDQUFpQztFQUNqQyxrQ0FBa0M7RUFDbEMsOEJBQThCO0VBQzlCLG1DQUFtQztBQUNyQztBQUVBO0VBQ0UsZ0NBQWdDO0VBQ2hDLCtCQUErQjtBQUNqQztBQUVBO21HQUNtRztBQUNuRztFQUNFLGtCQUFrQjtBQUNwQjtBQUVBO0VBQ0UsVUFBVTtBQUNaO0FBRUEsbURBQW1EO0FBQ25EOztFQUVFLFNBQVM7RUFDVCxzQ0FBc0M7QUFDeEM7QUFFQTs7RUFFRSxZQUFZO0VBQ1osc0NBQXNDO0FBQ3hDO0FBRUE7O0VBRUUseUJBQXlCO0FBQzNCO0FBRUE7RUFDRSxVQUFVO0FBQ1o7QUFFQTtFQUNFLFVBQVU7QUFDWjtBQUVBOzs7Q0FHQztBQUNEO0VBQ0Usa0JBQWtCO0VBQ2xCLFVBQVU7RUFDVixtQkFBbUI7RUFDbkIsdUNBQXVDO0FBQ3pDO0FBRUE7RUFDRSxVQUFVO0FBQ1o7QUFFQTs7O0VBR0Usd0NBQXdDO0VBQ3hDLDJEQUEyRDtFQUMzRCxnQkFBZ0I7RUFDaEIsc0NBQXNDO0VBQ3RDLHlCQUF5QjtBQUMzQjtBQUVBOztFQUVFLDREQUE0RDtFQUM1RCxnQkFBZ0I7QUFDbEI7QUFFQTs7RUFFRSwyQ0FBMkM7RUFDM0MsYUFBYTtBQUNmO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0UsaUNBQWlDO0FBQ25DO0FBRUEsbUNBQW1DO0FBQ25DOztFQUVFLGtCQUFrQjtFQUNsQiwyQkFBMkI7RUFDM0IsV0FBVztFQUNYLGdGQUFnRjtBQUNsRjtBQUVBO21HQUNtRztBQUNuRztFQUNFLGtCQUFrQjtFQUNsQixrREFBa0Q7RUFDbEQsY0FBYztFQUNkLDJCQUEyQjtFQUMzQixpQkFBaUI7RUFDakIsZ0JBQWdCO0VBQ2hCLGtCQUFrQjtFQUNsQix5QkFBeUI7QUFDM0I7QUFFQTs7RUFFRSx5QkFBeUI7RUFDekIsNkJBQTZCO0FBQy9CO0FBRUE7O0VBRUUsV0FBVztFQUNYLHVCQUF1QjtFQUN2QixxQkFBcUI7RUFDckIsdUJBQXVCO0FBQ3pCO0FBRUE7O0VBRUUsZUFBZTtFQUNmLHFFQUFxRTtBQUN2RTtBQUVBOztFQUVFLHlDQUF5QztFQUN6QyxtQkFBbUI7QUFDckI7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixVQUFVO0FBQ1o7QUFFQSx1Q0FBdUM7QUFDdkM7RUFDRSxrQkFBa0I7RUFDbEIsVUFBVTtBQUNaO0FBRUEsNEJBQTRCO0FBQzVCO0VBQ0UsYUFBYTtBQUNmO0FBRUE7O0VBRUUscURBQXFEO0VBQ3JELGNBQWM7QUFDaEI7QUFFQSxhQUFhO0FBQ2I7RUFDRSxxQkFBcUI7RUFDckIsV0FBVztFQUNYLGtCQUFrQjtFQUNsQixhQUFhO0VBQ2IsdURBQXVEO0VBQ3ZELFFBQVE7RUFDUixTQUFTO0VBQ1QsV0FBVztFQUNYLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsaUJBQWlCO0FBQ25CO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0Usd0JBQXdCO0VBQ3hCLDZCQUE2QjtFQUM3Qix3Q0FBd0M7QUFDMUM7QUFFQTtFQUNFLFdBQVc7RUFDWCxrQkFBa0I7RUFDbEIsVUFBVTtFQUNWLHVDQUF1QztFQUN2Qyx5QkFBeUI7RUFDekIsU0FBUztFQUNULFdBQVc7RUFDWCxZQUFZO0VBQ1osVUFBVTtFQUNWLHFCQUFxQjtFQUNyQixnQkFBZ0I7RUFDaEIsYUFBYTtBQUNmO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0Usd0NBQXdDO0FBQzFDO0FBRUE7RUFDRSxhQUFhO0FBQ2Y7QUFFQTttR0FDbUc7QUFDbkcsb0NBQW9DO0FBQ3BDO0VBQ0UsV0FBVztFQUNYLGtCQUFrQjtFQUNsQixVQUFVO0VBQ1YsbUJBQW1CO0VBQ25CLFVBQVU7RUFDVixhQUFhO0VBQ2IsT0FBTztFQUNQLFFBQVE7QUFDVjtBQUVBLG1HQUFtRztBQUNuRzs7RUFFRSxjQUFjO0VBQ2Qsb0JBQW9CO0VBQ3BCLGlCQUFpQjtFQUNqQixvQ0FBb0M7RUFDcEMseUJBQXlCO0VBQ3pCLDRCQUE0QjtBQUM5QjtBQUVBOztFQUVFLGVBQWU7RUFDZixxQkFBcUI7RUFDckIsa0JBQWtCO0VBQ2xCLG9DQUFvQztFQUNwQywwQkFBMEI7RUFDMUIsNkJBQTZCO0FBQy9CO0FBRUEsdUNBQXVDO0FBQ3ZDLGtCQUFrQjtBQUNsQjs7RUFFRSxnQkFBZ0I7RUFDaEIsVUFBVTtFQUNWLG9CQUFvQjtBQUN0QjtBQUVBLGtCQUFrQjtBQUNsQjs7RUFFRSxnQkFBZ0I7RUFDaEIsV0FBVztFQUNYLG9CQUFvQjtBQUN0QjtBQUVBLDRCQUE0QjtBQUM1QjtFQUNFLFVBQVU7RUFDVixTQUFTO0VBQ1Qsd0JBQXdCO0VBQ3hCLFlBQVk7RUFDWiwyQkFBMkI7QUFDN0I7QUFFQSw0QkFBNEI7QUFDNUI7RUFDRSxtQkFBbUI7RUFDbkIsa0JBQWtCO0VBQ2xCLGlCQUFpQjtFQUNqQixVQUFVO0VBQ1YsV0FBVztFQUNYLG1CQUFtQjtFQUNuQixxQkFBcUI7RUFDckIsZ0JBQWdCO0VBQ2hCLHNCQUFzQjtFQUN0QixRQUFRO0VBQ1IsZ0JBQWdCO0FBQ2xCO0FBRUEsa0JBQWtCO0FBQ2xCOztFQUVFLGlCQUFpQjtFQUNqQix5Q0FBeUM7QUFDM0M7QUFFQSxrQkFBa0I7QUFDbEI7O0VBRUUsa0JBQWtCO0VBQ2xCLDBDQUEwQztBQUM1QztBQUVBOzs7O0NBSUM7QUFDRDtFQUNFLGlCQUFpQjtFQUNqQixxQ0FBcUM7RUFDckMsY0FBYztBQUNoQjtBQUVBO0VBQ0UsZUFBZTtFQUNmLG1EQUFtRDtBQUNyRDtBQUVBO0VBQ0UsYUFBYTtFQUNiLCtCQUErQjtBQUNqQztBQUVBO0VBQ0UscUNBQXFDO0VBQ3JDLG1CQUFtQjtFQUNuQixnQkFBZ0I7QUFDbEI7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUVBLDZCQUE2QjtBQUM3QixrQkFBa0I7QUFDbEI7O0VBRUUsaUJBQWlCO0VBQ2pCLDJCQUEyQjtBQUM3QjtBQUVBLGtCQUFrQjtBQUNsQjs7RUFFRSxrQkFBa0I7RUFDbEIsMkJBQTJCO0FBQzdCO0FBRUE7bUdBQ21HO0FBQ25HLDhDQUE4QztBQUM5QztFQUNFLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsZUFBZTtFQUNmLHFCQUFxQjtBQUN2QjtBQUVBO0VBQ0UsMEJBQTBCO0FBQzVCO0FBRUE7RUFDRSw0REFBNEQ7RUFDNUQsYUFBYTtBQUNmO0FBRUEscURBQXFEO0FBQ3JEO0VBQ0UsVUFBVTtFQUNWLGlEQUFpRDtBQUNuRDtBQUVBO0VBQ0UsVUFBVTtFQUNWLFlBQVk7QUFDZDtBQUVBO0VBQ0UsYUFBYTtBQUNmO0FBRUE7bUdBQ21HO0FBQ25HO0VBQ0Usa0JBQWtCO0VBQ2xCLG1CQUFtQjtBQUNyQjtBQUVBO21HQUNtRztBQUNuRztFQUNFLHlCQUF5QjtFQUV6QixzQkFBc0I7RUFFdEIsaUJBQWlCO0VBQ2pCLDJCQUEyQjtFQUMzQiw2Q0FBNkM7QUFDL0M7QUFFQTs7Q0FFQztBQUNEO21HQUNtRztBQUNuRzs7Ozs7Ozs7OztFQVVFLGtCQUFrQjtBQUNwQjtBQUVBO0VBQ0Usc0JBQXNCO0FBQ3hCO0FBRUE7OztFQUdFLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0UsbUJBQW1CO0FBQ3JCO0FBRUE7RUFDRSxtQkFBbUI7RUFDbkIsWUFBWTtBQUNkO0FBRUE7OztDQUdDO0FBQ0Q7RUFDRSxzQkFBc0I7RUFDdEIsNG1HQUE0bUc7RUFDNW1HLG1CQUFtQjtFQUNuQixrQkFBa0I7QUFDcEI7QUFDQTtFQUNFLCtFQUErRTtFQUMvRSxpQ0FBaUM7RUFDakMsV0FBVztFQUNYLGtCQUFrQjtFQUNsQixtQkFBbUI7RUFDbkIsb0JBQW9CO0VBQ3BCLG9CQUFvQjtFQUNwQixjQUFjO0VBQ2Qsc0NBQXNDO0VBQ3RDLG1DQUFtQztFQUNuQyxrQ0FBa0M7QUFDcEM7QUFFQTtFQUNFLFlBQVk7QUFDZDtBQUVBO0VBQ0UsWUFBWTtBQUNkO0FBRUE7RUFDRSxZQUFZO0FBQ2Q7QUFFQTtFQUNFLFlBQVk7QUFDZDtBQUVBO0VBQ0UsWUFBWTtBQUNkO0FBRUE7RUFDRSxZQUFZO0FBQ2Q7QUFFQTtFQUNFLFlBQVk7QUFDZDtBQUVBO0VBQ0UscUJBQXFCO0VBQ3JCLFVBQVU7RUFDVixXQUFXO0VBQ1gsa0JBQWtCO0FBQ3BCO0FBRUE7OztDQUdDO0FBQ0QsVUFBVTtBQUNWO0VBQ0UsZ0JBQWdCO0VBQ2hCLGlCQUFpQjtFQUNqQixvQkFBb0I7RUFDcEIsU0FBUztFQUNULG9CQUFvQjtFQUNwQixrQkFBa0I7RUFDbEIsb0JBQW9CO0FBQ3RCO0FBRUE7RUFDRSxtQkFBbUI7RUFDbkIsMENBQTBDO0FBQzVDO0FBRUE7RUFDRSwwQkFBMEI7QUFDNUI7QUFFQTtFQUNFLGVBQWU7QUFDakI7QUFFQTtFQUNFLFVBQVU7RUFDVixrQkFBa0I7QUFDcEI7QUFFQSxVQUFVO0FBQ1Y7RUFDRSxxQkFBcUI7RUFDckIsZ0JBQWdCO0VBQ2hCLGNBQWM7RUFDZCxrQkFBa0I7RUFDbEIsc0JBQXNCO0VBQ3RCLHlCQUF5QjtFQUN6QixzQkFBc0I7RUFFdEIsaUJBQWlCO0VBQ2pCLDZCQUE2QjtFQUM3Qiw2QkFBNkI7RUFDN0IscUJBQXFCO0VBQ3JCLGNBQWM7RUFDZCxnQkFBZ0I7RUFDaEIscUJBQXFCO0FBQ3ZCO0FBRUE7RUFDRSxjQUFjO0VBQ2QscUJBQXFCO0FBQ3ZCO0FBRUE7RUFDRSxVQUFVO0VBRVYsK0NBQStDO0FBQ2pEO0FBRUE7RUFDRSxhQUFhO0FBQ2Y7QUFFQSx1QkFBdUI7QUFDdkI7RUFDRSxXQUFXO0VBQ1gseUJBQXlCO0VBQ3pCLHFCQUFxQjtBQUN2QjtBQUVBO0VBQ0UsV0FBVztFQUNYLHlCQUF5QjtFQUN6QixxQkFBcUI7QUFDdkI7QUFFQTtFQUVFLCtDQUErQztBQUNqRDtBQUVBO0VBQ0UsV0FBVztFQUNYLHlCQUF5QjtFQUN6QixxQkFBcUI7QUFDdkI7QUFFQTs7RUFFRSxXQUFXO0VBQ1gseUJBQXlCO0VBQ3pCLHFCQUFxQjtBQUN2QjtBQUVBOztFQUdFLCtDQUErQztBQUNqRDtBQUVBLHlCQUF5QjtBQUN6QjtFQUNFLHNCQUFzQjtFQUN0QixnQkFBZ0I7QUFDbEI7QUFFQTttR0FDbUc7QUFDbkc7RUFDRSxrQkFBa0I7RUFHbEIsb0JBQW9CO0VBQ3BCLHNCQUFzQjtBQUN4QjtBQUVBO0VBQ0Usa0JBQWtCO0VBR2xCLGNBQWM7QUFDaEI7QUFFQTtFQUNFLFVBQVU7QUFDWjtBQUVBOzs7RUFHRSxVQUFVO0FBQ1o7QUFFQTtFQUNFLGlCQUFpQjtBQUNuQjtBQUVBO0VBQ0UsMEJBQTBCO0VBQzFCLDZCQUE2QjtBQUMvQjtBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLDRCQUE0QjtBQUM5QjtBQUVBO21HQUNtRztBQUNuRztFQUNFLGlCQUFpQjtFQUNqQixtQkFBbUI7QUFDckI7QUFFQTttR0FDbUc7QUFDbkc7RUFDRSx5QkFBeUI7QUFDM0I7QUFFQTttR0FDbUc7QUFDbkc7RUFDRSxhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLG1CQUFtQjtBQUNyQjtBQUVBO0VBQ0Usb0JBQW9CO0FBQ3RCO0FBRUE7RUFDRSxpQkFBaUI7QUFDbkI7QUFFQSxrQkFBa0I7QUFDbEI7RUFDRSxtQkFBbUI7QUFDckI7QUFFQTtFQUNFLGlCQUFpQjtFQUNqQixTQUFTO0FBQ1g7QUFFQTttR0FDbUc7QUFDbkc7RUFDRSxrQkFBa0I7QUFDcEI7QUFFQSxpRkFBaUY7QUFDakYsaUdBQWlHO0FBQ2pHOzs7RUFLRSx1QkFBdUI7QUFDekI7QUFFQTs7RUFFRSw2REFBNkQ7RUFDN0Qsa0JBQWtCO0VBQ2xCLFVBQVU7QUFDWjtBQUVBO0VBQ0U7SUFDRSwwQkFBMEI7RUFDNUI7O0VBRUE7cUdBQ21HO0VBQ25HO0lBQ0UsMkJBQTJCO0lBQzNCLHNCQUFzQjtJQUN0Qix3QkFBd0I7RUFDMUI7O0VBRUE7SUFDRSxhQUFhO0VBQ2Y7O0VBRUE7cUdBQ21HO0VBQ25HOzs7Ozs7SUFNRSw2QkFBNkI7SUFDN0IsMkJBQTJCO0VBQzdCOztFQUVBLHdEQUF3RDtFQUN4RCxjQUFjO0VBQ2Q7Ozs7Ozs7O0lBUUUsYUFBYTtFQUNmOztFQUVBLG1EQUFtRDtFQUNuRDtJQUNFLHVCQUF1QjtJQUN2QixnREFBZ0Q7SUFDaEQsd0JBQXdCO0lBQ3hCLDZEQUE2RDtFQUMvRDs7RUFFQTtJQUNFLGdCQUFnQjtJQUNoQixtQkFBbUI7SUFDbkIsNEJBQTRCO0lBQzVCLGtEQUFrRDtFQUNwRDs7RUFFQTtJQUNFLGlDQUFpQztJQUNqQyxtQkFBbUI7SUFDbkIseUVBQXlFO0VBQzNFOztFQUVBO0lBQ0U7c0ZBQ2tGO0lBQ2xGLFdBQVc7RUFDYjs7RUFFQTtxR0FDbUc7RUFDbkc7O0lBRUUsd0JBQXdCO0VBQzFCOztFQUVBO0lBQ0UsNkJBQTZCO0VBQy9COztFQUVBO0lBQ0UsOEJBQThCO0VBQ2hDOztFQUVBO0lBQ0UsYUFBYTtJQUNiLHFEQUFxRDtFQUN2RDs7RUFFQTtxR0FDbUc7RUFDbkcsdUVBQXVFO0VBQ3ZFO0lBQ0Usd0JBQXdCO0VBQzFCOztFQUVBLGtFQUFrRTtFQUNsRTtJQUNFLGFBQWE7RUFDZjs7RUFFQSx1Q0FBdUM7RUFDdkM7O0lBRUUsb0VBQW9FO0lBQ3BFLHdCQUF3QjtJQUN4QiwyQ0FBMkM7RUFDN0M7O0VBRUEsMkZBQTJGO0VBQzNGO0lBQ0UsZ0JBQWdCO0VBQ2xCOztFQUVBLDJEQUEyRDtFQUMzRDtJQUNFLFdBQVc7RUFDYjs7RUFFQSw4RkFBOEY7RUFDOUY7SUFDRSxvQkFBb0I7RUFDdEI7O0VBRUE7cUdBQ21HO0VBQ25HLHdEQUF3RDtFQUN4RDtJQUNFLDJCQUEyQjtJQUMzQiwwQkFBMEI7RUFDNUI7O0VBRUEsMEVBQTBFO0VBQzFFO0lBQ0UsbUNBQW1DO0VBQ3JDOztFQUVBLGdEQUFnRDtFQUNoRDtJQUNFLGNBQWM7RUFDaEI7O0VBRUEsbUZBQW1GO0VBQ25GO0lBQ0UsZ0NBQWdDO0VBQ2xDOztFQUVBLHdEQUF3RDtFQUN4RDtJQUNFLGNBQWM7RUFDaEI7O0VBRUEsU0FBUztFQUNULDRFQUE0RTtFQUM1RTtJQUNFLDhCQUE4QjtFQUNoQzs7RUFFQSxvREFBb0Q7RUFDcEQ7SUFDRSxhQUFhO0VBQ2Y7O0VBRUEsMkZBQTJGO0VBQzNGO0lBQ0Usd0JBQXdCO0VBQzFCOztFQUVBO3FHQUNtRztFQUNuRyxpREFBaUQ7RUFDakQ7OztJQUdFLElBQUk7SUFDSiw0QkFBNEI7SUFDNUIsdUJBQXVCO0VBQ3pCOztFQUVBLHlFQUF5RTtFQUN6RTtJQUNFLG9CQUFvQjtJQUNwQixvQkFBb0I7RUFDdEI7O0VBRUE7cUdBQ21HO0VBQ25HOztJQUVFLGFBQWE7SUFDYiw4Q0FBOEM7RUFDaEQ7QUFDRjtBQzNoQ0E7bUdBQ21HO0FBQ25HLHNCQUFzQjtBQUN0Qjs7RUFFRSxnRUFBZ0U7RUFDaEUsbUJBQW1CO0VBQ25CLGlFQUFpRTtBQUNuRTtBQUVBO0VBQ0UsZUFBZTtFQUNmLGdEQUFnRDtBQUNsRDtBQUVBLGdHQUFnRztBQUNoRztFQUNFLGdCQUFnQjtBQUNsQjtBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLE1BQU07RUFDTixPQUFPO0VBQ1AsUUFBUTtBQUNWO0FBRUEsZ0NBQWdDO0FBQ2hDO0VBQ0UsWUFBWTtBQUNkO0FBRUE7O0VBRUUsWUFBWTtBQUNkO0FBRUE7O0VBRUUsY0FBYztFQUNkLDhDQUE4QztBQUNoRDtBQUVBO0VBQ0UsWUFBWTtBQUNkO0FBRUE7RUFDRSxXQUFXO0FBQ2I7QUFFQTtFQUNFLFdBQVc7RUFDWCx3QkFBd0I7QUFDMUI7QUFFQTtFQUNFLFlBQVk7RUFDWix3QkFBd0I7QUFDMUI7QUFFQTtFQUNFLGdCQUFnQjtFQUNoQixrQkFBa0I7RUFDbEIseUJBQXlCO0VBQ3pCLGNBQWM7QUFDaEI7QUFFQSx5Q0FBeUM7QUFDekM7RUFDRSxrQkFBa0I7QUFDcEI7QUFFQTtFQUNFLHlFQUF5RTtFQUN6RSxxQkFBcUI7RUFDckIsaUJBQWlCO0FBQ25CO0FDM0VBLG9CQUFvQixzQkFBc0IsQ0FBQyIsImZpbGUiOiJzcmMvYXBwL2NvbXBvbmVudHMvc29mYm94L2Z1bGwtY2FsZW5kYXIvZnVsbC1jYWxlbmRhci5jb21wb25lbnQuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiQGNoYXJzZXQgXCJVVEYtOFwiO1xuLmZjIHtcbiAgZGlyZWN0aW9uOiBsdHI7XG4gIHRleHQtYWxpZ246IGxlZnQ7XG59XG5cbi5mYy1ydGwge1xuICB0ZXh0LWFsaWduOiByaWdodDtcbn1cblxuYm9keSAuZmMge1xuICAvKiBleHRyYSBwcmVjZWRlbmNlIHRvIG92ZXJjb21lIGpxdWkgKi9cbiAgZm9udC1zaXplOiAxZW07XG59XG5cbi8qIENvbG9yc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLWhpZ2hsaWdodCB7XG4gIC8qIHdoZW4gdXNlciBpcyBzZWxlY3RpbmcgY2VsbHMgKi9cbiAgYmFja2dyb3VuZDogI2JjZThmMTtcbiAgb3BhY2l0eTogMC4zO1xufVxuXG4uZmMtYmdldmVudCB7XG4gIC8qIGRlZmF1bHQgbG9vayBmb3IgYmFja2dyb3VuZCBldmVudHMgKi9cbiAgYmFja2dyb3VuZDogIzhmZGY4MjtcbiAgb3BhY2l0eTogMC4zO1xufVxuXG4uZmMtbm9uYnVzaW5lc3Mge1xuICAvKiBkZWZhdWx0IGxvb2sgZm9yIG5vbi1idXNpbmVzcy1ob3VycyBhcmVhcyAqL1xuICAvKiB3aWxsIGluaGVyaXQgLmZjLWJnZXZlbnQncyBzdHlsZXMgKi9cbiAgYmFja2dyb3VuZDogI2Q3ZDdkNztcbn1cblxuLyogUG9wb3ZlclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLXBvcG92ZXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGJveC1zaGFkb3c6IDAgMnB4IDZweCByZ2JhKDAsIDAsIDAsIDAuMTUpO1xufVxuXG4uZmMtcG9wb3ZlciAuZmMtaGVhZGVyIHtcbiAgLyogVE9ETzogYmUgbW9yZSBjb25zaXN0ZW50IHdpdGggZmMtaGVhZC9mYy1ib2R5ICovXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgcGFkZGluZzogMnB4IDRweDtcbn1cblxuLmZjLXJ0bCAuZmMtcG9wb3ZlciAuZmMtaGVhZGVyIHtcbiAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xufVxuXG4uZmMtcG9wb3ZlciAuZmMtaGVhZGVyIC5mYy10aXRsZSB7XG4gIG1hcmdpbjogMCAycHg7XG59XG5cbi5mYy1wb3BvdmVyIC5mYy1oZWFkZXIgLmZjLWNsb3NlIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBvcGFjaXR5OiAwLjY1O1xuICBmb250LXNpemU6IDEuMWVtO1xufVxuXG4vKiBNaXNjIFJldXNhYmxlIENvbXBvbmVudHNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYy1kaXZpZGVyIHtcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XG59XG5cbmhyLmZjLWRpdmlkZXIge1xuICBoZWlnaHQ6IDA7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMCAwIDJweDtcbiAgLyogaGVpZ2h0IGlzIHVucmVsaWFibGUgYWNyb3NzIGJyb3dzZXJzLCBzbyB1c2UgcGFkZGluZyAqL1xuICBib3JkZXItd2lkdGg6IDFweCAwO1xufVxuXG4uZmMtYmcsXG4uZmMtYmdldmVudC1za2VsZXRvbixcbi5mYy1oaWdobGlnaHQtc2tlbGV0b24sXG4uZmMtbWlycm9yLXNrZWxldG9uIHtcbiAgLyogdGhlc2UgZWxlbWVudCBzaG91bGQgYWx3YXlzIGNsaW5nIHRvIHRvcC1sZWZ0L3JpZ2h0IGNvcm5lcnMgKi9cbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xufVxuXG4uZmMtYmcge1xuICBib3R0b206IDA7XG4gIC8qIHN0cmVjaCBiZyB0byBib3R0b20gZWRnZSAqL1xufVxuXG4uZmMtYmcgdGFibGUge1xuICBoZWlnaHQ6IDEwMCU7XG4gIC8qIHN0cmVjaCBiZyB0byBib3R0b20gZWRnZSAqL1xufVxuXG4vKiBUYWJsZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYyB0YWJsZSB7XG4gIHdpZHRoOiAxMDAlO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAvKiBmaXggc2Nyb2xsYmFyIGlzc3VlIGluIGZpcmVmb3ggKi9cbiAgdGFibGUtbGF5b3V0OiBmaXhlZDtcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XG4gIGZvbnQtc2l6ZTogMWVtO1xuICAvKiBub3JtYWxpemUgY3Jvc3MtYnJvd3NlciAqL1xufVxuXG4uZmMgdGgge1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG59XG5cbi5mYyB0aCxcbi5mYyB0ZCB7XG4gIGJvcmRlci1zdHlsZTogc29saWQ7XG4gIGJvcmRlci13aWR0aDogMXB4O1xuICBwYWRkaW5nOiAwO1xuICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xufVxuXG4uZmMgdGQuZmMtdG9kYXkge1xuICBib3JkZXItc3R5bGU6IGRvdWJsZTtcbiAgLyogb3ZlcmNvbWUgbmVpZ2hib3JpbmcgYm9yZGVycyAqL1xufVxuXG4vKiBJbnRlcm5hbCBOYXYgTGlua3Ncbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmFbZGF0YS1nb3RvXSB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuYVtkYXRhLWdvdG9dOmhvdmVyIHtcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG59XG5cbi8qIEZha2UgVGFibGUgUm93c1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjIC5mYy1yb3cge1xuICAvKiBleHRyYSBwcmVjZWRlbmNlIHRvIG92ZXJjb21lIHRoZW1lcyBmb3JjaW5nIGEgMXB4IGJvcmRlciAqL1xuICAvKiBubyB2aXNpYmxlIGJvcmRlciBieSBkZWZhdWx0LiBidXQgbWFrZSBhdmFpbGFibGUgaWYgbmVlZCBiZSAoc2Nyb2xsYmFyIHdpZHRoIGNvbXBlbnNhdGlvbikgKi9cbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgYm9yZGVyLXdpZHRoOiAwO1xufVxuXG4uZmMtcm93IHRhYmxlIHtcbiAgLyogZG9uJ3QgcHV0IGxlZnQvcmlnaHQgYm9yZGVyIG9uIGFueXRoaW5nIHdpdGhpbiBhIGZha2Ugcm93LlxuICAgICB0aGUgb3V0ZXIgdGJvZHkgd2lsbCB3b3JyeSBhYm91dCB0aGlzICovXG4gIGJvcmRlci1sZWZ0OiAwIGhpZGRlbiB0cmFuc3BhcmVudDtcbiAgYm9yZGVyLXJpZ2h0OiAwIGhpZGRlbiB0cmFuc3BhcmVudDtcbiAgLyogbm8gYm90dG9tIGJvcmRlcnMgb24gcm93cyAqL1xuICBib3JkZXItYm90dG9tOiAwIGhpZGRlbiB0cmFuc3BhcmVudDtcbn1cblxuLmZjLXJvdzpmaXJzdC1jaGlsZCB0YWJsZSB7XG4gIGJvcmRlci10b3A6IDAgaGlkZGVuIHRyYW5zcGFyZW50O1xuICAvKiBubyB0b3AgYm9yZGVyIG9uIGZpcnN0IHJvdyAqL1xufVxuXG4vKiBEYXkgUm93ICh1c2VkIHdpdGhpbiB0aGUgaGVhZGVyIGFuZCB0aGUgRGF5R3JpZClcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYy1yb3cge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5mYy1yb3cgLmZjLWJnIHtcbiAgei1pbmRleDogMTtcbn1cblxuLyogaGlnaGxpZ2h0aW5nIGNlbGxzICYgYmFja2dyb3VuZCBldmVudCBza2VsZXRvbiAqL1xuLmZjLXJvdyAuZmMtYmdldmVudC1za2VsZXRvbixcbi5mYy1yb3cgLmZjLWhpZ2hsaWdodC1za2VsZXRvbiB7XG4gIGJvdHRvbTogMDtcbiAgLyogc3RyZXRjaCBza2VsZXRvbiB0byBib3R0b20gb2Ygcm93ICovXG59XG5cbi5mYy1yb3cgLmZjLWJnZXZlbnQtc2tlbGV0b24gdGFibGUsXG4uZmMtcm93IC5mYy1oaWdobGlnaHQtc2tlbGV0b24gdGFibGUge1xuICBoZWlnaHQ6IDEwMCU7XG4gIC8qIHN0cmV0Y2ggc2tlbGV0b24gdG8gYm90dG9tIG9mIHJvdyAqL1xufVxuXG4uZmMtcm93IC5mYy1oaWdobGlnaHQtc2tlbGV0b24gdGQsXG4uZmMtcm93IC5mYy1iZ2V2ZW50LXNrZWxldG9uIHRkIHtcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLmZjLXJvdyAuZmMtYmdldmVudC1za2VsZXRvbiB7XG4gIHotaW5kZXg6IDI7XG59XG5cbi5mYy1yb3cgLmZjLWhpZ2hsaWdodC1za2VsZXRvbiB7XG4gIHotaW5kZXg6IDM7XG59XG5cbi8qXG5yb3cgY29udGVudCAod2hpY2ggY29udGFpbnMgZGF5L3dlZWsgbnVtYmVycyBhbmQgZXZlbnRzKSBhcyB3ZWxsIGFzIFwibWlycm9yXCIgKHdoaWNoIGNvbnRhaW5zXG50ZW1wb3JhcnkgcmVuZGVyZWQgZXZlbnRzKS5cbiovXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiA0O1xuICBwYWRkaW5nLWJvdHRvbTogMnB4O1xuICAvKiBtYXRjaGVzIHRoZSBzcGFjZSBhYm92ZSB0aGUgZXZlbnRzICovXG59XG5cbi5mYy1yb3cgLmZjLW1pcnJvci1za2VsZXRvbiB7XG4gIHotaW5kZXg6IDU7XG59XG5cbi5mYyAuZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRhYmxlLFxuLmZjIC5mYy1yb3cgLmZjLWNvbnRlbnQtc2tlbGV0b24gdGQsXG4uZmMgLmZjLXJvdyAuZmMtbWlycm9yLXNrZWxldG9uIHRkIHtcbiAgLyogc2VlLXRocm91Z2ggdG8gdGhlIGJhY2tncm91bmQgYmVsb3cgKi9cbiAgLyogZXh0cmEgcHJlY2VkZW5jZSB0byBwcmV2ZW50IHRoZW1lLXByb3ZpZGVkIGJhY2tncm91bmRzICovXG4gIGJhY2tncm91bmQ6IG5vbmU7XG4gIC8qIGluIGNhc2UgPHRkPnMgYXJlIGdsb2JhbGx5IHN0eWxlZCAqL1xuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xufVxuXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRkLFxuLmZjLXJvdyAuZmMtbWlycm9yLXNrZWxldG9uIHRkIHtcbiAgLyogZG9uJ3QgcHV0IGEgYm9yZGVyIGJldHdlZW4gZXZlbnRzIGFuZC9vciB0aGUgZGF5IG51bWJlciAqL1xuICBib3JkZXItYm90dG9tOiAwO1xufVxuXG4uZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRib2R5IHRkLFxuLmZjLXJvdyAuZmMtbWlycm9yLXNrZWxldG9uIHRib2R5IHRkIHtcbiAgLyogZG9uJ3QgcHV0IGEgYm9yZGVyIGJldHdlZW4gZXZlbnQgY2VsbHMgKi9cbiAgYm9yZGVyLXRvcDogMDtcbn1cblxuLyogU2Nyb2xsaW5nIENvbnRhaW5lclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLXNjcm9sbGVyIHtcbiAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xufVxuXG4vKiBUT0RPOiBtb3ZlIHRvIHRpbWVncmlkL2RheWdyaWQgKi9cbi5mYy1zY3JvbGxlciA+IC5mYy1kYXktZ3JpZCxcbi5mYy1zY3JvbGxlciA+IC5mYy10aW1lLWdyaWQge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIC8qIHJlLXNjb3BlIGFsbCBwb3NpdGlvbnMgKi9cbiAgd2lkdGg6IDEwMCU7XG4gIC8qIGhhY2sgdG8gZm9yY2UgcmUtc2l6aW5nIHRoaXMgaW5uZXIgZWxlbWVudCB3aGVuIHNjcm9sbGJhcnMgYXBwZWFyL2Rpc2FwcGVhciAqL1xufVxuXG4vKiBHbG9iYWwgRXZlbnQgU3R5bGVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4uZmMtZXZlbnQge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIC8qIGZvciByZXNpemUgaGFuZGxlIGFuZCBvdGhlciBpbm5lciBwb3NpdGlvbmluZyAqL1xuICBkaXNwbGF5OiBibG9jaztcbiAgLyogbWFrZSB0aGUgPGE+IHRhZyBibG9jayAqL1xuICBmb250LXNpemU6IDAuODVlbTtcbiAgbGluZS1oZWlnaHQ6IDEuNDtcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xuICBib3JkZXI6IDFweCBzb2xpZCAjMzc4OGQ4O1xufVxuXG4uZmMtZXZlbnQsXG4uZmMtZXZlbnQtZG90IHtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzM3ODhkODtcbiAgLyogZGVmYXVsdCBCQUNLR1JPVU5EIGNvbG9yICovXG59XG5cbi5mYy1ldmVudCxcbi5mYy1ldmVudDpob3ZlciB7XG4gIGNvbG9yOiAjZmZmO1xuICAvKiBkZWZhdWx0IFRFWFQgY29sb3IgKi9cbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAvKiBpZiA8YT4gaGFzIGFuIGhyZWYgKi9cbn1cblxuLmZjLWV2ZW50W2hyZWZdLFxuLmZjLWV2ZW50LmZjLWRyYWdnYWJsZSB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgLyogZ2l2ZSBldmVudHMgd2l0aCBsaW5rcyBhbmQgZHJhZ2dhYmxlIGV2ZW50cyBhIGhhbmQgbW91c2UgcG9pbnRlciAqL1xufVxuXG4uZmMtbm90LWFsbG93ZWQsXG4uZmMtbm90LWFsbG93ZWQgLmZjLWV2ZW50IHtcbiAgLyogdG8gb3ZlcnJpZGUgYW4gZXZlbnQncyBjdXN0b20gY3Vyc29yICovXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XG59XG5cbi5mYy1ldmVudCAuZmMtY29udGVudCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgei1pbmRleDogMjtcbn1cblxuLyogcmVzaXplciAoY3Vyc29yIEFORCB0b3VjaCBkZXZpY2VzKSAqL1xuLmZjLWV2ZW50IC5mYy1yZXNpemVyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB6LWluZGV4OiA0O1xufVxuXG4vKiByZXNpemVyICh0b3VjaCBkZXZpY2VzKSAqL1xuLmZjLWV2ZW50IC5mYy1yZXNpemVyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLmZjLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtcmVzaXplcixcbi5mYy1ldmVudC5mYy1zZWxlY3RlZCAuZmMtcmVzaXplciB7XG4gIC8qIG9ubHkgc2hvdyB3aGVuIGhvdmVyaW5nIG9yIHNlbGVjdGVkICh3aXRoIHRvdWNoKSAqL1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLyogaGl0IGFyZWEgKi9cbi5mYy1ldmVudC5mYy1zZWxlY3RlZCAuZmMtcmVzaXplcjpiZWZvcmUge1xuICAvKiA0MHg0MCB0b3VjaCBhcmVhICovXG4gIGNvbnRlbnQ6IFwiXCI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogOTk5OTtcbiAgLyogdXNlciBvZiB0aGlzIHV0aWwgY2FuIHNjb3BlIHdpdGhpbiBhIGxvd2VyIHotaW5kZXggKi9cbiAgdG9wOiA1MCU7XG4gIGxlZnQ6IDUwJTtcbiAgd2lkdGg6IDQwcHg7XG4gIGhlaWdodDogNDBweDtcbiAgbWFyZ2luLWxlZnQ6IC0yMHB4O1xuICBtYXJnaW4tdG9wOiAtMjBweDtcbn1cblxuLyogRXZlbnQgU2VsZWN0aW9uIChvbmx5IGZvciB0b3VjaCBkZXZpY2VzKVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLWV2ZW50LmZjLXNlbGVjdGVkIHtcbiAgei1pbmRleDogOTk5OSAhaW1wb3J0YW50O1xuICAvKiBvdmVyY29tZXMgaW5saW5lIHotaW5kZXggKi9cbiAgYm94LXNoYWRvdzogMCAycHggNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbn1cblxuLmZjLWV2ZW50LmZjLXNlbGVjdGVkOmFmdGVyIHtcbiAgY29udGVudDogXCJcIjtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB6LWluZGV4OiAxO1xuICAvKiBzYW1lIHotaW5kZXggYXMgZmMtYmcsIGJlaGluZCB0ZXh0ICovXG4gIC8qIG92ZXJjb21lIHRoZSBib3JkZXJzICovXG4gIHRvcDogLTFweDtcbiAgcmlnaHQ6IC0xcHg7XG4gIGJvdHRvbTogLTFweDtcbiAgbGVmdDogLTFweDtcbiAgLyogZGFya2VuaW5nIGVmZmVjdCAqL1xuICBiYWNrZ3JvdW5kOiAjMDAwO1xuICBvcGFjaXR5OiAwLjI1O1xufVxuXG4vKiBFdmVudCBEcmFnZ2luZ1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLWV2ZW50LmZjLWRyYWdnaW5nLmZjLXNlbGVjdGVkIHtcbiAgYm94LXNoYWRvdzogMCAycHggN3B4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbn1cblxuLmZjLWV2ZW50LmZjLWRyYWdnaW5nOm5vdCguZmMtc2VsZWN0ZWQpIHtcbiAgb3BhY2l0eTogMC43NTtcbn1cblxuLyogSG9yaXpvbnRhbCBFdmVudHNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qIGJpZ2dlciB0b3VjaCBhcmVhIHdoZW4gc2VsZWN0ZWQgKi9cbi5mYy1oLWV2ZW50LmZjLXNlbGVjdGVkOmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgei1pbmRleDogMztcbiAgLyogYmVsb3cgcmVzaXplcnMgKi9cbiAgdG9wOiAtMTBweDtcbiAgYm90dG9tOiAtMTBweDtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG59XG5cbi8qIGV2ZW50cyB0aGF0IGFyZSBjb250aW51aW5nIHRvL2Zyb20gYW5vdGhlciB3ZWVrLiBraWxsIHJvdW5kZWQgY29ybmVycyBhbmQgYnV0dCB1cCBhZ2FpbnN0IGVkZ2UgKi9cbi5mYy1sdHIgLmZjLWgtZXZlbnQuZmMtbm90LXN0YXJ0LFxuLmZjLXJ0bCAuZmMtaC1ldmVudC5mYy1ub3QtZW5kIHtcbiAgbWFyZ2luLWxlZnQ6IDA7XG4gIGJvcmRlci1sZWZ0LXdpZHRoOiAwO1xuICBwYWRkaW5nLWxlZnQ6IDFweDtcbiAgLyogcmVwbGFjZSB0aGUgYm9yZGVyIHdpdGggcGFkZGluZyAqL1xuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xufVxuXG4uZmMtbHRyIC5mYy1oLWV2ZW50LmZjLW5vdC1lbmQsXG4uZmMtcnRsIC5mYy1oLWV2ZW50LmZjLW5vdC1zdGFydCB7XG4gIG1hcmdpbi1yaWdodDogMDtcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwO1xuICBwYWRkaW5nLXJpZ2h0OiAxcHg7XG4gIC8qIHJlcGxhY2UgdGhlIGJvcmRlciB3aXRoIHBhZGRpbmcgKi9cbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xufVxuXG4vKiByZXNpemVyIChjdXJzb3IgQU5EIHRvdWNoIGRldmljZXMpICovXG4vKiBsZWZ0IHJlc2l6ZXIgICovXG4uZmMtbHRyIC5mYy1oLWV2ZW50IC5mYy1zdGFydC1yZXNpemVyLFxuLmZjLXJ0bCAuZmMtaC1ldmVudCAuZmMtZW5kLXJlc2l6ZXIge1xuICBjdXJzb3I6IHctcmVzaXplO1xuICBsZWZ0OiAtMXB4O1xuICAvKiBvdmVyY29tZSBib3JkZXIgKi9cbn1cblxuLyogcmlnaHQgcmVzaXplciAqL1xuLmZjLWx0ciAuZmMtaC1ldmVudCAuZmMtZW5kLXJlc2l6ZXIsXG4uZmMtcnRsIC5mYy1oLWV2ZW50IC5mYy1zdGFydC1yZXNpemVyIHtcbiAgY3Vyc29yOiBlLXJlc2l6ZTtcbiAgcmlnaHQ6IC0xcHg7XG4gIC8qIG92ZXJjb21lIGJvcmRlciAqL1xufVxuXG4vKiByZXNpemVyIChtb3VzZSBkZXZpY2VzKSAqL1xuLmZjLWgtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1yZXNpemVyIHtcbiAgd2lkdGg6IDdweDtcbiAgdG9wOiAtMXB4O1xuICAvKiBvdmVyY29tZSB0b3AgYm9yZGVyICovXG4gIGJvdHRvbTogLTFweDtcbiAgLyogb3ZlcmNvbWUgYm90dG9tIGJvcmRlciAqL1xufVxuXG4vKiByZXNpemVyICh0b3VjaCBkZXZpY2VzKSAqL1xuLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLXJlc2l6ZXIge1xuICAvKiA4eDggbGl0dGxlIGRvdCAqL1xuICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGJvcmRlci13aWR0aDogMXB4O1xuICB3aWR0aDogNnB4O1xuICBoZWlnaHQ6IDZweDtcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0O1xuICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAvKiB2ZXJ0aWNhbGx5IGNlbnRlciAqL1xuICB0b3A6IDUwJTtcbiAgbWFyZ2luLXRvcDogLTRweDtcbn1cblxuLyogbGVmdCByZXNpemVyICAqL1xuLmZjLWx0ciAuZmMtaC1ldmVudC5mYy1zZWxlY3RlZCAuZmMtc3RhcnQtcmVzaXplcixcbi5mYy1ydGwgLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLWVuZC1yZXNpemVyIHtcbiAgbWFyZ2luLWxlZnQ6IC00cHg7XG4gIC8qIGNlbnRlcnMgdGhlIDh4OCBkb3Qgb24gdGhlIGxlZnQgZWRnZSAqL1xufVxuXG4vKiByaWdodCByZXNpemVyICovXG4uZmMtbHRyIC5mYy1oLWV2ZW50LmZjLXNlbGVjdGVkIC5mYy1lbmQtcmVzaXplcixcbi5mYy1ydGwgLmZjLWgtZXZlbnQuZmMtc2VsZWN0ZWQgLmZjLXN0YXJ0LXJlc2l6ZXIge1xuICBtYXJnaW4tcmlnaHQ6IC00cHg7XG4gIC8qIGNlbnRlcnMgdGhlIDh4OCBkb3Qgb24gdGhlIHJpZ2h0IGVkZ2UgKi9cbn1cblxuLyogRGF5R3JpZCBldmVudHNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbldlIHVzZSB0aGUgZnVsbCBcImZjLWRheS1ncmlkLWV2ZW50XCIgY2xhc3MgaW5zdGVhZCBvZiB1c2luZyBkZXNjZW5kYW50cyBiZWNhdXNlIHRoZSBldmVudCB3b24ndFxuYmUgYSBkZXNjZW5kYW50IG9mIHRoZSBncmlkIHdoZW4gaXQgaXMgYmVpbmcgZHJhZ2dlZC5cbiovXG4uZmMtZGF5LWdyaWQtZXZlbnQge1xuICBtYXJnaW46IDFweCAycHggMDtcbiAgLyogc3BhY2luZyBiZXR3ZWVuIGV2ZW50cyBhbmQgZWRnZXMgKi9cbiAgcGFkZGluZzogMCAxcHg7XG59XG5cbnRyOmZpcnN0LWNoaWxkID4gdGQgPiAuZmMtZGF5LWdyaWQtZXZlbnQge1xuICBtYXJnaW4tdG9wOiAycHg7XG4gIC8qIGEgbGl0dGxlIGJpdCBtb3JlIHNwYWNlIGJlZm9yZSB0aGUgZmlyc3QgZXZlbnQgKi9cbn1cblxuLmZjLW1pcnJvci1za2VsZXRvbiB0cjpmaXJzdC1jaGlsZCA+IHRkID4gLmZjLWRheS1ncmlkLWV2ZW50IHtcbiAgbWFyZ2luLXRvcDogMDtcbiAgLyogZXhjZXB0IGZvciBtaXJyb3Igc2tlbGV0b24gKi9cbn1cblxuLmZjLWRheS1ncmlkLWV2ZW50IC5mYy1jb250ZW50IHtcbiAgLyogZm9yY2UgZXZlbnRzIHRvIGJlIG9uZS1saW5lIHRhbGwgKi9cbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuLmZjLWRheS1ncmlkLWV2ZW50IC5mYy10aW1lIHtcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XG59XG5cbi8qIHJlc2l6ZXIgKGN1cnNvciBkZXZpY2VzKSAqL1xuLyogbGVmdCByZXNpemVyICAqL1xuLmZjLWx0ciAuZmMtZGF5LWdyaWQtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1zdGFydC1yZXNpemVyLFxuLmZjLXJ0bCAuZmMtZGF5LWdyaWQtZXZlbnQuZmMtYWxsb3ctbW91c2UtcmVzaXplIC5mYy1lbmQtcmVzaXplciB7XG4gIG1hcmdpbi1sZWZ0OiAtMnB4O1xuICAvKiB0byB0aGUgZGF5IGNlbGwncyBlZGdlICovXG59XG5cbi8qIHJpZ2h0IHJlc2l6ZXIgKi9cbi5mYy1sdHIgLmZjLWRheS1ncmlkLWV2ZW50LmZjLWFsbG93LW1vdXNlLXJlc2l6ZSAuZmMtZW5kLXJlc2l6ZXIsXG4uZmMtcnRsIC5mYy1kYXktZ3JpZC1ldmVudC5mYy1hbGxvdy1tb3VzZS1yZXNpemUgLmZjLXN0YXJ0LXJlc2l6ZXIge1xuICBtYXJnaW4tcmlnaHQ6IC0ycHg7XG4gIC8qIHRvIHRoZSBkYXkgY2VsbCdzIGVkZ2UgKi9cbn1cblxuLyogRXZlbnQgTGltaXRpbmdcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qIFwibW9yZVwiIGxpbmsgdGhhdCByZXByZXNlbnRzIGhpZGRlbiBldmVudHMgKi9cbmEuZmMtbW9yZSB7XG4gIG1hcmdpbjogMXB4IDNweDtcbiAgZm9udC1zaXplOiAwLjg1ZW07XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xufVxuXG5hLmZjLW1vcmU6aG92ZXIge1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbn1cblxuLmZjLWxpbWl0ZWQge1xuICAvKiByb3dzIGFuZCBjZWxscyB0aGF0IGFyZSBoaWRkZW4gYmVjYXVzZSBvZiBhIFwibW9yZVwiIGxpbmsgKi9cbiAgZGlzcGxheTogbm9uZTtcbn1cblxuLyogcG9wb3ZlciB0aGF0IGFwcGVhcnMgd2hlbiBcIm1vcmVcIiBsaW5rIGlzIGNsaWNrZWQgKi9cbi5mYy1kYXktZ3JpZCAuZmMtcm93IHtcbiAgei1pbmRleDogMTtcbiAgLyogbWFrZSB0aGUgXCJtb3JlXCIgcG9wb3ZlciBvbmUgaGlnaGVyIHRoYW4gdGhpcyAqL1xufVxuXG4uZmMtbW9yZS1wb3BvdmVyIHtcbiAgei1pbmRleDogMjtcbiAgd2lkdGg6IDIyMHB4O1xufVxuXG4uZmMtbW9yZS1wb3BvdmVyIC5mYy1ldmVudC1jb250YWluZXIge1xuICBwYWRkaW5nOiAxMHB4O1xufVxuXG4vKiBOb3cgSW5kaWNhdG9yXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4uZmMtbm93LWluZGljYXRvciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYm9yZGVyOiAwIHNvbGlkIHJlZDtcbn1cblxuLyogVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4uZmMtdW5zZWxlY3RhYmxlIHtcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIHVzZXItc2VsZWN0OiBub25lO1xuICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbn1cblxuLypcblRPRE86IG1vcmUgZGlzdGluY3Rpb24gYmV0d2VlbiB0aGlzIGZpbGUgYW5kIGNvbW1vbi5jc3NcbiovXG4vKiBDb2xvcnNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYy11bnRoZW1lZCB0aCxcbi5mYy11bnRoZW1lZCB0ZCxcbi5mYy11bnRoZW1lZCB0aGVhZCxcbi5mYy11bnRoZW1lZCB0Ym9keSxcbi5mYy11bnRoZW1lZCAuZmMtZGl2aWRlcixcbi5mYy11bnRoZW1lZCAuZmMtcm93LFxuLmZjLXVudGhlbWVkIC5mYy1jb250ZW50LFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyLFxuLmZjLXVudGhlbWVkIC5mYy1saXN0LXZpZXcsXG4uZmMtdW50aGVtZWQgLmZjLWxpc3QtaGVhZGluZyB0ZCB7XG4gIGJvcmRlci1jb2xvcjogI2RkZDtcbn1cblxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcbn1cblxuLmZjLXVudGhlbWVkIC5mYy1kaXZpZGVyLFxuLmZjLXVudGhlbWVkIC5mYy1wb3BvdmVyIC5mYy1oZWFkZXIsXG4uZmMtdW50aGVtZWQgLmZjLWxpc3QtaGVhZGluZyB0ZCB7XG4gIGJhY2tncm91bmQ6ICNlZWU7XG59XG5cbi5mYy11bnRoZW1lZCB0ZC5mYy10b2RheSB7XG4gIGJhY2tncm91bmQ6ICNmY2Y4ZTM7XG59XG5cbi5mYy11bnRoZW1lZCAuZmMtZGlzYWJsZWQtZGF5IHtcbiAgYmFja2dyb3VuZDogI2Q3ZDdkNztcbiAgb3BhY2l0eTogMC4zO1xufVxuXG4vKiBJY29uc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZyb20gaHR0cHM6Ly9mZWF0aGVyaWNvbnMuY29tLyBhbmQgYnVpbHQgd2l0aCBJY29Nb29uXG4qL1xuQGZvbnQtZmFjZSB7XG4gIGZvbnQtZmFtaWx5OiBcImZjaWNvbnNcIjtcbiAgc3JjOiB1cmwoXCJkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC10dGY7Y2hhcnNldD11dGYtODtiYXNlNjQsQUFFQUFBQUxBSUFBQXdBd1QxTXZNZzhTQmZBQUFBQzhBQUFBWUdOdFlYQVhWdEtOQUFBQkhBQUFBRlJuWVhOd0FBQUFFQUFBQVhBQUFBQUlaMng1WmdZeWR4SUFBQUY0QUFBRk5HaGxZV1FVSjdjSUFBQUdyQUFBQURab2FHVmhCMjBEekFBQUJ1UUFBQUFrYUcxMGVDSUFCaFFBQUFjSUFBQUFMR3h2WTJFRDRBVTZBQUFITkFBQUFCaHRZWGh3QUE4QWpBQUFCMHdBQUFBZ2JtRnRaWHNyNjkwQUFBZHNBQUFCaG5CdmMzUUFBd0FBQUFBSTlBQUFBQ0FBQXdQQUFaQUFCUUFBQXBrQ3pBQUFBSThDbVFMTUFBQUI2d0F6QVFrQUFBQUFBQUFBQUFBQUFBQUFBQUFCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFEcEJnUEEvOEFBUUFQQUFFQUFBQUFCQUFBQUFBQUFBQUFBQUFBZ0FBQUFBQUFEQUFBQUF3QUFBQndBQVFBREFBQUFIQUFEQUFFQUFBQWNBQVFBT0FBQUFBb0FDQUFDQUFJQUFRQWc2UWIvL2YvL0FBQUFBQUFnNlFELy9mLy9BQUgvNHhjRUFBTUFBUUFBQUFBQUFBQUFBQUFBQVFBQi8vOEFEd0FCQUFBQUFBQUFBQUFBQWdBQU56a0JBQUFBQUFFQUFBQUFBQUFBQUFBQ0FBQTNPUUVBQUFBQUFRQUFBQUFBQUFBQUFBSUFBRGM1QVFBQUFBQUJBV0lBalFLZUFza0FFd0FBSlNjM05qUW5KaUlIQVFZVUZ3RVdNamMyTkNjQ251TGlEUTBNSkF6L0FBME5BUUFNSkF3TkRjbmk0Z3dqRFF3TS93QU5Jd3ovQUEwTkRDTU5BQUFBQVFGaUFJMENuZ0xKQUJNQUFDVUJOalFuQVNZaUJ3WVVId0VIQmhRWEZqSTNBWjRCQUEwTi93QU1KQXdORGVMaURRME1KQXlOQVFBTUl3MEJBQXdNRFNNTTR1SU5Jd3dORFFBQUFBSUE0Z0MzQXg0Q25nQVRBQ2NBQUNVbk56WTBKeVlpRHdFR0ZCOEJGakkzTmpRbklTYzNOalFuSmlJUEFRWVVId0VXTWpjMk5DY0I4N2UzRFEwTUl3M1ZEUTNWRFNNTURRMEJLN2UzRFEwTUpBelZEUTNWRENRTURRM3p1TGNNSkF3TkRkVU5Jd3pXREF3Tkl3eTR0d3drREEwTjFRMGpETllNREEwakRBQUFBZ0RpQUxjREhnS2VBQk1BSndBQUpUYzJOQzhCSmlJSEJoUWZBUWNHRkJjV01qY2hOelkwTHdFbUlnY0dGQjhCQndZVUZ4WXlOd0pKMVEwTjFRMGpEQTBOdDdjTkRRd2pEZjdWMVEwTjFRd2tEQTBOdDdjTkRRd2tETGZXRENNTjFRME5EQ1FNdDdnTUl3ME1ETllNSXczVkRRME1KQXkzdUF3akRRd01BQUFEQUZVQUFBT3JBMVVBTXdCb0FIY0FBQk1pQmdjT0FRY09BUWNPQVJVUkZCWVhIZ0VYSGdFWEhnRXpJVEkyTno0Qk56NEJOejRCTlJFMEppY3VBU2N1QVNjdUFTTUZJVElXRng0QkZ4NEJGeDRCRlJFVUJnY09BUWNPQVFjT0FTTWhJaVluTGdFbkxnRW5MZ0UxRVRRMk56NEJOejRCTno0Qk14TWhNalkxTkNZaklTSUdGUlFXTTlVTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ05BbFlOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTi9hb0NWZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FUOXFnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVNBQVZZUkdSa1IvcW9SR1JrUkExVUZCQVVPQ1FrVkRBc1pEZjJyRFJrTERCVUpDQTRGQlFVRkJRVU9DUWdWREFzWkRRSlZEUmtMREJVSkNRNEZCQVZWQWdFQ0JRTUNCd1FFQ0FYOXF3UUpBd1FIQXdNRkFRSUNBZ0lCQlFNREJ3UURDUVFDVlFVSUJBUUhBZ01GQWdFQy9vQVpFaEVaR1JFU0dRQUFBQUFEQUZVQUFBT3JBMVVBTXdCb0FJa0FBQk1pQmdjT0FRY09BUWNPQVJVUkZCWVhIZ0VYSGdFWEhnRXpJVEkyTno0Qk56NEJOejRCTlJFMEppY3VBU2N1QVNjdUFTTUZJVElXRng0QkZ4NEJGeDRCRlJFVUJnY09BUWNPQVFjT0FTTWhJaVluTGdFbkxnRW5MZ0UxRVRRMk56NEJOejRCTno0Qk14TXpGUlFXTXpJMlBRRXpNalkxTkNZckFUVTBKaU1pQmgwQkl5SUdGUlFXTTlVTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ05BbFlOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTi9hb0NWZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FUOXFnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVNBZ0JrU0VobUFFUmtaRVlBWkVoSVpnQkVaR1JFRFZRVUVCUTRKQ1JVTUN4a04vYXNOR1FzTUZRa0lEZ1VGQlFVRkJRNEpDQlVNQ3hrTkFsVU5HUXNNRlFrSkRnVUVCVlVDQVFJRkF3SUhCQVFJQmYyckJBa0RCQWNEQXdVQkFnSUNBZ0VGQXdNSEJBTUpCQUpWQlFnRUJBY0NBd1VDQVFMK2dJQVNHUmtTZ0JrU0VSbUFFaGtaRW9BWkVSSVpBQUFCQU9JQWpRTWVBc2tBSUFBQUV4Y0hCaFFYRmpJL0FSY1dNamMyTkM4Qk56WTBKeVlpRHdFbkppSUhCaFFYNHVMaURRME1KQXppNGd3a0RBME40dUlORFF3a0RPTGlEQ1FNRFEwQ2plTGlEU01NRFEzaDRRME5EQ01ONHVJTUl3ME1ET0xpREF3Tkl3d0FBQUFCQUFBQUFRQUFhNW4weTE4UFBQVUFDd1FBQUFBQUFOaXZPVnNBQUFBQTJLODVXd0FBQUFBRHF3TlZBQUFBQ0FBQ0FBQUFBQUFBQUFFQUFBUEEvOEFBQUFRQUFBQUFBQU9yQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFMQkFBQUFBQUFBQUFBQUFBQUFnQUFBQVFBQVdJRUFBRmlCQUFBNGdRQUFPSUVBQUJWQkFBQVZRUUFBT0lBQUFBQUFBb0FGQUFlQUVRQWFnQ3FBT29CbmdKa0Fwb0FBUUFBQUFzQWlnQURBQUFBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFyZ0FCQUFBQUFBQUJBQWNBQUFBQkFBQUFBQUFDQUFjQVlBQUJBQUFBQUFBREFBY0FOZ0FCQUFBQUFBQUVBQWNBZFFBQkFBQUFBQUFGQUFzQUZRQUJBQUFBQUFBR0FBY0FTd0FCQUFBQUFBQUtBQm9BaWdBREFBRUVDUUFCQUE0QUJ3QURBQUVFQ1FBQ0FBNEFad0FEQUFFRUNRQURBQTRBUFFBREFBRUVDUUFFQUE0QWZBQURBQUVFQ1FBRkFCWUFJQUFEQUFFRUNRQUdBQTRBVWdBREFBRUVDUUFLQURRQXBHWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMVpsY25OcGIyNGdNUzR3QUZZQVpRQnlBSE1BYVFCdkFHNEFJQUF4QUM0QU1HWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMlpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFKbFozVnNZWElBVWdCbEFHY0FkUUJzQUdFQWNtWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMFp2Ym5RZ1oyVnVaWEpoZEdWa0lHSjVJRWxqYjAxdmIyNHVBRVlBYndCdUFIUUFJQUJuQUdVQWJnQmxBSElBWVFCMEFHVUFaQUFnQUdJQWVRQWdBRWtBWXdCdkFFMEFid0J2QUc0QUxnQUFBQU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPVwiKSBmb3JtYXQoXCJ0cnVldHlwZVwiKTtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xufVxuLmZjLWljb24ge1xuICAvKiB1c2UgIWltcG9ydGFudCB0byBwcmV2ZW50IGlzc3VlcyB3aXRoIGJyb3dzZXIgZXh0ZW5zaW9ucyB0aGF0IGNoYW5nZSBmb250cyAqL1xuICBmb250LWZhbWlseTogXCJmY2ljb25zXCIgIWltcG9ydGFudDtcbiAgc3BlYWs6IG5vbmU7XG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgZm9udC12YXJpYW50OiBub3JtYWw7XG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xuICBsaW5lLWhlaWdodDogMTtcbiAgLyogQmV0dGVyIEZvbnQgUmVuZGVyaW5nID09PT09PT09PT09ICovXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xufVxuXG4uZmMtaWNvbi1jaGV2cm9uLWxlZnQ6YmVmb3JlIHtcbiAgY29udGVudDogXCLupIBcIjtcbn1cblxuLmZjLWljb24tY2hldnJvbi1yaWdodDpiZWZvcmUge1xuICBjb250ZW50OiBcIu6kgVwiO1xufVxuXG4uZmMtaWNvbi1jaGV2cm9ucy1sZWZ0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwi7qSCXCI7XG59XG5cbi5mYy1pY29uLWNoZXZyb25zLXJpZ2h0OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwi7qSDXCI7XG59XG5cbi5mYy1pY29uLW1pbnVzLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIu6khFwiO1xufVxuXG4uZmMtaWNvbi1wbHVzLXNxdWFyZTpiZWZvcmUge1xuICBjb250ZW50OiBcIu6khVwiO1xufVxuXG4uZmMtaWNvbi14OmJlZm9yZSB7XG4gIGNvbnRlbnQ6IFwi7qSGXCI7XG59XG5cbi5mYy1pY29uIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICB3aWR0aDogMWVtO1xuICBoZWlnaHQ6IDFlbTtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG4vKiBCdXR0b25zXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuTG90cyB0YWtlbiBmcm9tIEZsYXRseSAoTUlUKTogaHR0cHM6Ly9ib290c3dhdGNoLmNvbS80L2ZsYXRseS9ib290c3RyYXAuY3NzXG4qL1xuLyogcmVzZXQgKi9cbi5mYy1idXR0b24ge1xuICBib3JkZXItcmFkaXVzOiAwO1xuICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XG4gIG1hcmdpbjogMDtcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XG59XG5cbi5mYy1idXR0b246Zm9jdXMge1xuICBvdXRsaW5lOiAxcHggZG90dGVkO1xuICBvdXRsaW5lOiA1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3I7XG59XG5cbi5mYy1idXR0b24ge1xuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcbn1cblxuLmZjLWJ1dHRvbjpub3QoOmRpc2FibGVkKSB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuLmZjLWJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lciB7XG4gIHBhZGRpbmc6IDA7XG4gIGJvcmRlci1zdHlsZTogbm9uZTtcbn1cblxuLyogdGhlbWUgKi9cbi5mYy1idXR0b24ge1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGZvbnQtd2VpZ2h0OiA0MDA7XG4gIGNvbG9yOiAjMjEyNTI5O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcbiAgcGFkZGluZzogMC40ZW0gMC42NWVtO1xuICBmb250LXNpemU6IDFlbTtcbiAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgYm9yZGVyLXJhZGl1czogMC4yNWVtO1xufVxuXG4uZmMtYnV0dG9uOmhvdmVyIHtcbiAgY29sb3I6ICMyMTI1Mjk7XG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbn1cblxuLmZjLWJ1dHRvbjpmb2N1cyB7XG4gIG91dGxpbmU6IDA7XG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDAgMC4ycmVtIHJnYmEoNDQsIDYyLCA4MCwgMC4yNSk7XG4gIGJveC1zaGFkb3c6IDAgMCAwIDAuMnJlbSByZ2JhKDQ0LCA2MiwgODAsIDAuMjUpO1xufVxuXG4uZmMtYnV0dG9uOmRpc2FibGVkIHtcbiAgb3BhY2l0eTogMC42NTtcbn1cblxuLyogXCJwcmltYXJ5XCIgY29sb3JpbmcgKi9cbi5mYy1idXR0b24tcHJpbWFyeSB7XG4gIGNvbG9yOiAjZmZmO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMkMzRTUwO1xuICBib3JkZXItY29sb3I6ICMyQzNFNTA7XG59XG5cbi5mYy1idXR0b24tcHJpbWFyeTpob3ZlciB7XG4gIGNvbG9yOiAjZmZmO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMWUyYjM3O1xuICBib3JkZXItY29sb3I6ICMxYTI1MmY7XG59XG5cbi5mYy1idXR0b24tcHJpbWFyeTpmb2N1cyB7XG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDAgMC4ycmVtIHJnYmEoNzYsIDkxLCAxMDYsIDAuNSk7XG4gIGJveC1zaGFkb3c6IDAgMCAwIDAuMnJlbSByZ2JhKDc2LCA5MSwgMTA2LCAwLjUpO1xufVxuXG4uZmMtYnV0dG9uLXByaW1hcnk6ZGlzYWJsZWQge1xuICBjb2xvcjogI2ZmZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzJDM0U1MDtcbiAgYm9yZGVyLWNvbG9yOiAjMkMzRTUwO1xufVxuXG4uZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlLFxuLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpLmZjLWJ1dHRvbi1hY3RpdmUge1xuICBjb2xvcjogI2ZmZjtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFhMjUyZjtcbiAgYm9yZGVyLWNvbG9yOiAjMTUxZTI3O1xufVxuXG4uZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3VzLFxuLmZjLWJ1dHRvbi1wcmltYXJ5Om5vdCg6ZGlzYWJsZWQpLmZjLWJ1dHRvbi1hY3RpdmU6Zm9jdXMge1xuICAtd2Via2l0LWJveC1zaGFkb3c6IDAgMCAwIDAuMnJlbSByZ2JhKDc2LCA5MSwgMTA2LCAwLjUpO1xuICBib3gtc2hhZG93OiAwIDAgMCAwLjJyZW0gcmdiYSg3NiwgOTEsIDEwNiwgMC41KTtcbn1cblxuLyogaWNvbnMgd2l0aGluIGJ1dHRvbnMgKi9cbi5mYy1idXR0b24gLmZjLWljb24ge1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICBmb250LXNpemU6IDEuNWVtO1xufVxuXG4vKiBCdXR0b25zIEdyb3Vwc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLWJ1dHRvbi1ncm91cCB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtYm94O1xuICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xufVxuXG4uZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbiB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcbiAgLW1zLWZsZXg6IDEgMSBhdXRvO1xuICBmbGV4OiAxIDEgYXV0bztcbn1cblxuLmZjLWJ1dHRvbi1ncm91cCA+IC5mYy1idXR0b246aG92ZXIge1xuICB6LWluZGV4OiAxO1xufVxuXG4uZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpmb2N1cyxcbi5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uOmFjdGl2ZSxcbi5mYy1idXR0b24tZ3JvdXAgPiAuZmMtYnV0dG9uLmZjLWJ1dHRvbi1hY3RpdmUge1xuICB6LWluZGV4OiAxO1xufVxuXG4uZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKSB7XG4gIG1hcmdpbi1sZWZ0OiAtMXB4O1xufVxuXG4uZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpub3QoOmxhc3QtY2hpbGQpIHtcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAwO1xufVxuXG4uZmMtYnV0dG9uLWdyb3VwID4gLmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKSB7XG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XG59XG5cbi8qIFBvcG92ZXJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYy11bnRoZW1lZCAuZmMtcG9wb3ZlciB7XG4gIGJvcmRlci13aWR0aDogMXB4O1xuICBib3JkZXItc3R5bGU6IHNvbGlkO1xufVxuXG4vKiBMaXN0IFZpZXdcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYy11bnRoZW1lZCAuZmMtbGlzdC1pdGVtOmhvdmVyIHRkIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y1ZjVmNTtcbn1cblxuLyogVG9vbGJhclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLmZjLXRvb2xiYXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG59XG5cbi5mYy10b29sYmFyLmZjLWhlYWRlci10b29sYmFyIHtcbiAgbWFyZ2luLWJvdHRvbTogMS41ZW07XG59XG5cbi5mYy10b29sYmFyLmZjLWZvb3Rlci10b29sYmFyIHtcbiAgbWFyZ2luLXRvcDogMS41ZW07XG59XG5cbi8qIGlubmVyIGNvbnRlbnQgKi9cbi5mYy10b29sYmFyID4gKiA+IDpub3QoOmZpcnN0LWNoaWxkKSB7XG4gIG1hcmdpbi1sZWZ0OiAwLjc1ZW07XG59XG5cbi5mYy10b29sYmFyIGgyIHtcbiAgZm9udC1zaXplOiAxLjc1ZW07XG4gIG1hcmdpbjogMDtcbn1cblxuLyogVmlldyBTdHJ1Y3R1cmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi5mYy12aWV3LWNvbnRhaW5lciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbn1cblxuLyogdW5kbyB0d2l0dGVyIGJvb3RzdHJhcCdzIGJveC1zaXppbmcgcnVsZXMuIG5vcm1hbGl6ZXMgcG9zaXRpb25pbmcgdGVjaG5pcXVlcyAqL1xuLyogZG9uJ3QgZG8gdGhpcyBmb3IgdGhlIHRvb2xiYXIgYmVjYXVzZSB3ZSdsbCB3YW50IGJvb3RzdHJhcCB0byBzdHlsZSB0aG9zZSBidXR0b25zIGFzIHNvbWUgcHQgKi9cbi5mYy12aWV3LWNvbnRhaW5lciAqLFxuLmZjLXZpZXctY29udGFpbmVyICo6YmVmb3JlLFxuLmZjLXZpZXctY29udGFpbmVyICo6YWZ0ZXIge1xuICAtd2Via2l0LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICAtbW96LWJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcbn1cblxuLmZjLXZpZXcsXG4uZmMtdmlldyA+IHRhYmxlIHtcbiAgLyogc28gZHJhZ2dlZCBlbGVtZW50cyBjYW4gYmUgYWJvdmUgdGhlIHZpZXcncyBtYWluIGVsZW1lbnQgKi9cbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB6LWluZGV4OiAxO1xufVxuXG5AbWVkaWEgcHJpbnQge1xuICAuZmMge1xuICAgIG1heC13aWR0aDogMTAwJSAhaW1wb3J0YW50O1xuICB9XG5cbiAgLyogR2xvYmFsIEV2ZW50IFJlc3R5bGluZ1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC5mYy1ldmVudCB7XG4gICAgYmFja2dyb3VuZDogI2ZmZiAhaW1wb3J0YW50O1xuICAgIGNvbG9yOiAjMDAwICFpbXBvcnRhbnQ7XG4gICAgcGFnZS1icmVhay1pbnNpZGU6IGF2b2lkO1xuICB9XG5cbiAgLmZjLWV2ZW50IC5mYy1yZXNpemVyIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLyogVGFibGUgJiBEYXktUm93IFJlc3R5bGluZ1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC5mYyB0aCxcbi5mYyB0ZCxcbi5mYyBocixcbi5mYyB0aGVhZCxcbi5mYyB0Ym9keSxcbi5mYy1yb3cge1xuICAgIGJvcmRlci1jb2xvcjogI2NjYyAhaW1wb3J0YW50O1xuICAgIGJhY2tncm91bmQ6ICNmZmYgIWltcG9ydGFudDtcbiAgfVxuXG4gIC8qIGtpbGwgdGhlIG92ZXJsYWlkLCBhYnNvbHV0ZWx5LXBvc2l0aW9uZWQgY29tcG9uZW50cyAqL1xuICAvKiBjb21tb24uLi4gKi9cbiAgLmZjLWJnLFxuLmZjLWJnZXZlbnQtc2tlbGV0b24sXG4uZmMtaGlnaGxpZ2h0LXNrZWxldG9uLFxuLmZjLW1pcnJvci1za2VsZXRvbixcbi5mYy1iZ2V2ZW50LWNvbnRhaW5lcixcbi5mYy1idXNpbmVzcy1jb250YWluZXIsXG4uZmMtaGlnaGxpZ2h0LWNvbnRhaW5lcixcbi5mYy1taXJyb3ItY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLyogZG9uJ3QgZm9yY2UgYSBtaW4taGVpZ2h0IG9uIHJvd3MgKGZvciBEYXlHcmlkKSAqL1xuICAuZmMgdGJvZHkgLmZjLXJvdyB7XG4gICAgaGVpZ2h0OiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgLyogdW5kbyBoZWlnaHQgdGhhdCBKUyBzZXQgaW4gZGlzdHJpYnV0ZUhlaWdodCAqL1xuICAgIG1pbi1oZWlnaHQ6IDAgIWltcG9ydGFudDtcbiAgICAvKiB1bmRvIHRoZSBtaW4taGVpZ2h0IGZyb20gZWFjaCB2aWV3J3Mgc3BlY2lmaWMgc3R5bGVzaGVldCAqL1xuICB9XG5cbiAgLmZjIHRib2R5IC5mYy1yb3cgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xuICAgIHBvc2l0aW9uOiBzdGF0aWM7XG4gICAgLyogdW5kbyAuZmMtcmlnaWQgKi9cbiAgICBwYWRkaW5nLWJvdHRvbTogMCAhaW1wb3J0YW50O1xuICAgIC8qIHVzZSBhIG1vcmUgYm9yZGVyLWZyaWVuZGx5IG1ldGhvZCBmb3IgdGhpcy4uLiAqL1xuICB9XG5cbiAgLmZjIHRib2R5IC5mYy1yb3cgLmZjLWNvbnRlbnQtc2tlbGV0b24gdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZCB7XG4gICAgLyogb25seSB3b3JrcyBpbiBuZXdlciBicm93c2VycyAqL1xuICAgIHBhZGRpbmctYm90dG9tOiAxZW07XG4gICAgLyogLi4uZ2l2ZXMgc3BhY2Ugd2l0aGluIHRoZSBza2VsZXRvbi4gYWxzbyBlbnN1cmVzIG1pbiBoZWlnaHQgaW4gYSB3YXkgKi9cbiAgfVxuXG4gIC5mYyB0Ym9keSAuZmMtcm93IC5mYy1jb250ZW50LXNrZWxldG9uIHRhYmxlIHtcbiAgICAvKiBwcm92aWRlcyBhIG1pbi1oZWlnaHQgZm9yIHRoZSByb3csIGJ1dCBvbmx5IGVmZmVjdGl2ZSBmb3IgSUUsIHdoaWNoIGV4YWdnZXJhdGVzIHRoaXMgdmFsdWUsXG4gICAgICAgbWFraW5nIGl0IGxvb2sgbW9yZSBsaWtlIDNlbS4gZm9yIG90aGVyIGJyb3dlcnMsIGl0IHdpbGwgYWxyZWFkeSBiZSB0aGlzIHRhbGwgKi9cbiAgICBoZWlnaHQ6IDFlbTtcbiAgfVxuXG4gIC8qIFVuZG8gbW9udGgtdmlldyBldmVudCBsaW1pdGluZy4gRGlzcGxheSBhbGwgZXZlbnRzIGFuZCBoaWRlIHRoZSBcIm1vcmVcIiBsaW5rc1xuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC5mYy1tb3JlLWNlbGwsXG4uZmMtbW9yZSB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICB9XG5cbiAgLmZjIHRyLmZjLWxpbWl0ZWQge1xuICAgIGRpc3BsYXk6IHRhYmxlLXJvdyAhaW1wb3J0YW50O1xuICB9XG5cbiAgLmZjIHRkLmZjLWxpbWl0ZWQge1xuICAgIGRpc3BsYXk6IHRhYmxlLWNlbGwgIWltcG9ydGFudDtcbiAgfVxuXG4gIC5mYy1wb3BvdmVyIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICAgIC8qIG5ldmVyIGRpc3BsYXkgdGhlIFwibW9yZS4uXCIgcG9wb3ZlciBpbiBwcmludCBtb2RlICovXG4gIH1cblxuICAvKiBUaW1lR3JpZCBSZXN0eWxpbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKiB1bmRvIHRoZSBtaW4taGVpZ2h0IDEwMCUgdHJpY2sgdXNlZCB0byBmaWxsIHRoZSBjb250YWluZXIncyBoZWlnaHQgKi9cbiAgLmZjLXRpbWUtZ3JpZCB7XG4gICAgbWluLWhlaWdodDogMCAhaW1wb3J0YW50O1xuICB9XG5cbiAgLyogZG9uJ3QgZGlzcGxheSB0aGUgc2lkZSBheGlzIGF0IGFsbCAoXCJhbGwtZGF5XCIgYW5kIHRpbWUgY2VsbHMpICovXG4gIC5mYy10aW1lR3JpZC12aWV3IC5mYy1heGlzIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgLyogZG9uJ3QgZGlzcGxheSB0aGUgaG9yaXpvbnRhbCBsaW5lcyAqL1xuICAuZmMtc2xhdHMsXG4uZmMtdGltZS1ncmlkIGhyIHtcbiAgICAvKiB0aGlzIGhyIGlzIHVzZWQgd2hlbiBoZWlnaHQgaXMgdW5kZXJ1c2VkIGFuZCBuZWVkcyB0byBiZSBmaWxsZWQgKi9cbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgLyogaW1wb3J0YW50IG92ZXJyaWRlcyBpbmxpbmUgZGVjbGFyYXRpb24gKi9cbiAgfVxuXG4gIC8qIGxldCB0aGUgY29udGFpbmVyIHRoYXQgaG9sZHMgdGhlIGV2ZW50cyBiZSBuYXR1cmFsbHkgcG9zaXRpb25lZCBhbmQgY3JlYXRlIHJlYWwgaGVpZ2h0ICovXG4gIC5mYy10aW1lLWdyaWQgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xuICAgIHBvc2l0aW9uOiBzdGF0aWM7XG4gIH1cblxuICAvKiBpbiBjYXNlIHRoZXJlIGFyZSBubyBldmVudHMsIHdlIHN0aWxsIHdhbnQgc29tZSBoZWlnaHQgKi9cbiAgLmZjLXRpbWUtZ3JpZCAuZmMtY29udGVudC1za2VsZXRvbiB0YWJsZSB7XG4gICAgaGVpZ2h0OiA0ZW07XG4gIH1cblxuICAvKiBraWxsIHRoZSBob3Jpem9udGFsIHNwYWNpbmcgbWFkZSBieSB0aGUgZXZlbnQgY29udGFpbmVyLiBldmVudCBtYXJnaW5zIHdpbGwgYmUgZG9uZSBiZWxvdyAqL1xuICAuZmMtdGltZS1ncmlkIC5mYy1ldmVudC1jb250YWluZXIge1xuICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB9XG5cbiAgLyogVGltZUdyaWQgKkV2ZW50KiBSZXN0eWxpbmdcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKiBuYXR1cmFsbHkgcG9zaXRpb24gZXZlbnRzLCB2ZXJ0aWNhbGx5IHN0YWNraW5nIHRoZW0gKi9cbiAgLmZjLXRpbWUtZ3JpZCAuZmMtZXZlbnQge1xuICAgIHBvc2l0aW9uOiBzdGF0aWMgIWltcG9ydGFudDtcbiAgICBtYXJnaW46IDNweCAycHggIWltcG9ydGFudDtcbiAgfVxuXG4gIC8qIGZvciBldmVudHMgdGhhdCBjb250aW51ZSB0byBhIGZ1dHVyZSBkYXksIGdpdmUgdGhlIGJvdHRvbSBib3JkZXIgYmFjayAqL1xuICAuZmMtdGltZS1ncmlkIC5mYy1ldmVudC5mYy1ub3QtZW5kIHtcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgfVxuXG4gIC8qIGluZGljYXRlIHRoZSBldmVudCBjb250aW51ZXMgdmlhIFwiLi4uXCIgdGV4dCAqL1xuICAuZmMtdGltZS1ncmlkIC5mYy1ldmVudC5mYy1ub3QtZW5kOmFmdGVyIHtcbiAgICBjb250ZW50OiBcIi4uLlwiO1xuICB9XG5cbiAgLyogZm9yIGV2ZW50cyB0aGF0IGFyZSBjb250aW51YXRpb25zIGZyb20gcHJldmlvdXMgZGF5cywgZ2l2ZSB0aGUgdG9wIGJvcmRlciBiYWNrICovXG4gIC5mYy10aW1lLWdyaWQgLmZjLWV2ZW50LmZjLW5vdC1zdGFydCB7XG4gICAgYm9yZGVyLXRvcC13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gIH1cblxuICAvKiBpbmRpY2F0ZSB0aGUgZXZlbnQgaXMgYSBjb250aW51YXRpb24gdmlhIFwiLi4uXCIgdGV4dCAqL1xuICAuZmMtdGltZS1ncmlkIC5mYy1ldmVudC5mYy1ub3Qtc3RhcnQ6YmVmb3JlIHtcbiAgICBjb250ZW50OiBcIi4uLlwiO1xuICB9XG5cbiAgLyogdGltZSAqL1xuICAvKiB1bmRvIGEgcHJldmlvdXMgZGVjbGFyYXRpb24gYW5kIGxldCB0aGUgdGltZSB0ZXh0IHNwYW4gdG8gYSBzZWNvbmQgbGluZSAqL1xuICAuZmMtdGltZS1ncmlkIC5mYy1ldmVudCAuZmMtdGltZSB7XG4gICAgd2hpdGUtc3BhY2U6IG5vcm1hbCAhaW1wb3J0YW50O1xuICB9XG5cbiAgLyogaGlkZSB0aGUgdGhlIHRpbWUgdGhhdCBpcyBub3JtYWxseSBkaXNwbGF5ZWQuLi4gKi9cbiAgLmZjLXRpbWUtZ3JpZCAuZmMtZXZlbnQgLmZjLXRpbWUgc3BhbiB7XG4gICAgZGlzcGxheTogbm9uZTtcbiAgfVxuXG4gIC8qIC4uLnJlcGxhY2UgaXQgd2l0aCBhIG1vcmUgdmVyYm9zZSB2ZXJzaW9uIChpbmNsdWRlcyBBTS9QTSkgc3RvcmVkIGluIGFuIGh0bWwgYXR0cmlidXRlICovXG4gIC5mYy10aW1lLWdyaWQgLmZjLWV2ZW50IC5mYy10aW1lOmFmdGVyIHtcbiAgICBjb250ZW50OiBhdHRyKGRhdGEtZnVsbCk7XG4gIH1cblxuICAvKiBWZXJ0aWNhbCBTY3JvbGxlciAmIENvbnRhaW5lcnNcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAvKiBraWxsIHRoZSBzY3JvbGxiYXJzIGFuZCBhbGxvdyBuYXR1cmFsIGhlaWdodCAqL1xuICAuZmMtc2Nyb2xsZXIsXG4uZmMtZGF5LWdyaWQtY29udGFpbmVyLFxuLmZjLXRpbWUtZ3JpZC1jb250YWluZXIge1xuICAgIC8qICovXG4gICAgb3ZlcmZsb3c6IHZpc2libGUgIWltcG9ydGFudDtcbiAgICBoZWlnaHQ6IGF1dG8gIWltcG9ydGFudDtcbiAgfVxuXG4gIC8qIGtpbGwgdGhlIGhvcml6b250YWwgYm9yZGVyL3BhZGRpbmcgdXNlZCB0byBjb21wZW5zYXRlIGZvciBzY3JvbGxiYXJzICovXG4gIC5mYy1yb3cge1xuICAgIGJvcmRlcjogMCAhaW1wb3J0YW50O1xuICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB9XG5cbiAgLyogQnV0dG9uIENvbnRyb2xzXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgLmZjLWJ1dHRvbi1ncm91cCxcbi5mYyBidXR0b24ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgLyogZG9uJ3QgZGlzcGxheSBhbnkgYnV0dG9uLXJlbGF0ZWQgY29udHJvbHMgKi9cbiAgfVxufVxuIiwiLyogRGF5R3JpZFZpZXdcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qIGRheSByb3cgc3RydWN0dXJlICovXG4uZmMtZGF5R3JpZFdlZWstdmlldyAuZmMtY29udGVudC1za2VsZXRvbixcbi5mYy1kYXlHcmlkRGF5LXZpZXcgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xuICAvKiB0aGVyZSBtYXkgYmUgd2VlayBudW1iZXJzIGluIHRoZXNlIHZpZXdzLCBzbyBubyBwYWRkaW5nLXRvcCAqL1xuICBwYWRkaW5nLWJvdHRvbTogMWVtO1xuICAvKiBlbnN1cmUgYSBzcGFjZSBhdCBib3R0b20gb2YgY2VsbCBmb3IgdXNlciBzZWxlY3RpbmcvY2xpY2tpbmcgKi9cbn1cblxuLmZjLWRheUdyaWQtdmlldyAuZmMtYm9keSAuZmMtcm93IHtcbiAgbWluLWhlaWdodDogNGVtO1xuICAvKiBlbnN1cmUgdGhhdCBhbGwgcm93cyBhcmUgYXQgbGVhc3QgdGhpcyB0YWxsICovXG59XG5cbi8qIGEgXCJyaWdpZFwiIHJvdyB3aWxsIHRha2UgdXAgYSBjb25zdGFudCBhbW91bnQgb2YgaGVpZ2h0IGJlY2F1c2UgY29udGVudC1za2VsZXRvbiBpcyBhYnNvbHV0ZSAqL1xuLmZjLXJvdy5mYy1yaWdpZCB7XG4gIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5mYy1yb3cuZmMtcmlnaWQgLmZjLWNvbnRlbnQtc2tlbGV0b24ge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgcmlnaHQ6IDA7XG59XG5cbi8qIHdlZWsgYW5kIGRheSBudW1iZXIgc3R5bGluZyAqL1xuLmZjLWRheS10b3AuZmMtb3RoZXItbW9udGgge1xuICBvcGFjaXR5OiAwLjM7XG59XG5cbi5mYy1kYXlHcmlkLXZpZXcgLmZjLXdlZWstbnVtYmVyLFxuLmZjLWRheUdyaWQtdmlldyAuZmMtZGF5LW51bWJlciB7XG4gIHBhZGRpbmc6IDJweDtcbn1cblxuLmZjLWRheUdyaWQtdmlldyB0aC5mYy13ZWVrLW51bWJlcixcbi5mYy1kYXlHcmlkLXZpZXcgdGguZmMtZGF5LW51bWJlciB7XG4gIHBhZGRpbmc6IDAgMnB4O1xuICAvKiBjb2x1bW4gaGVhZGVycyBjYW4ndCBoYXZlIGFzIG11Y2ggdiBzcGFjZSAqL1xufVxuXG4uZmMtbHRyIC5mYy1kYXlHcmlkLXZpZXcgLmZjLWRheS10b3AgLmZjLWRheS1udW1iZXIge1xuICBmbG9hdDogcmlnaHQ7XG59XG5cbi5mYy1ydGwgLmZjLWRheUdyaWQtdmlldyAuZmMtZGF5LXRvcCAuZmMtZGF5LW51bWJlciB7XG4gIGZsb2F0OiBsZWZ0O1xufVxuXG4uZmMtbHRyIC5mYy1kYXlHcmlkLXZpZXcgLmZjLWRheS10b3AgLmZjLXdlZWstbnVtYmVyIHtcbiAgZmxvYXQ6IGxlZnQ7XG4gIGJvcmRlci1yYWRpdXM6IDAgMCAzcHggMDtcbn1cblxuLmZjLXJ0bCAuZmMtZGF5R3JpZC12aWV3IC5mYy1kYXktdG9wIC5mYy13ZWVrLW51bWJlciB7XG4gIGZsb2F0OiByaWdodDtcbiAgYm9yZGVyLXJhZGl1czogMCAwIDAgM3B4O1xufVxuXG4uZmMtZGF5R3JpZC12aWV3IC5mYy1kYXktdG9wIC5mYy13ZWVrLW51bWJlciB7XG4gIG1pbi13aWR0aDogMS41ZW07XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YyZjJmMjtcbiAgY29sb3I6ICM4MDgwODA7XG59XG5cbi8qIHdoZW4gd2Vlay9kYXkgbnVtYmVyIGhhdmUgb3duIGNvbHVtbiAqL1xuLmZjLWRheUdyaWQtdmlldyB0ZC5mYy13ZWVrLW51bWJlciB7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbn1cblxuLmZjLWRheUdyaWQtdmlldyB0ZC5mYy13ZWVrLW51bWJlciA+ICoge1xuICAvKiB3b3JrIGFyb3VuZCB0aGUgd2F5IHdlIGRvIGNvbHVtbiByZXNpemluZyBhbmQgZW5zdXJlIGEgbWluaW11bSB3aWR0aCAqL1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIG1pbi13aWR0aDogMS4yNWVtO1xufVxuIiwiQGltcG9ydCAnfkBmdWxsY2FsZW5kYXIvY29yZS9tYWluLmNzcyc7XHJcbkBpbXBvcnQgJ35AZnVsbGNhbGVuZGFyL2RheWdyaWQvbWFpbi5jc3MnO1xyXG4uZmMtZGF5LWdyaWQtZXZlbnQge2NvbG9yOiB3aGl0ZSFpbXBvcnRhbnQ7fVxyXG4iXX0= */";
    /***/
  },

  /***/
  "./src/app/components/sofbox/full-calendar/full-calendar.component.ts":
  /*!****************************************************************************!*\
    !*** ./src/app/components/sofbox/full-calendar/full-calendar.component.ts ***!
    \****************************************************************************/

  /*! exports provided: FullCalendarComponent */

  /***/
  function srcAppComponentsSofboxFullCalendarFullCalendarComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FullCalendarComponent", function () {
      return FullCalendarComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @fullcalendar/daygrid */
    "./node_modules/@fullcalendar/daygrid/main.esm.js");
    /* harmony import */


    var _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! @fullcalendar/timegrid */
    "./node_modules/@fullcalendar/timegrid/main.esm.js");

    var FullCalendarComponent = /*#__PURE__*/function () {
      function FullCalendarComponent() {
        _classCallCheck(this, FullCalendarComponent);

        this.calendarWeekends = true;
        this.calendarPlugins = [_fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_2__["default"], _fullcalendar_timegrid__WEBPACK_IMPORTED_MODULE_3__["default"]];
      }

      _createClass(FullCalendarComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return FullCalendarComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], FullCalendarComponent.prototype, "calendarWeekends", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], FullCalendarComponent.prototype, "calendarPlugins", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], FullCalendarComponent.prototype, "calendarEvents", void 0);
    FullCalendarComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-full-calendar',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./full-calendar.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/full-calendar/full-calendar.component.html"))["default"],
      encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_1__["ViewEncapsulation"].None,
      styles: [Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! ./full-calendar.component.css */
      "./src/app/components/sofbox/full-calendar/full-calendar.component.css"))["default"]]
    })], FullCalendarComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/loaders/loader1/loader.component.ts":
  /*!***********************************************************************!*\
    !*** ./src/app/components/sofbox/loaders/loader1/loader.component.ts ***!
    \***********************************************************************/

  /*! exports provided: LoaderComponent */

  /***/
  function srcAppComponentsSofboxLoadersLoader1LoaderComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LoaderComponent", function () {
      return LoaderComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var LoaderComponent = /*#__PURE__*/function () {
      function LoaderComponent() {
        _classCallCheck(this, LoaderComponent);
      }

      _createClass(LoaderComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return LoaderComponent;
    }();

    LoaderComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-loader',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./loader.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/loaders/loader1/loader.component.html"))["default"]
    })], LoaderComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/scroll-top/scroll-top.component.ts":
  /*!**********************************************************************!*\
    !*** ./src/app/components/sofbox/scroll-top/scroll-top.component.ts ***!
    \**********************************************************************/

  /*! exports provided: ScrollTopComponent */

  /***/
  function srcAppComponentsSofboxScrollTopScrollTopComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ScrollTopComponent", function () {
      return ScrollTopComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! jquery */
    "./node_modules/jquery/dist/jquery.js");
    /* harmony import */


    var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);

    var ScrollTopComponent = /*#__PURE__*/function () {
      function ScrollTopComponent() {
        _classCallCheck(this, ScrollTopComponent);
      }

      _createClass(ScrollTopComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }, {
        key: "scrollTop",
        value: function scrollTop() {
          jquery__WEBPACK_IMPORTED_MODULE_2__('body,html').animate({
            scrollTop: 0
          }, 800);
        }
      }]);

      return ScrollTopComponent;
    }();

    ScrollTopComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-scroll-top',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./scroll-top.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/scroll-top/scroll-top.component.html"))["default"]
    })], ScrollTopComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/sofbox.module.ts":
  /*!****************************************************!*\
    !*** ./src/app/components/sofbox/sofbox.module.ts ***!
    \****************************************************/

  /*! exports provided: SofboxModule */

  /***/
  function srcAppComponentsSofboxSofboxModuleTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SofboxModule", function () {
      return SofboxModule;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");
    /* harmony import */


    var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! @angular/common */
    "./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js");
    /* harmony import */


    var _loaders_loader1_loader_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./loaders/loader1/loader.component */
    "./src/app/components/sofbox/loaders/loader1/loader.component.ts");
    /* harmony import */


    var _scroll_top_scroll_top_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./scroll-top/scroll-top.component */
    "./src/app/components/sofbox/scroll-top/scroll-top.component.ts");
    /* harmony import */


    var _charts_apex_chart_apex_chart_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./charts/apex-chart/apex-chart.component */
    "./src/app/components/sofbox/charts/apex-chart/apex-chart.component.ts");
    /* harmony import */


    var _breadcrumbs_breadcrumb1_breadcrumb1_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./breadcrumbs/breadcrumb1/breadcrumb1.component */
    "./src/app/components/sofbox/breadcrumbs/breadcrumb1/breadcrumb1.component.ts");
    /* harmony import */


    var _cards_iq_card_iq_card_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./cards/iq-card/iq-card.component */
    "./src/app/components/sofbox/cards/iq-card/iq-card.component.ts");
    /* harmony import */


    var ngx_scrollbar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ngx-scrollbar */
    "./node_modules/ngx-scrollbar/__ivy_ngcc__/fesm2015/ngx-scrollbar.js");
    /* harmony import */


    var _charts_high_chart_high_chart_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ./charts/high-chart/high-chart.component */
    "./src/app/components/sofbox/charts/high-chart/high-chart.component.ts");
    /* harmony import */


    var _angular_router__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! @angular/router */
    "./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js");
    /* harmony import */


    var _tabs_tab_nav_tab_nav_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! ./tabs/tab-nav/tab-nav.component */
    "./src/app/components/sofbox/tabs/tab-nav/tab-nav.component.ts");
    /* harmony import */


    var _tabs_tab_content_tab_content_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! ./tabs/tab-content/tab-content.component */
    "./src/app/components/sofbox/tabs/tab-content/tab-content.component.ts");
    /* harmony import */


    var _full_calendar_full_calendar_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! ./full-calendar/full-calendar.component */
    "./src/app/components/sofbox/full-calendar/full-calendar.component.ts");
    /* harmony import */


    var _fullcalendar_angular__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! @fullcalendar/angular */
    "./node_modules/@fullcalendar/angular/__ivy_ngcc__/fesm2015/fullcalendar-angular.js");
    /* harmony import */


    var _card_with_image_card_with_image_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! ./card-with-image/card-with-image.component */
    "./src/app/components/sofbox/card-with-image/card-with-image.component.ts");
    /* harmony import */


    var ngx_bootstrap_collapse__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! ngx-bootstrap/collapse */
    "./node_modules/ngx-bootstrap/__ivy_ngcc__/collapse/fesm2015/ngx-bootstrap-collapse.js");

    var SofboxModule = /*#__PURE__*/_createClass(function SofboxModule() {
      _classCallCheck(this, SofboxModule);
    });

    SofboxModule = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["NgModule"])({
      declarations: [_loaders_loader1_loader_component__WEBPACK_IMPORTED_MODULE_3__["LoaderComponent"], _scroll_top_scroll_top_component__WEBPACK_IMPORTED_MODULE_4__["ScrollTopComponent"], _charts_apex_chart_apex_chart_component__WEBPACK_IMPORTED_MODULE_5__["ApexChartComponent"], _breadcrumbs_breadcrumb1_breadcrumb1_component__WEBPACK_IMPORTED_MODULE_6__["Breadcrumb1Component"], _cards_iq_card_iq_card_component__WEBPACK_IMPORTED_MODULE_7__["IqCardComponent"], _tabs_tab_nav_tab_nav_component__WEBPACK_IMPORTED_MODULE_11__["TabNavComponent"], _tabs_tab_content_tab_content_component__WEBPACK_IMPORTED_MODULE_12__["TabContentComponent"], _charts_high_chart_high_chart_component__WEBPACK_IMPORTED_MODULE_9__["HighChartComponent"], _full_calendar_full_calendar_component__WEBPACK_IMPORTED_MODULE_13__["FullCalendarComponent"], _card_with_image_card_with_image_component__WEBPACK_IMPORTED_MODULE_15__["CardWithImageComponent"]],
      exports: [_loaders_loader1_loader_component__WEBPACK_IMPORTED_MODULE_3__["LoaderComponent"], _scroll_top_scroll_top_component__WEBPACK_IMPORTED_MODULE_4__["ScrollTopComponent"], _charts_apex_chart_apex_chart_component__WEBPACK_IMPORTED_MODULE_5__["ApexChartComponent"], _breadcrumbs_breadcrumb1_breadcrumb1_component__WEBPACK_IMPORTED_MODULE_6__["Breadcrumb1Component"], _cards_iq_card_iq_card_component__WEBPACK_IMPORTED_MODULE_7__["IqCardComponent"], _tabs_tab_nav_tab_nav_component__WEBPACK_IMPORTED_MODULE_11__["TabNavComponent"], _tabs_tab_content_tab_content_component__WEBPACK_IMPORTED_MODULE_12__["TabContentComponent"], _charts_high_chart_high_chart_component__WEBPACK_IMPORTED_MODULE_9__["HighChartComponent"], _full_calendar_full_calendar_component__WEBPACK_IMPORTED_MODULE_13__["FullCalendarComponent"], _card_with_image_card_with_image_component__WEBPACK_IMPORTED_MODULE_15__["CardWithImageComponent"]],
      imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__["CommonModule"], ngx_scrollbar__WEBPACK_IMPORTED_MODULE_8__["NgScrollbarModule"], _angular_router__WEBPACK_IMPORTED_MODULE_10__["RouterModule"], _fullcalendar_angular__WEBPACK_IMPORTED_MODULE_14__["FullCalendarModule"], ngx_bootstrap_collapse__WEBPACK_IMPORTED_MODULE_16__["CollapseModule"].forRoot()]
    })], SofboxModule);
    /***/
  },

  /***/
  "./src/app/components/sofbox/tabs/tab-content/tab-content.component.ts":
  /*!*****************************************************************************!*\
    !*** ./src/app/components/sofbox/tabs/tab-content/tab-content.component.ts ***!
    \*****************************************************************************/

  /*! exports provided: TabContentComponent */

  /***/
  function srcAppComponentsSofboxTabsTabContentTabContentComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TabContentComponent", function () {
      return TabContentComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var TabContentComponent = /*#__PURE__*/function () {
      function TabContentComponent() {
        _classCallCheck(this, TabContentComponent);

        this.tabContentClass = 'tab-pane fade';
      }

      _createClass(TabContentComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return TabContentComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], TabContentComponent.prototype, "tabContentClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], TabContentComponent.prototype, "tabContentLink", void 0);
    TabContentComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-tab-content',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./tab-content.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/tabs/tab-content/tab-content.component.html"))["default"]
    })], TabContentComponent);
    /***/
  },

  /***/
  "./src/app/components/sofbox/tabs/tab-nav/tab-nav.component.ts":
  /*!*********************************************************************!*\
    !*** ./src/app/components/sofbox/tabs/tab-nav/tab-nav.component.ts ***!
    \*********************************************************************/

  /*! exports provided: TabNavComponent */

  /***/
  function srcAppComponentsSofboxTabsTabNavTabNavComponentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TabNavComponent", function () {
      return TabNavComponent;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js");

    var TabNavComponent = /*#__PURE__*/function () {
      function TabNavComponent() {
        _classCallCheck(this, TabNavComponent);

        this.tabClass = 'nav nav-pills';
        this.tagToggleType = 'pill';
        this.tabNavItems = [];
      }

      _createClass(TabNavComponent, [{
        key: "ngOnInit",
        value: function ngOnInit() {}
      }]);

      return TabNavComponent;
    }();

    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], TabNavComponent.prototype, "tabClass", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], TabNavComponent.prototype, "tagToggleType", void 0);
    Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Input"])()], TabNavComponent.prototype, "tabNavItems", void 0);
    TabNavComponent = Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__decorate"])([Object(_angular_core__WEBPACK_IMPORTED_MODULE_1__["Component"])({
      selector: 'app-tab-nav',
      template: Object(tslib__WEBPACK_IMPORTED_MODULE_0__["__importDefault"])(__webpack_require__(
      /*! raw-loader!./tab-nav.component.html */
      "./node_modules/raw-loader/dist/cjs.js!./src/app/components/sofbox/tabs/tab-nav/tab-nav.component.html"))["default"]
    })], TabNavComponent);
    /***/
  }
}]);
//# sourceMappingURL=default~layouts-auth-auth-module~pages-dashboard-dashboard-module~pages-relatorios-relatorios-module-es5.js.map